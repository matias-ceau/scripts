{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"albumplayer.xsh -- Pick a cmus album via dmenu, enqueue it plus 10 random albums ansi-cheatsheet.sh -- Quickly displays a cheatsheet of ANSI escape codes in a syntax-highlighted view ansi8bit2rgb_hex.py -- Converts 8-bit ANSI color codes to RGB or HEX representations with optional colorized output and names ardour-open.sh -- Fuzzy-pick and open Ardour sessions with colored list and bat preview build_and_link.sh -- Compile C/C++ or install Python app into $SCRIPTS/bin and symlink into repo root chatgpt-all-scripts-describer.py -- A Python script to generate documentation for other scripts using OpenAI's GPT API. chezmoi_on_a_new_system.sh -- Script to initialize and apply Chezmoi configuration for user 'matias-ceau'. citeboard.sh -- Find academic references by citation key, copy their identifier, or open associated PDFs. closest_colors.py -- Find the closest matching terminal color for a list of color hex codes. color_restrict.py -- Restricts image colors to those in a custom palette with optional resizing. colormap_from_text.sh -- Extracts and displays unique color codes from text or config files in various formats command_prompt.sh -- Interactive shell history picker via fzf wrapper count_tokens_with_tiktoken.py -- Count token usage for a text file or stdin using OpenAI tiktoken . create_cover_art.sh -- generates a cover image by creating a spectrogram from a selected .wav file. desk_fzf.sh -- Quickly search and launch .desktop applications using fzf and a cached file listing. display_markdown.py -- Script to display markdown files in the terminal with styling dmenu_run_scripts.py -- Presents a list of runnable scripts via rofi integrated with xonsh for selection and execution. dmenu_run_scripts.xsh -- A script to run user scripts via dmenu or rofi. edit_chezmoi_cfg_files.sh -- Fuzzy-find and edit dotfiles managed by chezmoi, with preview and optional sync/apply. edit_chezmoi_cfg_files.sh -- Script to search and edit Chezmoi managed configuration files and directories. editor.sh -- Quickly edit files using fzf, with smart search modes and exclusions. env.sh -- Modular environment loader for colors, FZF, paths, git and debug fix-markdown-links.sh -- Adjust relative paths in markdown links to start from a base directory flexoki_show.sh -- Script to visually display the Flexoki color palette and roles in your terminal ftp-data-mount.sh -- Mounts a remote DATA folder from Mega via FTP to /mnt/ftp/DATA fzf-file-manager.sh -- Interactive terminal-based file manager leveraging fzf and eza for rapid navigation. fzf_albumlauncher.xsh -- Pick an album via fzf and queue/play it in cmus fzfmenu.sh -- Helper script that runs fzf inside an alacritty terminal instance. fzfmenu_cache.sh -- Cache PATH executables to RAM and print them, with background refresh fzfmenu_run.sh -- Launches app selection using fzf in a floating terminal, as a dmenu_run replacement. fzfpreview.sh -- Display file or image contents in fzf preview window using various tools and fallback logic generate_commit_message.py -- Generate commit messages from staged diff via OpenRouter; safe fallback generate_commit_message.sh -- Script to generate commit messages using OpenAI's GPT-4o-mini get-window-thumbnails.sh -- Creates thumbnails of currently open windows on your qtile environment. get-windows.sh -- Outputs information about currently open windows in qtile (ID, group, name, wm_class) get_hyperlinks_in_folder.py -- Scans a folder of markdown notes and builds a hyperlink graph visualization. get_repos_present_on_host.sh -- List and register two-level git repos present under $GIT_REPOS for this host. get_scripts_relations.py -- Scans user scripts to detect and visualize script dependencies. get_scripts_relations.xsh -- Scans $SCRIPTS directory for scripts and visualizes intra-folder dependencies as a directed graph git_cd.sh -- Quickly cd to any git project directory found on the system using a fuzzy search. git_clone_by_author-repo.sh -- Clone a GitHub repository via SSH, HTTPS, or from a local path with developer-oriented subfolder convention. git_update_all_other_repos.sh -- Batch-pulls all git repositories (with HTTPS remote) at exact depth 3 under $GIT_REPOS grub-tune-to-audio-python.py -- Converts a GRUB_INIT_TUNE string into an MP3 audio file gsi.sh -- Interactive, robust script for syncing a local Git repository with its remote, handling merges, conflicts, and summary display. help-pastel.sh -- Enhanced interactive subcommand and help browser for pastel CLI. help_pwcli.sh -- Interactive helper for PipeWire CLI tools, displays per-command help with preview. html_viewer.py -- Simple graphical viewer for local HTML and Markdown, with folder browsing. improved-fzfmenu.sh -- Launch fzf in Alacritty with optional piping and preserved stdio install_dependencies.sh -- Bash script to bulk-install essential terminal and desktop utilities. interactive_git_sync.sh -- Interactive script for syncing multiple git repositories with fzf selection. json_to_markdown.py -- Converts a simple JSON file (list of dicts with \"role\" and \"content\") to a styled Markdown file. jupyter_new_notebook.xsh -- Quickly create and open a blank Jupyter notebook in Chromium via dmenu. keyboard-help.sh -- Displays keyboard layout help in a floating terminal with syntax highlighting launch_tmux_with_music_player.sh -- Creates a headless tmux session named \"MUSIC\" and starts the cmus music player within. legacy-sync.repo.sh -- A script to synchronize a Git repository while providing enhanced output formatting. list-openai-models.sh -- Lists and caches available OpenAI API models with creation dates list_process.sh -- Lists all systemd services, showing their statuses sorted by type llama-all-scripts-describer.py -- Automated Github-style markdown documentation for scripts using Llama 3.1 llm-script-describer.py -- Generate per-script docs and README sections via OpenAI m3u_creator.sh -- Quickly generate an m3u playlist file from all files in the current directory mechen_music_transfert.py -- Syncs a subset of unlistened music albums to the MECHEN MP3 player, fitting within a max size. megacmd_launch_tmux.sh -- Launches mega-cmd inside a new detached tmux session. megaignore_editor.sh -- Fuzzy finder interface for searching, editing, and deleting .megaignore files. megasync.sh -- Launches MEGAsync with specific environment variables set for Qtile/Arch environments midi2arch.xsh -- Transform a MIDI controller into a keyboard/script launcher. midi2arch.xsh -- Transform a MIDI controller into a script/keyboard command launcher for Arch midi2cmd.py -- Manage and monitor MIDI controller input and test connections from the terminal minimal-browser.py -- Minimal local HTML viewer using PyQt6/QWebEngine, for local docs or apps minimal_gpt_call.py -- Simple script to interact with OpenAI GPT-4o-mini for CSV sample generation. new_script_creator.sh -- Automates script creation with templating based on file extension new_script_creator.sh -- Quickly create or adapt user scripts with templating and permissions in $SCRIPTS/bin . next_album.xsh -- Skip to the next album in cmus nvim_in_new_terminal.sh -- Open a file in nvim inside a floating Alacritty terminal window nvpn-tui-help.sh -- Interactive terminal UI for navigating nordvpn (or other CLI programs) commands and help. obsidian-vault-selector.sh -- Select and open Obsidian vaults with preview and search obsidian.xsh -- Quickly select and open an Obsidian vault via a fuzzy menu old-ousse -- Generates a collection of custom mlocate databases for various areas of your filesystem ollama-list.sh -- Fetches and caches a formatted list of Ollama models via LLM open_url_in_instance.sh -- Open a URL in an already running qutebrowser session, or start a new one if needed openwebui-launcher.sh -- Bash script to launch Open WebUI and open it in a minimal browser. openwebui_serve.sh -- Launch Open WebUI via uvx with XDG-compliant data directory ousse-locate.sh -- Experimental script for managing and searching local .db databases with preview support. ousse-update.sh -- Custom script to update various mlocate databases with personal folder scopes. pacman-fuzzy-search.sh -- Fuzzy search and install Arch Linux packages (repo/AUR) using paru and fzf pdfopener.sh -- Fuzzy-pick a PDF in $HOME and open it with Evince, falling back to xdg-open playlist_player.xsh -- Select and play a saved .m3u playlist in cmus via dmenu playlist_randomizer.xsh -- Pick an m3u playlist, shuffle album order, play via cmus ppm-color-reducer -- Reduce colors in a P6 PPM image to a user-defined palette pyman.sh -- Interactive fuzzy finder for Python topics, keywords, builtins, and installed modules/packages. qtile_dice_group.py -- Instantly switches to the workspace (\"group\") with a number summing to 7 with the current one. qtile_window_to_group_and_switch.py -- Moves the current focused window to the next or previous qtile group and switches focus to that group quick-pass.sh -- Fuzzy-find and copy your pass(1) passwords using fzf with one-click paste/edit support. qutebrowser-modify-source-bookmarks.sh -- Synchronizes qutebrowser bookmarks, quickmarks, and sessions with chezmoi dotfiles. random_album.xsh -- Select 10 random albums from cmus and start playback random_wallpapers.xsh -- Script to set a random wallpaper from the ~/.wallpapers directory. read_the_fucking_manual.sh -- Query and analyze your man / batman usage history for most searched entries. rgfzf.sh -- Search for text using ripgrep + fuzzy finder, preview with bat, open in neovim. sandisk_music_transfert.py -- Transfers music files to a Sandisk media player while managing storage capacity and file formats. sandisk_music_transfert.py -- Transfers unplayed albums from your music library to your Sandisk media player, automatically fitting them to available space. screenshot.sh -- Simple utility for taking fullscreen or user-selected screenshots using grim . script.sh -- Launches fzf in an xterm window and types the selected entry using xdotool . script_launcher.sh -- Fuzzy-find and launch scripts with enhanced previews and editing options script_launcher.sh -- Run scripts with fzf select_script -- Interactively select and execute a script from cached metadata using Rofi send_email.py -- Script to send an email from the command line with argparse and smtplib setting-up-syncs.sh -- Automates MEGA cloud syncs for key folders and differentiates setup by host. shell_history_info.sh -- Analyze and summarize the most frequent lines, words, or characters in your shell command history files. show-all-qutebrowser-scripts.sh -- Display the content of Qutebrowser's bundled scripts using bat for preview show_keyboard_layout.py -- Prints a custom visual keyboard layout to the terminal for reference. snekai.sh -- Utility for launching Jupyter Lab, Jupyter Notebook, or IPython from a dedicated Python virtual environment songlauncher.sh -- Quickly search and play music files via dmenu and cmus speach-to-text.py -- Python script for recording audio via a selected device and transcribing it to text using OpenAI Whisper. ssh-fzf.sh -- Fuzzy-find and execute ssh commands from pass using fzf . sync-repo-simple.py -- Automates syncing a git repository, handling conflicts, stashing, and summary output. sync-repo-simple.sh -- Automates the process of syncing a local git repository with its remote, including smart error handling and conflict resolution. sync-repo.py -- Python utility for automating git repository synchronization with rich terminal UI, local/remote conflict handling, and progress feedback. sync-repo.sh -- Synchronize a local git repository with its remote, handling stashes, conflicts, and pretty output terminal_with_command.sh -- Opens a floating Alacritty terminal to execute a given command, showing output and staying open. test.sh -- A script to handle input from standard input (stdin) or provide a default message if no input is given. text_spectrogram.py -- Live real-time text-based spectrogram using microphone input and ANSI colors. tmux-help.py -- A script to provide useful assistance and search functionalities for tmux commands and sections. tmux-help.py -- A script providing helpful utilities and search capabilities for tmux commands.* tmux_manager.py -- Python utility to manage named tmux sessions using a YAML configuration file tmux_session.sh -- Minimal script to launch a detached tmux session with a specified window and command toggle_picom.sh -- Simple script to toggle the Picom compositor on and off with notifications. transform_symlink.sh -- Convert symlinks into copies of their targets (both files and directories). try_the_bat_suit.sh -- Fuzzy-finds and previews files with syntax highlighting in terminal using bat and fzf . tui-gpt.py -- Interactive TUI chat application for GPT models themed as \"Mother\" from Aliens. ugc-python.py -- Extracts and lists movie titles from HTML input piped via stdin. update_birthdays.sh -- Extracts and records the creation date (\"birthday\") of all files in your scripts directory using git history. update_env.xsh -- Extracts current environment API keys and writes them to a .env file. utils_update_symlinks.sh -- maintain and update symlinks for $SCRIPTS into ~/.local/bin , logging actions and cleaning obsolete links utopia.sh -- Download selected Utopia Bordeaux film pages to HTML files vimwiki.sh -- Fuzzy search and open Markdown notes in Vim from your notes directory. vox.py -- Command-line utility to list and describe Vox amp modeling options wallpaper.sh -- Randomly select, set, or browse wallpapers using feh and optional GUIs. wrapper.sh -- Wraps execution of any command, logs invocation with timestamp. xephyr.sh -- Launches a nested X session with Xephyr, running a development Qtile instance. you_are_not_documented.sh -- Finds scripts lacking specific inline documentation tags","title":"Home"},{"location":"scripts/albumplayer.xsh/","text":"Cmus Album Picker (dmenu + xonsh) albumplayer.xsh : Pick a cmus album via dmenu, enqueue it plus 10 random albums Dependencies xonsh \u2014 the script is written in Xonsh (Python-powered shell) cmus \u2014 console music player controlled via cmus-remote dmenu \u2014 album selection UI coreutils \u2014 uses cat and echo ~/.config/cmus/lib.pl \u2014 cmus library/playlist file (m3u-like list of tracks) Description This script lets you quickly pick an album from your cmus library via dmenu, then constructs a temporary M3U playlist containing: - All tracks from the selected album - All tracks from 10 additional random albums It reads track paths from ~/.config/cmus/lib.pl , derives album identifiers from directory structure, presents a nicely formatted album list in dmenu, writes the resulting playlist to /tmp/temp.m3u , and then drives cmus to clear and load the new queue. Key flow: 1. Parse the library file into per-album groups. 2. Show a right-aligned, truncated album list in dmenu. 3. Build /tmp/temp.m3u with the chosen album first, followed by 10 shuffled albums. 4. Use cmus-remote to clear the queue and play. Usage Install deps on Arch: sudo pacman -S xonsh cmus dmenu Ensure you have a library file (from cmus): cmus-remote -C 'save -l ~/.config/cmus/lib.pl' Run from a terminal (starting in $HOME, see notes below): ~/.scripts/bin/albumplayer.xsh Qtile keybinding example: Key([mod], \"a\", lazy.spawn(\"~/.scripts/bin/albumplayer.xsh\")) Customize: - Number of random albums: change for a in albums[:10]: to your desired count. - Temp file location: edit temp_path = os.path.expanduser('/tmp/temp.m3u') . [!TIP] - The script uses a relative path .config/cmus/lib.pl ; if your CWD isn\u2019t $HOME , it will fail. Use os.path.expanduser('~/.config/cmus/lib.pl') instead. - Cancelling dmenu or no match triggers IndexError at res_[0] ; add a guard for empty selection. - Album matching uses substring checks and set-based albums; duplicate album names across artists may collide. Consider tuples (artist, album) or full absolute paths for keys. - Writing to /tmp/temp.m3u can race if launched twice; generate a unique tempfile. - cmus-remote -p then -n may not reliably start playback; prefer cmus-remote -C 'player-play' .","title":"Cmus Album Picker (dmenu + xonsh)"},{"location":"scripts/albumplayer.xsh/#cmus-album-picker-dmenu-xonsh","text":"albumplayer.xsh : Pick a cmus album via dmenu, enqueue it plus 10 random albums","title":"Cmus Album Picker (dmenu + xonsh)"},{"location":"scripts/albumplayer.xsh/#dependencies","text":"xonsh \u2014 the script is written in Xonsh (Python-powered shell) cmus \u2014 console music player controlled via cmus-remote dmenu \u2014 album selection UI coreutils \u2014 uses cat and echo ~/.config/cmus/lib.pl \u2014 cmus library/playlist file (m3u-like list of tracks)","title":"Dependencies"},{"location":"scripts/albumplayer.xsh/#description","text":"This script lets you quickly pick an album from your cmus library via dmenu, then constructs a temporary M3U playlist containing: - All tracks from the selected album - All tracks from 10 additional random albums It reads track paths from ~/.config/cmus/lib.pl , derives album identifiers from directory structure, presents a nicely formatted album list in dmenu, writes the resulting playlist to /tmp/temp.m3u , and then drives cmus to clear and load the new queue. Key flow: 1. Parse the library file into per-album groups. 2. Show a right-aligned, truncated album list in dmenu. 3. Build /tmp/temp.m3u with the chosen album first, followed by 10 shuffled albums. 4. Use cmus-remote to clear the queue and play.","title":"Description"},{"location":"scripts/albumplayer.xsh/#usage","text":"Install deps on Arch: sudo pacman -S xonsh cmus dmenu Ensure you have a library file (from cmus): cmus-remote -C 'save -l ~/.config/cmus/lib.pl' Run from a terminal (starting in $HOME, see notes below): ~/.scripts/bin/albumplayer.xsh Qtile keybinding example: Key([mod], \"a\", lazy.spawn(\"~/.scripts/bin/albumplayer.xsh\")) Customize: - Number of random albums: change for a in albums[:10]: to your desired count. - Temp file location: edit temp_path = os.path.expanduser('/tmp/temp.m3u') . [!TIP] - The script uses a relative path .config/cmus/lib.pl ; if your CWD isn\u2019t $HOME , it will fail. Use os.path.expanduser('~/.config/cmus/lib.pl') instead. - Cancelling dmenu or no match triggers IndexError at res_[0] ; add a guard for empty selection. - Album matching uses substring checks and set-based albums; duplicate album names across artists may collide. Consider tuples (artist, album) or full absolute paths for keys. - Writing to /tmp/temp.m3u can race if launched twice; generate a unique tempfile. - cmus-remote -p then -n may not reliably start playback; prefer cmus-remote -C 'player-play' .","title":"Usage"},{"location":"scripts/ansi-cheatsheet.sh/","text":"ANSI Escape Code Cheatsheet Viewer ansi-cheatsheet.sh : Quickly displays a cheatsheet of ANSI escape codes in a syntax-highlighted view Dependencies bat : A (cat-compatible) syntax highlighting viewer for the terminal. Needed to render the cheatsheet in a more readable and visually appealing format. Shell: Assumes /usr/bin/bash as the shell interpreter. Description This script provides a concise, formatted reference to common ANSI escape codes for text formatting, coloring, and cursor control in terminal environments. It leverages bat with the options -p (plain output), -l md (language: markdown), and displays a hardcoded markdown cheatsheet covering: Text formatting (reset, bold, underline, etc.) Foreground and background colors (standard and \"bright\" variants) Cursor movements (positioning, clearing, saving/restoring) Miscellaneous codes (cursor visibility, screen clearing) The use of a markdown-formatted here-document ( << EOF ... EOF ) ensures the cheatsheet is always up to date with no external file dependencies. Usage This script is intended to be run in any terminal: ansi-cheatsheet.sh No arguments are required (or processed). You can bind it to a key in your qtile configuration for quick access, e.g., to open a new terminal with the cheatsheet. Example: Running as a command ~/.scripts/bin/ansi-cheatsheet.sh Example: Qtile keybinding (assuming xterm ) Key([], \"F12\", lazy.spawn(\"xterm -e ~/.scripts/bin/ansi-cheatsheet.sh\")), [!TIP] The script is simple and effective, but there are a few things to consider: - The script will fail with a confusing message if bat is not installed. You could add a simple check: bash command -v bat >/dev/null 2>&1 || { echo \"bat is required but not installed. Aborting.\"; exit 1; } - Consider making the markdown cheatsheet an external file for easier updates if the content grows. - Add command-line options for output format (plain, markdown, etc.), or a --help flag to improve usability. - Some escape code examples ( \\x1b[31mBlack\\x1b[0m ) are not actually rendered (the color is lost when using bat for markdown), so you may want to clarify which are literal versus rendered.","title":"ANSI Escape Code Cheatsheet Viewer"},{"location":"scripts/ansi-cheatsheet.sh/#ansi-escape-code-cheatsheet-viewer","text":"ansi-cheatsheet.sh : Quickly displays a cheatsheet of ANSI escape codes in a syntax-highlighted view","title":"ANSI Escape Code Cheatsheet Viewer"},{"location":"scripts/ansi-cheatsheet.sh/#dependencies","text":"bat : A (cat-compatible) syntax highlighting viewer for the terminal. Needed to render the cheatsheet in a more readable and visually appealing format. Shell: Assumes /usr/bin/bash as the shell interpreter.","title":"Dependencies"},{"location":"scripts/ansi-cheatsheet.sh/#description","text":"This script provides a concise, formatted reference to common ANSI escape codes for text formatting, coloring, and cursor control in terminal environments. It leverages bat with the options -p (plain output), -l md (language: markdown), and displays a hardcoded markdown cheatsheet covering: Text formatting (reset, bold, underline, etc.) Foreground and background colors (standard and \"bright\" variants) Cursor movements (positioning, clearing, saving/restoring) Miscellaneous codes (cursor visibility, screen clearing) The use of a markdown-formatted here-document ( << EOF ... EOF ) ensures the cheatsheet is always up to date with no external file dependencies.","title":"Description"},{"location":"scripts/ansi-cheatsheet.sh/#usage","text":"This script is intended to be run in any terminal: ansi-cheatsheet.sh No arguments are required (or processed). You can bind it to a key in your qtile configuration for quick access, e.g., to open a new terminal with the cheatsheet.","title":"Usage"},{"location":"scripts/ansi-cheatsheet.sh/#example-running-as-a-command","text":"~/.scripts/bin/ansi-cheatsheet.sh","title":"Example: Running as a command"},{"location":"scripts/ansi-cheatsheet.sh/#example-qtile-keybinding-assuming-xterm","text":"Key([], \"F12\", lazy.spawn(\"xterm -e ~/.scripts/bin/ansi-cheatsheet.sh\")), [!TIP] The script is simple and effective, but there are a few things to consider: - The script will fail with a confusing message if bat is not installed. You could add a simple check: bash command -v bat >/dev/null 2>&1 || { echo \"bat is required but not installed. Aborting.\"; exit 1; } - Consider making the markdown cheatsheet an external file for easier updates if the content grows. - Add command-line options for output format (plain, markdown, etc.), or a --help flag to improve usability. - Some escape code examples ( \\x1b[31mBlack\\x1b[0m ) are not actually rendered (the color is lost when using bat for markdown), so you may want to clarify which are literal versus rendered.","title":"Example: Qtile keybinding (assuming xterm)"},{"location":"scripts/ansi8bit2rgb_hex.py/","text":"ansi8bit2rgb_hex.py ansi8bit2rgb_hex.py : Converts 8-bit ANSI color codes to RGB or HEX representations with optional colorized output and names Dependencies python (standard library only) Uses: os , sys No third-party libraries required Description This script provides a flexible utility for converting 8-bit ANSI color codes (0\u2013255) into RGB or hexadecimal (HEX) color representations. It can handle: - Single color codes (e.g., 42) - Comma-separated lists (e.g., 42,100,255) - Ranges (e.g., 50-99) - The full palette (default if no color specified) Internally, the conversion logic is based on the standard xterm 256-color palette: - 0\u201315: System/standard colors - 16\u2013231: 6\u00d76\u00d76 color cube (calculates R, G, B steps) - 232\u2013255: Greyscale ramp Key features: - Output format: Choose between rgb(R,G,B) or HEX ( #rrggbb ) - Optional coloring: Visually show the color in the terminal (assuming terminal ANSI support) - Optional labeling: Prepend each output with its ANSI color name (e.g., color242 ) - Batch output: Support for ranges/lists and displaying all 256 colors The script also provides clear usage instructions, in-terminal help, and error handling for out-of-range/invalid arguments. Usage You can execute this script directly from the terminal, assign it to a keybinding in Qtile, or invoke it from other scripts. Here are some usage examples: # Show single color in RGB ansi8bit2rgb_hex.py rgb 242 # Output: rgb(108,108,108) # Show single color in HEX ansi8bit2rgb_hex.py hex 242 # Output: #6c6c6c # Show with name and as color block ansi8bit2rgb_hex.py rgb -n -c 196 # Show a range of colors, colored and with their names ansi8bit2rgb_hex.py hex --colorize --name 20-25 # Show all ANSI 8-bit colors in HEX ansi8bit2rgb_hex.py hex # Show help/usage ansi8bit2rgb_hex.py help Tip: You can assign this script as a rofi runner, a custom dmenu, or a Qtile keybinding for fast lookups. [!TIP] - The argument parsing is functional, but could be made clearer (as currently, any extra argument is treated as a color selector; could lead to confusion if options are placed after the number). - The script doesn't currently validate for argument order/uniqueness or mutually exclusive options; e.g., you can pass both -n multiple times with no effect. - Adding support for piping from stdin (for bulk operations), a more idiomatic argparse usage, or JSON output for scripting would increase versatility. - The colorized output can be difficult to read with some terminals if contrasting foreground text is not used. Consider implementing the brightness-based contrasting text color technique outlined in your commented example code at the bottom of the script. - Minor typo: oolorize should be colorize in the usage section. - Overall, the script is robust for everyday use in a color theming/workflow context for Qtile/Arch.","title":"ansi8bit2rgb_hex.py"},{"location":"scripts/ansi8bit2rgb_hex.py/#ansi8bit2rgb_hexpy","text":"ansi8bit2rgb_hex.py : Converts 8-bit ANSI color codes to RGB or HEX representations with optional colorized output and names","title":"ansi8bit2rgb_hex.py"},{"location":"scripts/ansi8bit2rgb_hex.py/#dependencies","text":"python (standard library only) Uses: os , sys No third-party libraries required","title":"Dependencies"},{"location":"scripts/ansi8bit2rgb_hex.py/#description","text":"This script provides a flexible utility for converting 8-bit ANSI color codes (0\u2013255) into RGB or hexadecimal (HEX) color representations. It can handle: - Single color codes (e.g., 42) - Comma-separated lists (e.g., 42,100,255) - Ranges (e.g., 50-99) - The full palette (default if no color specified) Internally, the conversion logic is based on the standard xterm 256-color palette: - 0\u201315: System/standard colors - 16\u2013231: 6\u00d76\u00d76 color cube (calculates R, G, B steps) - 232\u2013255: Greyscale ramp Key features: - Output format: Choose between rgb(R,G,B) or HEX ( #rrggbb ) - Optional coloring: Visually show the color in the terminal (assuming terminal ANSI support) - Optional labeling: Prepend each output with its ANSI color name (e.g., color242 ) - Batch output: Support for ranges/lists and displaying all 256 colors The script also provides clear usage instructions, in-terminal help, and error handling for out-of-range/invalid arguments.","title":"Description"},{"location":"scripts/ansi8bit2rgb_hex.py/#usage","text":"You can execute this script directly from the terminal, assign it to a keybinding in Qtile, or invoke it from other scripts. Here are some usage examples: # Show single color in RGB ansi8bit2rgb_hex.py rgb 242 # Output: rgb(108,108,108) # Show single color in HEX ansi8bit2rgb_hex.py hex 242 # Output: #6c6c6c # Show with name and as color block ansi8bit2rgb_hex.py rgb -n -c 196 # Show a range of colors, colored and with their names ansi8bit2rgb_hex.py hex --colorize --name 20-25 # Show all ANSI 8-bit colors in HEX ansi8bit2rgb_hex.py hex # Show help/usage ansi8bit2rgb_hex.py help Tip: You can assign this script as a rofi runner, a custom dmenu, or a Qtile keybinding for fast lookups. [!TIP] - The argument parsing is functional, but could be made clearer (as currently, any extra argument is treated as a color selector; could lead to confusion if options are placed after the number). - The script doesn't currently validate for argument order/uniqueness or mutually exclusive options; e.g., you can pass both -n multiple times with no effect. - Adding support for piping from stdin (for bulk operations), a more idiomatic argparse usage, or JSON output for scripting would increase versatility. - The colorized output can be difficult to read with some terminals if contrasting foreground text is not used. Consider implementing the brightness-based contrasting text color technique outlined in your commented example code at the bottom of the script. - Minor typo: oolorize should be colorize in the usage section. - Overall, the script is robust for everyday use in a color theming/workflow context for Qtile/Arch.","title":"Usage"},{"location":"scripts/ardour-open.sh/","text":"Ardour Session Opener (fzf + bat) ardour-open.sh : Fuzzy-pick and open Ardour sessions with colored list and bat preview Dependencies bash \u2014 interpreter fd \u2014 fast file search for .ardour files xargs , stat , sort , sed , echo \u2014 GNU coreutils/textutils bat \u2014 syntax-highlighted preview (XML for .ardour) fzf \u2014 fuzzy finder (used via wrapper) improved-fzfmenu.sh \u2014 your wrapper around fzf with preview support ardour \u2014 DAW to open the selected session Optional: qtile \u2014 to bind to a key for quick access Description This script scans your Ardour project directory for session files (*.ardour), sorts them by most recently modified, and presents a colorized list in an fzf-powered menu. While navigating, a live preview of the selected .ardour (XML) file is shown using bat, sized to the preview pane. Key pieces: - AUDIO_PROJECTS defaults to $HOME/audio/PROJECTS and controls the search root. - search_cmd builds the session list with colorized path segments and sorts by mtime via stat -c %Y . - preview_cmd calls bat -l xml with --terminal-width=$FZF_PREVIEW_COLUMNS for readable previews. - get_path sanitizes the selected colored entry (ANSI stripped) and reconstructs the absolute path. - Selection is performed through improved-fzfmenu.sh with --ansi and a 60% preview pane. The chosen session is opened with ardour . Usage Run interactively: ~/.scripts/bin/ardour-open.sh Override the projects directory (one-off): AUDIO_PROJECTS=\"$HOME/audio/ARCHIVE\" ~/.scripts/bin/ardour-open.sh Qtile keybinding (e.g. in config.py): Key([mod], \"a\", lazy.spawn(\"~/.scripts/bin/ardour-open.sh\")) Tip: If you cancel the menu, Ardour may be spawned with an empty path. Consider adding a guard (see Critique). [!TIP] - Paths with spaces/newlines may break the xargs pipeline. Prefer fd -0 \u2026 | xargs -0 \u2026 to be robust. - The colorization sed rules hard-code /home/matias/audio/PROJECTS . Replace with $AUDIO_PROJECTS to avoid drift. - Check for cancellation before launching: if \"$selected\" is empty, exit without calling ardour . - Use printf instead of echo -e for safer escape handling. - Consider quoting $FZF_PREVIEW_COLUMNS and providing a default when unset. - Add dependency checks and helpful messages if fd , bat , or improved-fzfmenu.sh are missing.","title":"Ardour Session Opener (fzf + bat)"},{"location":"scripts/ardour-open.sh/#ardour-session-opener-fzf-bat","text":"ardour-open.sh : Fuzzy-pick and open Ardour sessions with colored list and bat preview","title":"Ardour Session Opener (fzf + bat)"},{"location":"scripts/ardour-open.sh/#dependencies","text":"bash \u2014 interpreter fd \u2014 fast file search for .ardour files xargs , stat , sort , sed , echo \u2014 GNU coreutils/textutils bat \u2014 syntax-highlighted preview (XML for .ardour) fzf \u2014 fuzzy finder (used via wrapper) improved-fzfmenu.sh \u2014 your wrapper around fzf with preview support ardour \u2014 DAW to open the selected session Optional: qtile \u2014 to bind to a key for quick access","title":"Dependencies"},{"location":"scripts/ardour-open.sh/#description","text":"This script scans your Ardour project directory for session files (*.ardour), sorts them by most recently modified, and presents a colorized list in an fzf-powered menu. While navigating, a live preview of the selected .ardour (XML) file is shown using bat, sized to the preview pane. Key pieces: - AUDIO_PROJECTS defaults to $HOME/audio/PROJECTS and controls the search root. - search_cmd builds the session list with colorized path segments and sorts by mtime via stat -c %Y . - preview_cmd calls bat -l xml with --terminal-width=$FZF_PREVIEW_COLUMNS for readable previews. - get_path sanitizes the selected colored entry (ANSI stripped) and reconstructs the absolute path. - Selection is performed through improved-fzfmenu.sh with --ansi and a 60% preview pane. The chosen session is opened with ardour .","title":"Description"},{"location":"scripts/ardour-open.sh/#usage","text":"Run interactively: ~/.scripts/bin/ardour-open.sh Override the projects directory (one-off): AUDIO_PROJECTS=\"$HOME/audio/ARCHIVE\" ~/.scripts/bin/ardour-open.sh Qtile keybinding (e.g. in config.py): Key([mod], \"a\", lazy.spawn(\"~/.scripts/bin/ardour-open.sh\")) Tip: If you cancel the menu, Ardour may be spawned with an empty path. Consider adding a guard (see Critique). [!TIP] - Paths with spaces/newlines may break the xargs pipeline. Prefer fd -0 \u2026 | xargs -0 \u2026 to be robust. - The colorization sed rules hard-code /home/matias/audio/PROJECTS . Replace with $AUDIO_PROJECTS to avoid drift. - Check for cancellation before launching: if \"$selected\" is empty, exit without calling ardour . - Use printf instead of echo -e for safer escape handling. - Consider quoting $FZF_PREVIEW_COLUMNS and providing a default when unset. - Add dependency checks and helpful messages if fd , bat , or improved-fzfmenu.sh are missing.","title":"Usage"},{"location":"scripts/build_and_link.sh/","text":"Build and symlink helper for $SCRIPTS/bin build_and_link.sh : Compile C/C++ or install Python app into $SCRIPTS/bin and symlink into repo root Dependencies bash \u2014 shell interpreter coreutils \u2014 for ln , mkdir , etc. gcc \u2014 build C sources g++ \u2014 build C++ sources uv \u2014 Python packaging/installer (Arch: pacman -S uv) pyproject.toml \u2014 required when installing a Python project SCRIPTS \u2014 environment variable pointing at your scripts root (e.g. $HOME/.scripts) Description This meta-builder compiles a single C/C++ source file or installs a Python project into $SCRIPTS/bin, then creates a symlink back into the current repository directory. It is designed for a simple, local workflow on Arch Linux, and pairs well with qtile keybindings or shell aliases. Flow: - Verifies SCRIPTS is set, creates $SCRIPTS/bin if needed. - Deduces the base name from the provided source path. - For .c/.cpp: builds to $SCRIPTS/bin/ via gcc/g++. - For .py: if the current working directory contains pyproject.toml, installs the app using uv into $SCRIPTS/bin/ . - Finally, symlinks $SCRIPTS/bin/ to ./ in your current repo. Note: The \u201crepo_dir\u201d is the current working directory; run the script from the repository where you want the symlink to appear. Usage Set up once in your shell profile: export SCRIPTS=\"$HOME/.scripts\" C example: cd ~/code/my-c-tool \"$SCRIPTS/meta/build_and_link.sh\" \"$SCRIPTS/src/hello.c\" # Produces $SCRIPTS/bin/hello and symlink ./hello C++ example: cd ~/code/my-cpp-tool \"$SCRIPTS/meta/build_and_link.sh\" \"$SCRIPTS/src/greeter.cpp\" # Produces $SCRIPTS/bin/greeter and symlink ./greeter Python (uv, from a project with pyproject.toml): cd ~/code/my-py-app # must contain pyproject.toml \"$SCRIPTS/meta/build_and_link.sh\" \"$SCRIPTS/src/my-py-app.py\" # Installs app into $SCRIPTS/bin/my-py-app and symlinks ./my-py-app qtile binding idea (spawn a rebuild for a known file): Key([mod], \"b\", lazy.spawn(\"$HOME/.scripts/meta/build_and_link.sh $HOME/.scripts/src/hello.c\")) [!WARNING] - Python path is only used for extension detection; the actual install targets the current directory\u2019s pyproject. Consider taking the project dir as the argument for Python. - uv --app --target writes an app layout (often a directory with bin/). Symlinking $BIN/ may point to a directory, not an executable. You may want to link $BIN/ /bin/ instead. - No compiler flags are set. Add CFLAGS/CXXFLAGS/LDFLAGS (e.g., -O2 -Wall -Wextra) or accept extra args. - $SRC is defined but unused. - Consider set -euo pipefail, using realpath, and better error messages.","title":"Build and symlink helper for $SCRIPTS/bin"},{"location":"scripts/build_and_link.sh/#build-and-symlink-helper-for-scriptsbin","text":"build_and_link.sh : Compile C/C++ or install Python app into $SCRIPTS/bin and symlink into repo root","title":"Build and symlink helper for $SCRIPTS/bin"},{"location":"scripts/build_and_link.sh/#dependencies","text":"bash \u2014 shell interpreter coreutils \u2014 for ln , mkdir , etc. gcc \u2014 build C sources g++ \u2014 build C++ sources uv \u2014 Python packaging/installer (Arch: pacman -S uv) pyproject.toml \u2014 required when installing a Python project SCRIPTS \u2014 environment variable pointing at your scripts root (e.g. $HOME/.scripts)","title":"Dependencies"},{"location":"scripts/build_and_link.sh/#description","text":"This meta-builder compiles a single C/C++ source file or installs a Python project into $SCRIPTS/bin, then creates a symlink back into the current repository directory. It is designed for a simple, local workflow on Arch Linux, and pairs well with qtile keybindings or shell aliases. Flow: - Verifies SCRIPTS is set, creates $SCRIPTS/bin if needed. - Deduces the base name from the provided source path. - For .c/.cpp: builds to $SCRIPTS/bin/ via gcc/g++. - For .py: if the current working directory contains pyproject.toml, installs the app using uv into $SCRIPTS/bin/ . - Finally, symlinks $SCRIPTS/bin/ to ./ in your current repo. Note: The \u201crepo_dir\u201d is the current working directory; run the script from the repository where you want the symlink to appear.","title":"Description"},{"location":"scripts/build_and_link.sh/#usage","text":"Set up once in your shell profile: export SCRIPTS=\"$HOME/.scripts\" C example: cd ~/code/my-c-tool \"$SCRIPTS/meta/build_and_link.sh\" \"$SCRIPTS/src/hello.c\" # Produces $SCRIPTS/bin/hello and symlink ./hello C++ example: cd ~/code/my-cpp-tool \"$SCRIPTS/meta/build_and_link.sh\" \"$SCRIPTS/src/greeter.cpp\" # Produces $SCRIPTS/bin/greeter and symlink ./greeter Python (uv, from a project with pyproject.toml): cd ~/code/my-py-app # must contain pyproject.toml \"$SCRIPTS/meta/build_and_link.sh\" \"$SCRIPTS/src/my-py-app.py\" # Installs app into $SCRIPTS/bin/my-py-app and symlinks ./my-py-app qtile binding idea (spawn a rebuild for a known file): Key([mod], \"b\", lazy.spawn(\"$HOME/.scripts/meta/build_and_link.sh $HOME/.scripts/src/hello.c\")) [!WARNING] - Python path is only used for extension detection; the actual install targets the current directory\u2019s pyproject. Consider taking the project dir as the argument for Python. - uv --app --target writes an app layout (often a directory with bin/). Symlinking $BIN/ may point to a directory, not an executable. You may want to link $BIN/ /bin/ instead. - No compiler flags are set. Add CFLAGS/CXXFLAGS/LDFLAGS (e.g., -O2 -Wall -Wextra) or accept extra args. - $SRC is defined but unused. - Consider set -euo pipefail, using realpath, and better error messages.","title":"Usage"},{"location":"scripts/chezmoi_on_a_new_system.sh/","text":"Initialize Chezmoi on a New System chezmoi_on_a_new_system.sh : Script to initialize and apply Chezmoi configuration for user 'matias-ceau'. Dependencies bash : The GNU Bourne Again SHell, a command processor that typically runs in a text window. curl : Command-line tool for transferring data with URL syntax. chezmoi : A command-line tool to manage your dotfiles across multiple machines. Description This script automates the process of initializing and applying dotfiles using Chezmoi on a new system. Chezmoi is a powerful tool for managing personal configuration files (dotfiles) across multiple machines. The script fetches the Chezmoi installation script via curl and immediately executes it with options to initialize and apply the configurations specified by the GitHub user 'matias-ceau'. The command is structured as follows: - curl -fsLS get.chezmoi.io : This command fetches the installation script for Chezmoi. The options -fsLS are used to enhance the command's reliability by controlling its behavior: - -f : Fail silently on server errors. - -s : Silent mode to reduce output. - -L : Follow redirects, if any. - -S : Show error if it fails. - -- init --apply matias-ceau : Tells Chezmoi to initialize and apply the dotfiles for the user matias-ceau . Usage To execute this script, simply run it from the terminal. It can be included as part of a system initialization process, executed automatically, or bound to a key combination in your qtile configuration. bash /home/matias/.scripts/meta/run_once/chezmoi_on_a_new_system.sh Example Usage: Run it directly in the terminal: ./chezmoi_on_a_new_system.sh Assign to a keybinding in qtile: Key([mod, \"control\"], \"c\", lazy.spawn(\"/home/matias/.scripts/meta/run_once/chezmoi_on_a_new_system.sh\")) [!TIP] While this script is concise and performs its function efficiently, consider wrapping the curl command in a conditional statement to handle potential errors during the download or execution of the installation script. Additionally, logging success or failure can aid in troubleshooting any setup issues.","title":"Initialize Chezmoi on a New System"},{"location":"scripts/chezmoi_on_a_new_system.sh/#initialize-chezmoi-on-a-new-system","text":"chezmoi_on_a_new_system.sh : Script to initialize and apply Chezmoi configuration for user 'matias-ceau'.","title":"Initialize Chezmoi on a New System"},{"location":"scripts/chezmoi_on_a_new_system.sh/#dependencies","text":"bash : The GNU Bourne Again SHell, a command processor that typically runs in a text window. curl : Command-line tool for transferring data with URL syntax. chezmoi : A command-line tool to manage your dotfiles across multiple machines.","title":"Dependencies"},{"location":"scripts/chezmoi_on_a_new_system.sh/#description","text":"This script automates the process of initializing and applying dotfiles using Chezmoi on a new system. Chezmoi is a powerful tool for managing personal configuration files (dotfiles) across multiple machines. The script fetches the Chezmoi installation script via curl and immediately executes it with options to initialize and apply the configurations specified by the GitHub user 'matias-ceau'. The command is structured as follows: - curl -fsLS get.chezmoi.io : This command fetches the installation script for Chezmoi. The options -fsLS are used to enhance the command's reliability by controlling its behavior: - -f : Fail silently on server errors. - -s : Silent mode to reduce output. - -L : Follow redirects, if any. - -S : Show error if it fails. - -- init --apply matias-ceau : Tells Chezmoi to initialize and apply the dotfiles for the user matias-ceau .","title":"Description"},{"location":"scripts/chezmoi_on_a_new_system.sh/#usage","text":"To execute this script, simply run it from the terminal. It can be included as part of a system initialization process, executed automatically, or bound to a key combination in your qtile configuration. bash /home/matias/.scripts/meta/run_once/chezmoi_on_a_new_system.sh Example Usage: Run it directly in the terminal: ./chezmoi_on_a_new_system.sh Assign to a keybinding in qtile: Key([mod, \"control\"], \"c\", lazy.spawn(\"/home/matias/.scripts/meta/run_once/chezmoi_on_a_new_system.sh\")) [!TIP] While this script is concise and performs its function efficiently, consider wrapping the curl command in a conditional statement to handle potential errors during the download or execution of the installation script. Additionally, logging success or failure can aid in troubleshooting any setup issues.","title":"Usage"},{"location":"scripts/citeboard.sh/","text":"Citeboard: Quick Paper Citation and Access citeboard.sh : Find academic references by citation key, copy their identifier, or open associated PDFs. Dependencies findutils Used for file and directory searching (find). xsel For copying citation keys to the X clipboard. dmenu Dynamic menu for rofi-style selection in a graphical environment. evince PDF viewer for opening matched papers. grep , sed Basic text processing utilities (should be pre-installed on Arch). Description This script allows you to quickly search your Zotero BibTeX library for a paper reference, using dmenu to select a citation key. Once a reference is selected, you choose whether to copy its citation key to the clipboard or open its associated PDF document (if available). Reference extraction : It parses all BibTeX files under data/bib/ , extracting citation keys. Interactive menu : Presents a searchable menu of keys with dmenu . Output action : Lets you copy the citation key ( clipboard ) or open the paper's PDF ( open ), using either xsel or evince . Usage Assign to keybindings in Qtile or launch directly from terminal: ~/.scripts/bin/citeboard.sh Selection workflow: 1. A dmenu prompt appears with available citation keys. Type to filter, press Enter to select. 2. A second menu (\"open\" or \"clipboard\") appears . - If you pick clipboard , the citation key is copied ( xsel -b ). - If you pick open , the script looks under data/zotero/storage for files matching the citation key and opens them with evince . Example with dmenu input: Press Super+Shift+C (example Qtile binding) to launch. Type part of a citation key, Enter. Choose open or clipboard . [!TIP] - Relies on directory structure: The script assumes you have a data/bib/ with BibTeX files and a corresponding data/zotero/storage/ with PDFs named after citation keys. If the file naming or structure doesn't match this, \"open\" may silently do nothing. - No input validation: If your BibTeX citation keys contain spaces or unusual characters, extraction with sed might not work reliably. - No error feedback if PDF not found: The script will pass nothing to evince if no match is found, potentially causing confusion. - Minor inefficiency: Always pipes to find and grep even for clipboard-only actions. This could be optimized. - You may want to add notifications (e.g. via notify-send ) to confirm clipboard copies or alert on missing PDFs for improved feedback.","title":"Citeboard: Quick Paper Citation and Access"},{"location":"scripts/citeboard.sh/#citeboard-quick-paper-citation-and-access","text":"citeboard.sh : Find academic references by citation key, copy their identifier, or open associated PDFs.","title":"Citeboard: Quick Paper Citation and Access"},{"location":"scripts/citeboard.sh/#dependencies","text":"findutils Used for file and directory searching (find). xsel For copying citation keys to the X clipboard. dmenu Dynamic menu for rofi-style selection in a graphical environment. evince PDF viewer for opening matched papers. grep , sed Basic text processing utilities (should be pre-installed on Arch).","title":"Dependencies"},{"location":"scripts/citeboard.sh/#description","text":"This script allows you to quickly search your Zotero BibTeX library for a paper reference, using dmenu to select a citation key. Once a reference is selected, you choose whether to copy its citation key to the clipboard or open its associated PDF document (if available). Reference extraction : It parses all BibTeX files under data/bib/ , extracting citation keys. Interactive menu : Presents a searchable menu of keys with dmenu . Output action : Lets you copy the citation key ( clipboard ) or open the paper's PDF ( open ), using either xsel or evince .","title":"Description"},{"location":"scripts/citeboard.sh/#usage","text":"Assign to keybindings in Qtile or launch directly from terminal: ~/.scripts/bin/citeboard.sh Selection workflow: 1. A dmenu prompt appears with available citation keys. Type to filter, press Enter to select. 2. A second menu (\"open\" or \"clipboard\") appears . - If you pick clipboard , the citation key is copied ( xsel -b ). - If you pick open , the script looks under data/zotero/storage for files matching the citation key and opens them with evince .","title":"Usage"},{"location":"scripts/citeboard.sh/#example-with-dmenu-input","text":"Press Super+Shift+C (example Qtile binding) to launch. Type part of a citation key, Enter. Choose open or clipboard . [!TIP] - Relies on directory structure: The script assumes you have a data/bib/ with BibTeX files and a corresponding data/zotero/storage/ with PDFs named after citation keys. If the file naming or structure doesn't match this, \"open\" may silently do nothing. - No input validation: If your BibTeX citation keys contain spaces or unusual characters, extraction with sed might not work reliably. - No error feedback if PDF not found: The script will pass nothing to evince if no match is found, potentially causing confusion. - Minor inefficiency: Always pipes to find and grep even for clipboard-only actions. This could be optimized. - You may want to add notifications (e.g. via notify-send ) to confirm clipboard copies or alert on missing PDFs for improved feedback.","title":"Example with dmenu input:"},{"location":"scripts/closest_colors.py/","text":"Closest Terminal Colors Utility closest_colors.py : Find the closest matching terminal color for a list of color hex codes. Dependencies python (standard library; no external packages required) Description This script is designed to help you match arbitrary hex color codes to their closest equivalent from a palette of terminal colors (by default, the 8-bit ANSI palette). It's particularly useful when customizing color schemes for terminal emulators, status bars (like in qtile), or anywhere color fidelity matters but you are limited to discrete color options. The script operates by: - Accepting an input file ( file1 ) that contains the hex codes of colors you care about (one per line). - Optionally accepting a second file ( file2 ) which defines the color palette to compare against, in name HEX format separated by whitespace (default: the internal 256-color ANSI palette). - Calculating the Euclidean distance between each requested color and all palette entries to find the closest match. - Printing a visually rich output with: - Original and closest color blocks shown via terminal ANSI escape codes. - Both color hex codes and the palette \"name\" for the closest match. Key Functions: - hex_to_rgb(hex_color) : Converts a #RRGGBB string to an (R, G, B) tuple. - color_distance(c1, c2) : Standard Euclidean distance in 3D RGB space. - find_closest_color(target_color, possible_colors) : Finds the closest palette color (by RGB) to target_color . Usage Run from the terminal: python closest_colors.py <file1> [<file2>] <file1> : Path to a file with your desired hex colors, one per line. Example: #ff8800 #CAFE00 #222233 <file2> (optional): Custom palette file with lines like: cyan #00ffff red #ff0000 green #00ff00 Example: python closest_colors.py ~/mycolors.txt python closest_colors.py ~/mycolors.txt ~/custom_palette.txt This works seamlessly with your qtile/Arch Linux setup. You can also bind this script to a key or call it from other scripts as needed. [!TIP] The script expects the input and palette files to be formatted strictly (one hex code per line in file1 ; <name><tab><hex> or <name> <hex> in file2 ). The internal ANSI palette is embedded as a single (very long) string. Consider externalizing this to a file both for maintainability and performance. The output uses ANSI escape codes, so usage outside a true terminal (e.g., some logging systems or editors) may not display color blocks correctly. Error handling is minimal; malformed lines or missing files will cause uncaught exceptions. Input validation could be improved for robustness. You might want options for different color distance heuristics (perceptual distances, for example).","title":"Closest Terminal Colors Utility"},{"location":"scripts/closest_colors.py/#closest-terminal-colors-utility","text":"closest_colors.py : Find the closest matching terminal color for a list of color hex codes.","title":"Closest Terminal Colors Utility"},{"location":"scripts/closest_colors.py/#dependencies","text":"python (standard library; no external packages required)","title":"Dependencies"},{"location":"scripts/closest_colors.py/#description","text":"This script is designed to help you match arbitrary hex color codes to their closest equivalent from a palette of terminal colors (by default, the 8-bit ANSI palette). It's particularly useful when customizing color schemes for terminal emulators, status bars (like in qtile), or anywhere color fidelity matters but you are limited to discrete color options. The script operates by: - Accepting an input file ( file1 ) that contains the hex codes of colors you care about (one per line). - Optionally accepting a second file ( file2 ) which defines the color palette to compare against, in name HEX format separated by whitespace (default: the internal 256-color ANSI palette). - Calculating the Euclidean distance between each requested color and all palette entries to find the closest match. - Printing a visually rich output with: - Original and closest color blocks shown via terminal ANSI escape codes. - Both color hex codes and the palette \"name\" for the closest match. Key Functions: - hex_to_rgb(hex_color) : Converts a #RRGGBB string to an (R, G, B) tuple. - color_distance(c1, c2) : Standard Euclidean distance in 3D RGB space. - find_closest_color(target_color, possible_colors) : Finds the closest palette color (by RGB) to target_color .","title":"Description"},{"location":"scripts/closest_colors.py/#usage","text":"Run from the terminal: python closest_colors.py <file1> [<file2>] <file1> : Path to a file with your desired hex colors, one per line. Example: #ff8800 #CAFE00 #222233 <file2> (optional): Custom palette file with lines like: cyan #00ffff red #ff0000 green #00ff00 Example: python closest_colors.py ~/mycolors.txt python closest_colors.py ~/mycolors.txt ~/custom_palette.txt This works seamlessly with your qtile/Arch Linux setup. You can also bind this script to a key or call it from other scripts as needed. [!TIP] The script expects the input and palette files to be formatted strictly (one hex code per line in file1 ; <name><tab><hex> or <name> <hex> in file2 ). The internal ANSI palette is embedded as a single (very long) string. Consider externalizing this to a file both for maintainability and performance. The output uses ANSI escape codes, so usage outside a true terminal (e.g., some logging systems or editors) may not display color blocks correctly. Error handling is minimal; malformed lines or missing files will cause uncaught exceptions. Input validation could be improved for robustness. You might want options for different color distance heuristics (perceptual distances, for example).","title":"Usage"},{"location":"scripts/color_restrict.py/","text":"Color Restrict Script color_restrict.py : Restricts image colors to those in a custom palette with optional resizing. Dependencies pillow (PIL): Required for image loading, conversion, and saving. numpy : Used for efficient pixel array manipulation and color matching. Python 3.13+ (uses some modern type annotations and possibly new features) uv (for running with uv run as per shebang, a Python package/dependency runner) Description This script restricts the colors of any given image to a fixed, hardcoded palette. The palette is defined in the PALETTE numpy array and covers a variety of earthy and neutral tones, suitable for stylized effects or palette-limited graphics. Core Workflow: Input: Takes an image file as input. Resize: If the image's largest dimension exceeds 4000px, it is proportionally resized using high-quality Lanczos resampling, helpful for processing very large images without running out of RAM. Palette Reduction: All pixels in the image are mapped to the closest color in the specified palette using efficient numpy broadcasting and vectorized operations (see find_closest_colors function). Output: The resultant image (palette-reduced) is saved to the given output path. Functions: find_closest_colors : Finds, for each pixel, the palette color with the minimum Euclidean distance in RGB space. process_image : Handles image loading, optional resizing, applying the palette conversion, and saving. main : Validates arguments and manages the program flow. Usage You can run this script from the command line or assign it to a Qtile keybinding or launcher. It is not interactive; explicit file paths are required. Example usage: uv run color_restrict.py input_image.jpg output_image.jpg Arguments: - input_image.jpg : Path to source image. - output_image.jpg : Path to save the palette-converted image. You might want to bind this to a key in Qtile or use with a file manager custom action. tldr: color_restrict.py <input> <output> [!NOTE] - The script is performant for reasonably-sized images thanks to vectorized numpy operations, but processing very large images may still require considerable RAM. - The color palette is hardcoded; consider adding a command-line switch to load custom palettes if needed for flexibility. - The maximum image dimension (4000px) is also hardcoded. Making this a user-supplied argument would improve the script's general utility. - The output is always in JPEG or PNG format (determined by extension), but the format is not otherwise checked; you may wish to add error handling to verify format support and output path validity. - The use of Python >=3.13 and the uv runner may limit compatibility on some systems. Ensure uv is installed ( pip install uv ) and available in your $PATH .","title":"Color Restrict Script"},{"location":"scripts/color_restrict.py/#color-restrict-script","text":"color_restrict.py : Restricts image colors to those in a custom palette with optional resizing.","title":"Color Restrict Script"},{"location":"scripts/color_restrict.py/#dependencies","text":"pillow (PIL): Required for image loading, conversion, and saving. numpy : Used for efficient pixel array manipulation and color matching. Python 3.13+ (uses some modern type annotations and possibly new features) uv (for running with uv run as per shebang, a Python package/dependency runner)","title":"Dependencies"},{"location":"scripts/color_restrict.py/#description","text":"This script restricts the colors of any given image to a fixed, hardcoded palette. The palette is defined in the PALETTE numpy array and covers a variety of earthy and neutral tones, suitable for stylized effects or palette-limited graphics.","title":"Description"},{"location":"scripts/color_restrict.py/#core-workflow","text":"Input: Takes an image file as input. Resize: If the image's largest dimension exceeds 4000px, it is proportionally resized using high-quality Lanczos resampling, helpful for processing very large images without running out of RAM. Palette Reduction: All pixels in the image are mapped to the closest color in the specified palette using efficient numpy broadcasting and vectorized operations (see find_closest_colors function). Output: The resultant image (palette-reduced) is saved to the given output path.","title":"Core Workflow:"},{"location":"scripts/color_restrict.py/#functions","text":"find_closest_colors : Finds, for each pixel, the palette color with the minimum Euclidean distance in RGB space. process_image : Handles image loading, optional resizing, applying the palette conversion, and saving. main : Validates arguments and manages the program flow.","title":"Functions:"},{"location":"scripts/color_restrict.py/#usage","text":"You can run this script from the command line or assign it to a Qtile keybinding or launcher. It is not interactive; explicit file paths are required. Example usage: uv run color_restrict.py input_image.jpg output_image.jpg Arguments: - input_image.jpg : Path to source image. - output_image.jpg : Path to save the palette-converted image. You might want to bind this to a key in Qtile or use with a file manager custom action. tldr: color_restrict.py <input> <output> [!NOTE] - The script is performant for reasonably-sized images thanks to vectorized numpy operations, but processing very large images may still require considerable RAM. - The color palette is hardcoded; consider adding a command-line switch to load custom palettes if needed for flexibility. - The maximum image dimension (4000px) is also hardcoded. Making this a user-supplied argument would improve the script's general utility. - The output is always in JPEG or PNG format (determined by extension), but the format is not otherwise checked; you may wish to add error handling to verify format support and output path validity. - The use of Python >=3.13 and the uv runner may limit compatibility on some systems. Ensure uv is installed ( pip install uv ) and available in your $PATH .","title":"Usage"},{"location":"scripts/colormap_from_text.sh/","text":"Colormap Extractor from Text Files colormap_from_text.sh : Extracts and displays unique color codes from text or config files in various formats Dependencies bash \u2014 Shell interpreter for execution. grep \u2014 For extracting hex color codes from text. sort \u2014 For finding unique color codes. bat \u2014 For colored help output; will fail if not installed. cat \u2014 For reading files to stdin. (Optional) qtile \u2014 Not directly required, but can be integrated with keybindings in your setup. Description This script extracts all unique hexadecimal color codes ( #RRGGBB format, case-insensitive) from standard input or one or more text files. It is particularly useful for parsing configuration files to quickly generate palettes (for example, from your qtile, gtk, or neovim configs). Depending on the flag, it outputs the palette as: - Hex codes ( #RRGGBB ) - RGB tuples ( rgb(r, g, b) ) - CSV ( r, g, b ) - Optionally, colors are previewed visually in the terminal with a background swatch. Features: - Reads from stdin (pipe) or file arguments. - Use -x/--hex-code for hex output, -r/--rgb for rgb(r,g,b) output, -c/--color for terminal color preview. - Formats are mutually exclusive for hex and rgb. - Quick visualization of color palettes from any text/config file. Usage From command line with file(s): colormap_from_text.sh -x -c ~/.config/qtile/config.py From a pipeline: cat ~/.config/gtk-3.0/settings.ini | colormap_from_text.sh -r Examples: colormap_from_text.sh -x # (with stdin) Outputs only hex codes colormap_from_text.sh -r # (with stdin) Outputs only `rgb(r, g, b)` colormap_from_text.sh -c # (with stdin) Outputs color blocks and csv values colormap_from_text.sh -x -c my_colors.conf cat myfile | colormap_from_text.sh -r -c Invalid usage (e.g., both -x and -r): Script displays an error and usage message. [!TIP] Critique: - The script assumes all color codes are in #RRGGBB format (no support for shorthand #RGB or alpha channels). - Dependency on bat for help output may cause failure if bat is not installed; suggest a fallback to standard echo/cat if bat is missing. - Only the first six digits after # are parsed, so malformed or extended color codes could sneak in without warning. - The option parsing does not allow you to mix files and stdin conveniently; if both are detected, priority is not clear. - It could be made more robust by accepting multiple files directly with correct POSIX argument handling. - You might consider supporting inline comments (to filter out pseudo-colors), or supporting output in other formats (like JSON for script consumption).","title":"Colormap Extractor from Text Files"},{"location":"scripts/colormap_from_text.sh/#colormap-extractor-from-text-files","text":"colormap_from_text.sh : Extracts and displays unique color codes from text or config files in various formats","title":"Colormap Extractor from Text Files"},{"location":"scripts/colormap_from_text.sh/#dependencies","text":"bash \u2014 Shell interpreter for execution. grep \u2014 For extracting hex color codes from text. sort \u2014 For finding unique color codes. bat \u2014 For colored help output; will fail if not installed. cat \u2014 For reading files to stdin. (Optional) qtile \u2014 Not directly required, but can be integrated with keybindings in your setup.","title":"Dependencies"},{"location":"scripts/colormap_from_text.sh/#description","text":"This script extracts all unique hexadecimal color codes ( #RRGGBB format, case-insensitive) from standard input or one or more text files. It is particularly useful for parsing configuration files to quickly generate palettes (for example, from your qtile, gtk, or neovim configs). Depending on the flag, it outputs the palette as: - Hex codes ( #RRGGBB ) - RGB tuples ( rgb(r, g, b) ) - CSV ( r, g, b ) - Optionally, colors are previewed visually in the terminal with a background swatch. Features: - Reads from stdin (pipe) or file arguments. - Use -x/--hex-code for hex output, -r/--rgb for rgb(r,g,b) output, -c/--color for terminal color preview. - Formats are mutually exclusive for hex and rgb. - Quick visualization of color palettes from any text/config file.","title":"Description"},{"location":"scripts/colormap_from_text.sh/#usage","text":"From command line with file(s): colormap_from_text.sh -x -c ~/.config/qtile/config.py From a pipeline: cat ~/.config/gtk-3.0/settings.ini | colormap_from_text.sh -r Examples: colormap_from_text.sh -x # (with stdin) Outputs only hex codes colormap_from_text.sh -r # (with stdin) Outputs only `rgb(r, g, b)` colormap_from_text.sh -c # (with stdin) Outputs color blocks and csv values colormap_from_text.sh -x -c my_colors.conf cat myfile | colormap_from_text.sh -r -c Invalid usage (e.g., both -x and -r): Script displays an error and usage message. [!TIP] Critique: - The script assumes all color codes are in #RRGGBB format (no support for shorthand #RGB or alpha channels). - Dependency on bat for help output may cause failure if bat is not installed; suggest a fallback to standard echo/cat if bat is missing. - Only the first six digits after # are parsed, so malformed or extended color codes could sneak in without warning. - The option parsing does not allow you to mix files and stdin conveniently; if both are detected, priority is not clear. - It could be made more robust by accepting multiple files directly with correct POSIX argument handling. - You might consider supporting inline comments (to filter out pseudo-colors), or supporting output in other formats (like JSON for script consumption).","title":"Usage"},{"location":"scripts/command_prompt.sh/","text":"Command Prompt: FZF History Launcher command_prompt.sh : Interactive shell history picker via fzf wrapper Dependencies bash \u2014 script interpreter shell_history_info.sh \u2014 user script; outputs history in TSV; -l lists entries improved-fzfmenu.sh \u2014 user script; wrapper around fzf with sane defaults fzf \u2014 interactive fuzzy finder (used by the wrapper) cut \u2014 from coreutils, extracts the command field Description This script provides a minimal, fast command launcher backed by your shell history. It: 1) Calls shell_history_info.sh -l to fetch history in a table-like (TSV) format. 2) Pipes that to cut -f2 to keep only the command text (second column). 3) Sends the list to improved-fzfmenu.sh with: - --terminal-title=cmd_prompt to name the terminal window, - --tac to show most recent commands first, - --ansi to preserve colored entries (if any). The chosen command is printed to stdout. The script itself does not execute the command; this is intentional for safety and flexibility (you decide whether to run, edit, or copy it). Usage TL;DR examples: Pick a command and print it command_prompt.sh Pick and execute (bash login shell). Empty selection does nothing. cmd=\"$(command_prompt.sh)\" && [ -n \"$cmd\" ] && bash -lc \"$cmd\" Pick and copy to clipboard (X11) command_prompt.sh | xclip -selection clipboard Run, then open the selected command in $EDITOR for tweaks cmd=\"$(command_prompt.sh)\" && [ -n \"$cmd\" ] && ${EDITOR:-nvim} -c \"startinsert\" -c \"normal Go$cmd\" Qtile keybinding: pick and execute ``` # in config.py from libqtile.config import Key from libqtile.lazy import lazy keys += [ Key([\"mod4\"], \"p\", lazy.spawn(\"sh -lc 'cmd=\\\"$(command_prompt.sh)\\\"; [ -n \\\"$cmd\\\" ] && bash -lc \\\"$cmd\\\"'\"), desc=\"Run command from history picker\"), ] ``` [!TIP] - The script currently lacks error handling; consider set -euo pipefail and guarding missing dependencies. - It does not execute the selection; optionally add a -x/--exec flag to run automatically. - Assuming tab-delimited input, cut -f2 is fine; if the format changes, make the delimiter explicit. - Consider a preview (e.g., frequency, last run time) via fzf --preview . - Multi-line commands may not be represented well; you could join or preview full entries before selection.","title":"Command Prompt: FZF History Launcher"},{"location":"scripts/command_prompt.sh/#command-prompt-fzf-history-launcher","text":"command_prompt.sh : Interactive shell history picker via fzf wrapper","title":"Command Prompt: FZF History Launcher"},{"location":"scripts/command_prompt.sh/#dependencies","text":"bash \u2014 script interpreter shell_history_info.sh \u2014 user script; outputs history in TSV; -l lists entries improved-fzfmenu.sh \u2014 user script; wrapper around fzf with sane defaults fzf \u2014 interactive fuzzy finder (used by the wrapper) cut \u2014 from coreutils, extracts the command field","title":"Dependencies"},{"location":"scripts/command_prompt.sh/#description","text":"This script provides a minimal, fast command launcher backed by your shell history. It: 1) Calls shell_history_info.sh -l to fetch history in a table-like (TSV) format. 2) Pipes that to cut -f2 to keep only the command text (second column). 3) Sends the list to improved-fzfmenu.sh with: - --terminal-title=cmd_prompt to name the terminal window, - --tac to show most recent commands first, - --ansi to preserve colored entries (if any). The chosen command is printed to stdout. The script itself does not execute the command; this is intentional for safety and flexibility (you decide whether to run, edit, or copy it).","title":"Description"},{"location":"scripts/command_prompt.sh/#usage","text":"TL;DR examples: Pick a command and print it command_prompt.sh Pick and execute (bash login shell). Empty selection does nothing. cmd=\"$(command_prompt.sh)\" && [ -n \"$cmd\" ] && bash -lc \"$cmd\" Pick and copy to clipboard (X11) command_prompt.sh | xclip -selection clipboard Run, then open the selected command in $EDITOR for tweaks cmd=\"$(command_prompt.sh)\" && [ -n \"$cmd\" ] && ${EDITOR:-nvim} -c \"startinsert\" -c \"normal Go$cmd\" Qtile keybinding: pick and execute ``` # in config.py from libqtile.config import Key from libqtile.lazy import lazy keys += [ Key([\"mod4\"], \"p\", lazy.spawn(\"sh -lc 'cmd=\\\"$(command_prompt.sh)\\\"; [ -n \\\"$cmd\\\" ] && bash -lc \\\"$cmd\\\"'\"), desc=\"Run command from history picker\"), ] ``` [!TIP] - The script currently lacks error handling; consider set -euo pipefail and guarding missing dependencies. - It does not execute the selection; optionally add a -x/--exec flag to run automatically. - Assuming tab-delimited input, cut -f2 is fine; if the format changes, make the delimiter explicit. - Consider a preview (e.g., frequency, last run time) via fzf --preview . - Multi-line commands may not be represented well; you could join or preview full entries before selection.","title":"Usage"},{"location":"scripts/count_tokens_with_tiktoken.py/","text":"Count Tokens with tiktoken count_tokens_with_tiktoken.py : Count token usage for a text file or stdin using OpenAI tiktoken . Dependencies tiktoken Python package for OpenAI tokenizer encoding/decoding. Python 3.x (interpreter) Description This script counts the number of tokens (as understood by OpenAI's tokenization schemes) in a given text. It's designed to be used in two ways: Through a command line file argument : supply a file with the -f flag to count tokens in its contents. Via stdin : you can pipe text directly to it for interactive or scripted workflows. The script defaults to the gpt-4o model for tokenization if no model is specified. The model can be changed using the -m flag. It parses arguments manually and gracefully provides usage help. Key Functions: - count_tokens(text, model) : returns token count using the specified model. - get_options(arguments) : CLI argument parser, fetches file contents or reads from stdin, and selects the model. - usage() : prints usage help and exits. Usage Examples for Arch Linux + qtile environment: # Pipe text and count tokens with default model (gpt-4o) echo \"Hello world!\" | ~/.scripts/bin/count_tokens_with_tiktoken.py # Count tokens in a file ~/.scripts/bin/count_tokens_with_tiktoken.py -f ~/long_document.txt # Specify a different OpenAI model (e.g. gpt-3.5-turbo) ~/.scripts/bin/count_tokens_with_tiktoken.py -f ~/text.txt -m gpt-3.5-turbo # Get help ~/.scripts/bin/count_tokens_with_tiktoken.py -h You can assign this script to a keybinding in your qtile config, especially to process clipboard contents or selected files. [!TIP] - The argument parsing is simplistic and may break for input with overlapping or reordered flags, e.g. if -m is used before -f . - The usage string could show the full script name for clarity in help output. - There is no error handling for model names that are not recognized by tiktoken . - Consider using a standard argument parser like argparse or click for more robustness and flexibility. - Reading stdin is blocking; if nothing is piped, the script will wait for user input. An explicit prompt or timeout could improve interactivity.","title":"Count Tokens with tiktoken"},{"location":"scripts/count_tokens_with_tiktoken.py/#count-tokens-with-tiktoken","text":"count_tokens_with_tiktoken.py : Count token usage for a text file or stdin using OpenAI tiktoken .","title":"Count Tokens with tiktoken"},{"location":"scripts/count_tokens_with_tiktoken.py/#dependencies","text":"tiktoken Python package for OpenAI tokenizer encoding/decoding. Python 3.x (interpreter)","title":"Dependencies"},{"location":"scripts/count_tokens_with_tiktoken.py/#description","text":"This script counts the number of tokens (as understood by OpenAI's tokenization schemes) in a given text. It's designed to be used in two ways: Through a command line file argument : supply a file with the -f flag to count tokens in its contents. Via stdin : you can pipe text directly to it for interactive or scripted workflows. The script defaults to the gpt-4o model for tokenization if no model is specified. The model can be changed using the -m flag. It parses arguments manually and gracefully provides usage help. Key Functions: - count_tokens(text, model) : returns token count using the specified model. - get_options(arguments) : CLI argument parser, fetches file contents or reads from stdin, and selects the model. - usage() : prints usage help and exits.","title":"Description"},{"location":"scripts/count_tokens_with_tiktoken.py/#usage","text":"Examples for Arch Linux + qtile environment: # Pipe text and count tokens with default model (gpt-4o) echo \"Hello world!\" | ~/.scripts/bin/count_tokens_with_tiktoken.py # Count tokens in a file ~/.scripts/bin/count_tokens_with_tiktoken.py -f ~/long_document.txt # Specify a different OpenAI model (e.g. gpt-3.5-turbo) ~/.scripts/bin/count_tokens_with_tiktoken.py -f ~/text.txt -m gpt-3.5-turbo # Get help ~/.scripts/bin/count_tokens_with_tiktoken.py -h You can assign this script to a keybinding in your qtile config, especially to process clipboard contents or selected files. [!TIP] - The argument parsing is simplistic and may break for input with overlapping or reordered flags, e.g. if -m is used before -f . - The usage string could show the full script name for clarity in help output. - There is no error handling for model names that are not recognized by tiktoken . - Consider using a standard argument parser like argparse or click for more robustness and flexibility. - Reading stdin is blocking; if nothing is piped, the script will wait for user input. An explicit prompt or timeout could improve interactivity.","title":"Usage"},{"location":"scripts/create_cover_art.sh/","text":"Create Cover Art from Audio Spectrogram create_cover_art.sh : generates a cover image by creating a spectrogram from a selected .wav file. Dependencies sox Audio processing tool; used to generate spectrograms from audio files. dmenu Dynamic menu for X; provides an interactive way to pick a .wav file. imagemagick ( convert ) Suite for image processing; used to resize the generated spectrogram. Description This script is designed to quickly produce a visual cover (art) for an audio file by generating and resizing the spectrogram of a selected .wav file. Intended for workflows where visual art for audio projects is needed, it leverages: sox : to create a high-resolution (1600x900) PNG spectrogram of the .wav source selected by the user. dmenu : to interactively present all .wav files under /home/matias/audio/PROJECTS for easy selection within a X session (works seamlessly under qtile). ImageMagick : to force the spectrogram image into the desired 1600x900 resolution, ensuring uniform cover sizes. Intermediate files are managed efficiently: the original spectrogram is deleted after resizing, keeping only the final _RESIZED.png image. The script maintains a simple pipeline and expects the user to be at least minimally familiar with the terminal and X-based app launching. Usage tldr: /home/matias/.scripts/bin/create_cover_art.sh What happens: A dmenu menu appears listing all .wav files in /home/matias/audio/PROJECTS . You choose one file (via keyboard navigation/typing). The script: Creates a spectrogram image ( file.png ). Resizes it to 1600x900 pixels ( file_RESIZED.png ). Deletes the unresized temporary image. The final result is file_RESIZED.png next to your original .wav file. You can: - Assign the script to a qtile keybinding for even faster access. - Chain it with further artwork automation scripts if desired. [!TIP] - The script has no checking for user cancellation in dmenu (empty selection). - It does not escape spaces or special characters in filenames; files with such names may cause errors. - All operations are done in-place in the same directory as the selected .wav , which could clutter your project folder with image files. - Consider adding error handling and filename quoting (e.g. \"$file\" , \"$name\" ) to improve robustness. - If multiple files with the same base name (but different extensions) exist, overwriting is possible.","title":"Create Cover Art from Audio Spectrogram"},{"location":"scripts/create_cover_art.sh/#create-cover-art-from-audio-spectrogram","text":"create_cover_art.sh : generates a cover image by creating a spectrogram from a selected .wav file.","title":"Create Cover Art from Audio Spectrogram"},{"location":"scripts/create_cover_art.sh/#dependencies","text":"sox Audio processing tool; used to generate spectrograms from audio files. dmenu Dynamic menu for X; provides an interactive way to pick a .wav file. imagemagick ( convert ) Suite for image processing; used to resize the generated spectrogram.","title":"Dependencies"},{"location":"scripts/create_cover_art.sh/#description","text":"This script is designed to quickly produce a visual cover (art) for an audio file by generating and resizing the spectrogram of a selected .wav file. Intended for workflows where visual art for audio projects is needed, it leverages: sox : to create a high-resolution (1600x900) PNG spectrogram of the .wav source selected by the user. dmenu : to interactively present all .wav files under /home/matias/audio/PROJECTS for easy selection within a X session (works seamlessly under qtile). ImageMagick : to force the spectrogram image into the desired 1600x900 resolution, ensuring uniform cover sizes. Intermediate files are managed efficiently: the original spectrogram is deleted after resizing, keeping only the final _RESIZED.png image. The script maintains a simple pipeline and expects the user to be at least minimally familiar with the terminal and X-based app launching.","title":"Description"},{"location":"scripts/create_cover_art.sh/#usage","text":"tldr: /home/matias/.scripts/bin/create_cover_art.sh What happens: A dmenu menu appears listing all .wav files in /home/matias/audio/PROJECTS . You choose one file (via keyboard navigation/typing). The script: Creates a spectrogram image ( file.png ). Resizes it to 1600x900 pixels ( file_RESIZED.png ). Deletes the unresized temporary image. The final result is file_RESIZED.png next to your original .wav file. You can: - Assign the script to a qtile keybinding for even faster access. - Chain it with further artwork automation scripts if desired. [!TIP] - The script has no checking for user cancellation in dmenu (empty selection). - It does not escape spaces or special characters in filenames; files with such names may cause errors. - All operations are done in-place in the same directory as the selected .wav , which could clutter your project folder with image files. - Consider adding error handling and filename quoting (e.g. \"$file\" , \"$name\" ) to improve robustness. - If multiple files with the same base name (but different extensions) exist, overwriting is possible.","title":"Usage"},{"location":"scripts/desk_fzf.sh/","text":"Fuzzy .desktop Launcher desk_fzf.sh : Quickly search and launch .desktop applications using fzf and a cached file listing. Dependencies fd \u2014 For fast file searches ( fd is a fast alternative to find ). fzf \u2014 Terminal fuzzy finder for interactive selection. bat \u2014 Syntax highlighting for file previews in fzf . Bash \u2014 Script is written for bash. XDG compatible environment ( $XDG_CACHE_HOME should be set). .desktop files on your system (standard in most Linux desktop environments). Description This script streamlines application launching by searching for .desktop files system-wide and presenting them via an fzf -powered fuzzy selector. Its core logic is as follows: Caching: .desktop file paths are indexed using fd and stored in a cache file under $XDG_CACHE_HOME/desktop-script.txt , along with a timestamp (UNIX epoch seconds). The cache is refreshed if older than 2 hours (7200 seconds), or by forcibly running with the --update flag. Selection UI: Uses bat to display relative paths to .desktop files with line highlighting, piped into fzf for interactive selection. An fzf preview window (with bat ) displays the full content of each .desktop file. Launching: Parses the selected .desktop file for its Exec= line\u2015the application execution command. Executes this application command using eval . This script suits an Arch Linux user with qtile as WM, providing a minimal and fast alternative application launcher. Usage You can either run from a terminal or bind it to a key in qtile. Basic: ~/.scripts/bin/desk_fzf.sh Force update the cache: ~/.scripts/bin/desk_fzf.sh --update Sample Qtile Keybinding: Add in your config.py : Key([mod], \"d\", lazy.spawn(\"~/.scripts/bin/desk_fzf.sh\")) This binds Mod+d to the launcher. [!TIP] The caching logic is simple and fast, but some improvements are possible: - The script assumes .desktop files are readable and have an Exec line, but ignores entries with Exec= containing desktop environment specific variables or substitution fields (see freedesktop.org spec ). If the Exec command contains % -codes (like %u ), these are not handled and may cause unexpected behavior. - The preview command ( bat --color=always {} ) might fail if bat isn't installed or if the file path includes problematic characters. - No filtering for only user-accessible .desktop files, nor filtering out duplicates or broken symlinks. - Running eval directly can have security implications if untrusted .desktop files exist on your system. - For privacy or performance, you may wish to scope fd to known application directories (like /usr/share/applications and ~/.local/share/applications ) rather than searching from root ( / ). - The script does not parse or respect the TryExec or terminal options within .desktop files. For daily use on a personalized system these may not matter, but keep them in mind if you adapt or share the script.","title":"Fuzzy .desktop Launcher"},{"location":"scripts/desk_fzf.sh/#fuzzy-desktop-launcher","text":"desk_fzf.sh : Quickly search and launch .desktop applications using fzf and a cached file listing.","title":"Fuzzy .desktop Launcher"},{"location":"scripts/desk_fzf.sh/#dependencies","text":"fd \u2014 For fast file searches ( fd is a fast alternative to find ). fzf \u2014 Terminal fuzzy finder for interactive selection. bat \u2014 Syntax highlighting for file previews in fzf . Bash \u2014 Script is written for bash. XDG compatible environment ( $XDG_CACHE_HOME should be set). .desktop files on your system (standard in most Linux desktop environments).","title":"Dependencies"},{"location":"scripts/desk_fzf.sh/#description","text":"This script streamlines application launching by searching for .desktop files system-wide and presenting them via an fzf -powered fuzzy selector. Its core logic is as follows: Caching: .desktop file paths are indexed using fd and stored in a cache file under $XDG_CACHE_HOME/desktop-script.txt , along with a timestamp (UNIX epoch seconds). The cache is refreshed if older than 2 hours (7200 seconds), or by forcibly running with the --update flag. Selection UI: Uses bat to display relative paths to .desktop files with line highlighting, piped into fzf for interactive selection. An fzf preview window (with bat ) displays the full content of each .desktop file. Launching: Parses the selected .desktop file for its Exec= line\u2015the application execution command. Executes this application command using eval . This script suits an Arch Linux user with qtile as WM, providing a minimal and fast alternative application launcher.","title":"Description"},{"location":"scripts/desk_fzf.sh/#usage","text":"You can either run from a terminal or bind it to a key in qtile.","title":"Usage"},{"location":"scripts/desk_fzf.sh/#basic","text":"~/.scripts/bin/desk_fzf.sh","title":"Basic:"},{"location":"scripts/desk_fzf.sh/#force-update-the-cache","text":"~/.scripts/bin/desk_fzf.sh --update","title":"Force update the cache:"},{"location":"scripts/desk_fzf.sh/#sample-qtile-keybinding","text":"Add in your config.py : Key([mod], \"d\", lazy.spawn(\"~/.scripts/bin/desk_fzf.sh\")) This binds Mod+d to the launcher. [!TIP] The caching logic is simple and fast, but some improvements are possible: - The script assumes .desktop files are readable and have an Exec line, but ignores entries with Exec= containing desktop environment specific variables or substitution fields (see freedesktop.org spec ). If the Exec command contains % -codes (like %u ), these are not handled and may cause unexpected behavior. - The preview command ( bat --color=always {} ) might fail if bat isn't installed or if the file path includes problematic characters. - No filtering for only user-accessible .desktop files, nor filtering out duplicates or broken symlinks. - Running eval directly can have security implications if untrusted .desktop files exist on your system. - For privacy or performance, you may wish to scope fd to known application directories (like /usr/share/applications and ~/.local/share/applications ) rather than searching from root ( / ). - The script does not parse or respect the TryExec or terminal options within .desktop files. For daily use on a personalized system these may not matter, but keep them in mind if you adapt or share the script.","title":"Sample Qtile Keybinding:"},{"location":"scripts/display_markdown.py/","text":"Display Markdown Script display_markdown.py : Script to display markdown files in the terminal with styling Dependencies rich : A Python library for rich text and formatting in the terminal. Description This script is designed to display markdown files directly in your terminal with enhanced styling using the rich library. By default, it styles the markdown content with the github-dark theme. The script presents the content inside a styled panel, providing visually appealing rounded borders with a blue border style. The script reads a markdown file specified by the user via command-line argument and optionally takes a second argument for the panel width. If the width is not provided or is not a number, it defaults to an adaptive width. The use of rich 's Markdown and Panel classes enables the script to render complex markdown syntax and present it elegantly, enhancing legibility. Usage To use the script, execute it from a terminal on your Arch Linux environment as follows: python /home/matias/.scripts/dev/display_markdown.py /path/to/markdown.md [panel_width] Replace /path/to/markdown.md with the path to the markdown file you wish to display. Optionally, specify [panel_width] as a numeric value to set the desired width of the styled panel. For example, if you have a markdown file located at /home/matias/docs/example.md , you would run: python /home/matias/.scripts/dev/display_markdown.py /home/matias/docs/example.md 80 This command will render the markdown content inside an 80-character wide panel. [!WARNING] The current implementation of the script contains a logic error in checking the number of arguments. Ensure that the condition if len(sys.argv) != 2: should correctly handle both arguments, especially when counting how many arguments are provided. Additionally, consider implementing error handling for the conversion of panel_width to ensure it gracefully handles invalid inputs. Consider refactoring to allow optional styling themes from the command line for versatility.","title":"Display Markdown Script"},{"location":"scripts/display_markdown.py/#display-markdown-script","text":"display_markdown.py : Script to display markdown files in the terminal with styling","title":"Display Markdown Script"},{"location":"scripts/display_markdown.py/#dependencies","text":"rich : A Python library for rich text and formatting in the terminal.","title":"Dependencies"},{"location":"scripts/display_markdown.py/#description","text":"This script is designed to display markdown files directly in your terminal with enhanced styling using the rich library. By default, it styles the markdown content with the github-dark theme. The script presents the content inside a styled panel, providing visually appealing rounded borders with a blue border style. The script reads a markdown file specified by the user via command-line argument and optionally takes a second argument for the panel width. If the width is not provided or is not a number, it defaults to an adaptive width. The use of rich 's Markdown and Panel classes enables the script to render complex markdown syntax and present it elegantly, enhancing legibility.","title":"Description"},{"location":"scripts/display_markdown.py/#usage","text":"To use the script, execute it from a terminal on your Arch Linux environment as follows: python /home/matias/.scripts/dev/display_markdown.py /path/to/markdown.md [panel_width] Replace /path/to/markdown.md with the path to the markdown file you wish to display. Optionally, specify [panel_width] as a numeric value to set the desired width of the styled panel. For example, if you have a markdown file located at /home/matias/docs/example.md , you would run: python /home/matias/.scripts/dev/display_markdown.py /home/matias/docs/example.md 80 This command will render the markdown content inside an 80-character wide panel. [!WARNING] The current implementation of the script contains a logic error in checking the number of arguments. Ensure that the condition if len(sys.argv) != 2: should correctly handle both arguments, especially when counting how many arguments are provided. Additionally, consider implementing error handling for the conversion of panel_width to ensure it gracefully handles invalid inputs. Consider refactoring to allow optional styling themes from the command line for versatility.","title":"Usage"},{"location":"scripts/dmenu_run_scripts.py/","text":"Dmenu-style Script Launcher (dmenu_run_scripts.py) dmenu_run_scripts.py : Presents a list of runnable scripts via rofi integrated with xonsh for selection and execution. Dependencies xonsh Advanced Python-powered shell; used to gather script metadata via script_identifier.xsh. rofi Window switcher, run dialog & dmenu replacement; acts as the GUI menu for script selection. script_identifier.xsh User script required for fetching the list of manageable scripts. Must be in $PATH or same directory. Python 3 Standard interpreter for running this script. Description This script provides an application-launcher-like interface for running your local scripts. It works by first invoking script_identifier.xsh (presumably an xonsh script that enumerates available executable scripts, formatting and annotating them for display) with specific arguments to produce a list of scripts. The output is piped to rofi in dmenu mode, presenting a searchable and attractive interface, with color markup for statuses and descriptions. Upon selection, it parses the chosen entry to extract the command and directly invokes it using subprocess.run . This enables you to quickly search, select, and execute scripts from a large collection, without touching the terminal. The script assumes the output format of script_identifier.xsh is consistent and suited for markup parsing as implemented. Usage You can run the script either from a terminal or bind it as a hotkey via your qtile configuration (recommended for fast access): TLDR: ~/.scripts/bin/dmenu_run_scripts.py Keybinding Example in Qtile (python): Key([mod], \"r\", lazy.spawn(\"~/.scripts/bin/dmenu_run_scripts.py\")) From Terminal: python ~/.scripts/bin/dmenu_run_scripts.py Select an entry with arrow keys/type-to-search, press Enter \u2014 the corresponding script will be executed. [!TIP] The script assumes the chosen entry can be parsed simply by splitting on > and < and that the executable command is directly extractable in this way. If the output format changes or contains these characters, parsing may break. The script does not handle user cancellation gracefully (e.g., pressing Esc in rofi ), which may cause an IndexError. Consider adding input validation after the split statement. Security consideration: If your script list contains untrusted items, arbitrary code could be invoked. Consider passing absolute paths to rofi and script_identifier.xsh for robustness, and adding logging or error handling for missing dependencies or crashes. You might wish to use os.execvp() to replace the process or run in a new terminal for CLI scripts with output.","title":"Dmenu-style Script Launcher (dmenu_run_scripts.py)"},{"location":"scripts/dmenu_run_scripts.py/#dmenu-style-script-launcher-dmenu_run_scriptspy","text":"dmenu_run_scripts.py : Presents a list of runnable scripts via rofi integrated with xonsh for selection and execution.","title":"Dmenu-style Script Launcher (dmenu_run_scripts.py)"},{"location":"scripts/dmenu_run_scripts.py/#dependencies","text":"xonsh Advanced Python-powered shell; used to gather script metadata via script_identifier.xsh. rofi Window switcher, run dialog & dmenu replacement; acts as the GUI menu for script selection. script_identifier.xsh User script required for fetching the list of manageable scripts. Must be in $PATH or same directory. Python 3 Standard interpreter for running this script.","title":"Dependencies"},{"location":"scripts/dmenu_run_scripts.py/#description","text":"This script provides an application-launcher-like interface for running your local scripts. It works by first invoking script_identifier.xsh (presumably an xonsh script that enumerates available executable scripts, formatting and annotating them for display) with specific arguments to produce a list of scripts. The output is piped to rofi in dmenu mode, presenting a searchable and attractive interface, with color markup for statuses and descriptions. Upon selection, it parses the chosen entry to extract the command and directly invokes it using subprocess.run . This enables you to quickly search, select, and execute scripts from a large collection, without touching the terminal. The script assumes the output format of script_identifier.xsh is consistent and suited for markup parsing as implemented.","title":"Description"},{"location":"scripts/dmenu_run_scripts.py/#usage","text":"You can run the script either from a terminal or bind it as a hotkey via your qtile configuration (recommended for fast access):","title":"Usage"},{"location":"scripts/dmenu_run_scripts.py/#tldr","text":"~/.scripts/bin/dmenu_run_scripts.py","title":"TLDR:"},{"location":"scripts/dmenu_run_scripts.py/#keybinding-example-in-qtile-python","text":"Key([mod], \"r\", lazy.spawn(\"~/.scripts/bin/dmenu_run_scripts.py\"))","title":"Keybinding Example in Qtile (python):"},{"location":"scripts/dmenu_run_scripts.py/#from-terminal","text":"python ~/.scripts/bin/dmenu_run_scripts.py Select an entry with arrow keys/type-to-search, press Enter \u2014 the corresponding script will be executed. [!TIP] The script assumes the chosen entry can be parsed simply by splitting on > and < and that the executable command is directly extractable in this way. If the output format changes or contains these characters, parsing may break. The script does not handle user cancellation gracefully (e.g., pressing Esc in rofi ), which may cause an IndexError. Consider adding input validation after the split statement. Security consideration: If your script list contains untrusted items, arbitrary code could be invoked. Consider passing absolute paths to rofi and script_identifier.xsh for robustness, and adding logging or error handling for missing dependencies or crashes. You might wish to use os.execvp() to replace the process or run in a new terminal for CLI scripts with output.","title":"From Terminal:"},{"location":"scripts/edit_chezmoi_cfg_files.sh/","text":"Edit Chezmoi Config Files edit_chezmoi_cfg_files.sh : Fuzzy-find and edit dotfiles managed by chezmoi, with preview and optional sync/apply. Dependencies chezmoi : Manages personal dotfiles as source-controlled templates. eza : ls replacement for colorful/fancy directory listings. fzf : Command-line fuzzy finder for interactive file selection. bat : cat clone with syntax highlighting and Git integration (for file preview). fd : Simple, fast file finder (used for globbing files in directories). $SCRIPTS/sync-repo.sh : User script to sync repositories. (Script references this for optional syncing.) Optional: nvim (currently commented out), for editing files. Description This script provides an interactive way to browse, preview, and edit dotfiles managed by chezmoi on your Arch Linux system. Leveraging the fuzzy finder fzf , the script initially lists all files managed by chezmoi, allowing quick filtering and selection. Pressing Alt+D toggles to directory mode, allowing navigation into directories managed by chezmoi. Previews are shown for files (with bat ) and folders (with tree view from eza ). Once a file or directory is selected, the script opens it for editing via chezmoi edit . After editing, you are prompted to: Apply the changes with chezmoi apply ( a or Enter) Apply and also sync the repo ( s ) Exit without applying/syncing ( x ) The script is engineered for quick use within a terminal and can be easily bound to a custom keybinding in qtile for even snappier access to your chezmoi workflow. Key implemented functions: - remove_icons : Filters out terminal icons/escape sequences for clean file operations. - preview_command : Generates live previews for files (using bat ) and directories (using eza ). - search_files/search_dirs : Returns lists of managed files/directories for selection/reloading in fzf. Usage Typical workflow ( tldr version): ~/.scripts/bin/edit_chezmoi_cfg_files.sh Within fzf prompt: - Filter to find the file or directory managed by chezmoi you'd like to edit. - Press Alt+D to switch to directory view. - Press Alt+F to switch back to file view. - Press Enter on your selection. After editing: - [a] Apply changes - [s] Apply and sync repo - [x] Exit (no apply) This script is best launched from a terminal or bound to a custom key in your qtile configuration. [!TIP] Critique / Potential Improvements: - Script assumes $SCRIPTS/sync-repo.sh and $CHEZMOI are properly set up in the environment. Consider adding checks and clearer error handling for missing variables or dependencies. - Usage of chezmoi edit $(fd . -tf \"$path\") is a bit ambiguous: if the chosen directory contains many files, you may want to provide more selective logic, otherwise this could open an excessive number of editors or possibly fail. - The script could leverage chezmoi source-path to ensure file paths are correct, especially with unusual chezmoi configuration. - Some code (e.g. nvim integration) is commented out; clarify or remove. - For large chezmoi repos, consider limiting the search scope or preview size for responsiveness. - remove_icons may not be foolproof for all terminal-icon themes; further refinement might be needed for maximum robustness.","title":"Edit Chezmoi Config Files"},{"location":"scripts/edit_chezmoi_cfg_files.sh/#edit-chezmoi-config-files","text":"edit_chezmoi_cfg_files.sh : Fuzzy-find and edit dotfiles managed by chezmoi, with preview and optional sync/apply.","title":"Edit Chezmoi Config Files"},{"location":"scripts/edit_chezmoi_cfg_files.sh/#dependencies","text":"chezmoi : Manages personal dotfiles as source-controlled templates. eza : ls replacement for colorful/fancy directory listings. fzf : Command-line fuzzy finder for interactive file selection. bat : cat clone with syntax highlighting and Git integration (for file preview). fd : Simple, fast file finder (used for globbing files in directories). $SCRIPTS/sync-repo.sh : User script to sync repositories. (Script references this for optional syncing.) Optional: nvim (currently commented out), for editing files.","title":"Dependencies"},{"location":"scripts/edit_chezmoi_cfg_files.sh/#description","text":"This script provides an interactive way to browse, preview, and edit dotfiles managed by chezmoi on your Arch Linux system. Leveraging the fuzzy finder fzf , the script initially lists all files managed by chezmoi, allowing quick filtering and selection. Pressing Alt+D toggles to directory mode, allowing navigation into directories managed by chezmoi. Previews are shown for files (with bat ) and folders (with tree view from eza ). Once a file or directory is selected, the script opens it for editing via chezmoi edit . After editing, you are prompted to: Apply the changes with chezmoi apply ( a or Enter) Apply and also sync the repo ( s ) Exit without applying/syncing ( x ) The script is engineered for quick use within a terminal and can be easily bound to a custom keybinding in qtile for even snappier access to your chezmoi workflow. Key implemented functions: - remove_icons : Filters out terminal icons/escape sequences for clean file operations. - preview_command : Generates live previews for files (using bat ) and directories (using eza ). - search_files/search_dirs : Returns lists of managed files/directories for selection/reloading in fzf.","title":"Description"},{"location":"scripts/edit_chezmoi_cfg_files.sh/#usage","text":"Typical workflow ( tldr version): ~/.scripts/bin/edit_chezmoi_cfg_files.sh Within fzf prompt: - Filter to find the file or directory managed by chezmoi you'd like to edit. - Press Alt+D to switch to directory view. - Press Alt+F to switch back to file view. - Press Enter on your selection. After editing: - [a] Apply changes - [s] Apply and sync repo - [x] Exit (no apply) This script is best launched from a terminal or bound to a custom key in your qtile configuration. [!TIP] Critique / Potential Improvements: - Script assumes $SCRIPTS/sync-repo.sh and $CHEZMOI are properly set up in the environment. Consider adding checks and clearer error handling for missing variables or dependencies. - Usage of chezmoi edit $(fd . -tf \"$path\") is a bit ambiguous: if the chosen directory contains many files, you may want to provide more selective logic, otherwise this could open an excessive number of editors or possibly fail. - The script could leverage chezmoi source-path to ensure file paths are correct, especially with unusual chezmoi configuration. - Some code (e.g. nvim integration) is commented out; clarify or remove. - For large chezmoi repos, consider limiting the search scope or preview size for responsiveness. - remove_icons may not be foolproof for all terminal-icon themes; further refinement might be needed for maximum robustness.","title":"Usage"},{"location":"scripts/editor.sh/","text":"Fast Fuzzy File Editor editor.sh : Quickly edit files using fzf, with smart search modes and exclusions. Dependencies fd : Fast alternative to find, used for file searching (respects exclusions). fzf : Fuzzy finder interface for selecting files interactively. nvim : Neovim editor; edit target file. bat : Syntax-highlighting preview for files in fzf. chezmoi : Accesses unmanaged dotfiles when using config mode. rg : (ripgrep) Used for fast filtering in config mode. sudo : For editing files requiring elevated permissions. Environment variables used: $SCRIPTS , $LOCALDATA Description This script is a highly flexible file opener/editor, integrating the power of fd for fast searching and fzf for intuitive fuzzy selection. It is optimized for your workflow on Arch Linux with qtile , and is designed to help you locate and edit files rapidly across various contexts: scripts, configuration files, the current directory, or any specified location. Modes Default: Searches in your sensible user data, scripts, and home directories, while ignoring system/config paths and common large/irrelevant filetypes. Scripts ( -s ) : Restricts search to your $SCRIPTS directory. Config ( -C ) : Lists unmanaged chezmoi config files only. CWD ( -c ) : Limits search to the current working directory. Sudo ( -S ) : Allows selection from root-owned/system config directories and opens with sudo. Directory ( -d <dir> ) : Searches in any directory you specify. Smart Features Uses bat as an fzf preview window. Excludes a comprehensive set of non-editable and binary file patterns. Custom fzf bindings: <C-H> shows hidden files; <C-S> reverts to non-hidden files. Assignable to keybindings or used interactively. Usage editor.sh [-s|--scripts] [-c|--cwd] [-C|--config] [-d|--dir <dir>] [-S|--sudo] [-h|--help] Examples: editor.sh # Search in user data, scripts, home, etc. editor.sh -s # Only in $SCRIPTS directory editor.sh -c # Only in the current directory editor.sh -d ~/projects/foo # In the given directory editor.sh -S # Enable sudo, search root/system config locations editor.sh -C # Edit chezmoi 'unmanaged' configs editor.sh -h # Show usage Within fzf , use <C-H> to reveal hidden files and <C-S> revert. Can be run interactively, or assigned to a qtile keybinding for fast access. [!TIP] The script is robust and pragmatic, but could be improved: - $SCRIPTS and $LOCALDATA are assumed set; add checks or sensible defaults. - bat and chezmoi are hard-coded; consider gracefully bypassing features if missing. - The exclusion list is impressive but static; consider sourcing from a config, or documenting how to tweak. - The preview for config mode may break if chezmoi or rg is missing. - For non-bash shells or minimalist setups, ensure bashisms and external dependencies are portable for your workflow. - Variable quoting is inconsistent (e.g., [ -z $2 ] should be [ -z \"$2\" ] ).","title":"Fast Fuzzy File Editor"},{"location":"scripts/editor.sh/#fast-fuzzy-file-editor","text":"editor.sh : Quickly edit files using fzf, with smart search modes and exclusions.","title":"Fast Fuzzy File Editor"},{"location":"scripts/editor.sh/#dependencies","text":"fd : Fast alternative to find, used for file searching (respects exclusions). fzf : Fuzzy finder interface for selecting files interactively. nvim : Neovim editor; edit target file. bat : Syntax-highlighting preview for files in fzf. chezmoi : Accesses unmanaged dotfiles when using config mode. rg : (ripgrep) Used for fast filtering in config mode. sudo : For editing files requiring elevated permissions. Environment variables used: $SCRIPTS , $LOCALDATA","title":"Dependencies"},{"location":"scripts/editor.sh/#description","text":"This script is a highly flexible file opener/editor, integrating the power of fd for fast searching and fzf for intuitive fuzzy selection. It is optimized for your workflow on Arch Linux with qtile , and is designed to help you locate and edit files rapidly across various contexts: scripts, configuration files, the current directory, or any specified location.","title":"Description"},{"location":"scripts/editor.sh/#modes","text":"Default: Searches in your sensible user data, scripts, and home directories, while ignoring system/config paths and common large/irrelevant filetypes. Scripts ( -s ) : Restricts search to your $SCRIPTS directory. Config ( -C ) : Lists unmanaged chezmoi config files only. CWD ( -c ) : Limits search to the current working directory. Sudo ( -S ) : Allows selection from root-owned/system config directories and opens with sudo. Directory ( -d <dir> ) : Searches in any directory you specify.","title":"Modes"},{"location":"scripts/editor.sh/#smart-features","text":"Uses bat as an fzf preview window. Excludes a comprehensive set of non-editable and binary file patterns. Custom fzf bindings: <C-H> shows hidden files; <C-S> reverts to non-hidden files. Assignable to keybindings or used interactively.","title":"Smart Features"},{"location":"scripts/editor.sh/#usage","text":"editor.sh [-s|--scripts] [-c|--cwd] [-C|--config] [-d|--dir <dir>] [-S|--sudo] [-h|--help] Examples: editor.sh # Search in user data, scripts, home, etc. editor.sh -s # Only in $SCRIPTS directory editor.sh -c # Only in the current directory editor.sh -d ~/projects/foo # In the given directory editor.sh -S # Enable sudo, search root/system config locations editor.sh -C # Edit chezmoi 'unmanaged' configs editor.sh -h # Show usage Within fzf , use <C-H> to reveal hidden files and <C-S> revert. Can be run interactively, or assigned to a qtile keybinding for fast access. [!TIP] The script is robust and pragmatic, but could be improved: - $SCRIPTS and $LOCALDATA are assumed set; add checks or sensible defaults. - bat and chezmoi are hard-coded; consider gracefully bypassing features if missing. - The exclusion list is impressive but static; consider sourcing from a config, or documenting how to tweak. - The preview for config mode may break if chezmoi or rg is missing. - For non-bash shells or minimalist setups, ensure bashisms and external dependencies are portable for your workflow. - Variable quoting is inconsistent (e.g., [ -z $2 ] should be [ -z \"$2\" ] ).","title":"Usage"},{"location":"scripts/env.sh/","text":"Environment Loader Library (Flexoki/FZF/Paths) env.sh : Modular environment loader for colors, FZF, paths, git and debug Dependencies bash \u2014 required; uses arrays, export -f, and BASH_SOURCE coreutils \u2014 for readlink used to resolve script root fd \u2014 used by FZF_DEFAULT_COMMAND for fast file search bat \u2014 used by FZF_PREVIEW_COMMAND for syntax-highlighted previews fzf \u2014 interactive fuzzy finder, styled via Flexoki palette (optional) Description This library provides a single function, load_env , that sets up a modular environment for your scripts on Arch + qtile. It discovers your scripts root at runtime ( $SCRIPTS ) via readlink -f \"${BASH_SOURCE[0]}\" , populates $PATH with $SCRIPTS/bin and $HOME/.local/bin , and optionally configures: Flexoki color palette (exports named hex colors + semantic aliases) FZF defaults (command, keybindings, preview, and themed colors) Git-related locations ( $GIT_REPOS , $LOCALDATA ) Debug output to stderr It is idempotent: a guard ( $SCRIPTS_ENV_LOADED ) avoids re-initializing core state. Convenience wrappers are exported: load_env_minimal , load_env_colors , load_env_fzf , load_env_full . Usage tldr: # In an interactive shell (bash) source ~/.scripts/lib/env.sh load_env \"core,colors,fzf\" fzf # now uses Flexoki theme and fd+bat preview In another script: #!/usr/bin/env bash source \"$(dirname \"${BASH_SOURCE[0]}\")/../lib/env.sh\" load_env_full # your script... Using helpers: source ~/.scripts/lib/env.sh load_env_fzf # == \"core,colors,fzf\" load_env_minimal # only core paths Qtile integration (autostart or spawned scripts): # ~/.config/qtile/autostart.sh source ~/.scripts/lib/env.sh load_env_colors Debugging: source ~/.scripts/lib/env.sh load_env \"debug,core,colors,fzf\" Note: - Modules are comma-separated within a single argument (e.g., \"core,colors\"). - If you use only fzf without colors , FZF uses sane defaults without theming. [!TIP] - Consider splitting the modules argument by commas and matching tokens to avoid accidental substring matches (e.g., \u201cgitx\u201d matching \u201cgit\u201d). - Auto-enable colors when fzf is requested to ensure themed output: detect fzf and source colors if not present. - Add command existence checks ( fd , bat , fzf ) and degrade gracefully or warn when missing. - Export $SCRIPT_PATHS into $PATH only once using a loop over components to reduce duplication logic. - Provide an \u201cunload\u201d or \u201creload\u201d function to reset FZF options when testing.","title":"Environment Loader Library (Flexoki/FZF/Paths)"},{"location":"scripts/env.sh/#environment-loader-library-flexokifzfpaths","text":"env.sh : Modular environment loader for colors, FZF, paths, git and debug","title":"Environment Loader Library (Flexoki/FZF/Paths)"},{"location":"scripts/env.sh/#dependencies","text":"bash \u2014 required; uses arrays, export -f, and BASH_SOURCE coreutils \u2014 for readlink used to resolve script root fd \u2014 used by FZF_DEFAULT_COMMAND for fast file search bat \u2014 used by FZF_PREVIEW_COMMAND for syntax-highlighted previews fzf \u2014 interactive fuzzy finder, styled via Flexoki palette (optional)","title":"Dependencies"},{"location":"scripts/env.sh/#description","text":"This library provides a single function, load_env , that sets up a modular environment for your scripts on Arch + qtile. It discovers your scripts root at runtime ( $SCRIPTS ) via readlink -f \"${BASH_SOURCE[0]}\" , populates $PATH with $SCRIPTS/bin and $HOME/.local/bin , and optionally configures: Flexoki color palette (exports named hex colors + semantic aliases) FZF defaults (command, keybindings, preview, and themed colors) Git-related locations ( $GIT_REPOS , $LOCALDATA ) Debug output to stderr It is idempotent: a guard ( $SCRIPTS_ENV_LOADED ) avoids re-initializing core state. Convenience wrappers are exported: load_env_minimal , load_env_colors , load_env_fzf , load_env_full .","title":"Description"},{"location":"scripts/env.sh/#usage","text":"tldr: # In an interactive shell (bash) source ~/.scripts/lib/env.sh load_env \"core,colors,fzf\" fzf # now uses Flexoki theme and fd+bat preview In another script: #!/usr/bin/env bash source \"$(dirname \"${BASH_SOURCE[0]}\")/../lib/env.sh\" load_env_full # your script... Using helpers: source ~/.scripts/lib/env.sh load_env_fzf # == \"core,colors,fzf\" load_env_minimal # only core paths Qtile integration (autostart or spawned scripts): # ~/.config/qtile/autostart.sh source ~/.scripts/lib/env.sh load_env_colors Debugging: source ~/.scripts/lib/env.sh load_env \"debug,core,colors,fzf\" Note: - Modules are comma-separated within a single argument (e.g., \"core,colors\"). - If you use only fzf without colors , FZF uses sane defaults without theming. [!TIP] - Consider splitting the modules argument by commas and matching tokens to avoid accidental substring matches (e.g., \u201cgitx\u201d matching \u201cgit\u201d). - Auto-enable colors when fzf is requested to ensure themed output: detect fzf and source colors if not present. - Add command existence checks ( fd , bat , fzf ) and degrade gracefully or warn when missing. - Export $SCRIPT_PATHS into $PATH only once using a loop over components to reduce duplication logic. - Provide an \u201cunload\u201d or \u201creload\u201d function to reset FZF options when testing.","title":"Usage"},{"location":"scripts/fix-markdown-links.sh/","text":"Fix Markdown Links Script fix-markdown-links.sh : Adjust relative paths in markdown links to start from a base directory Dependencies bash : This script requires the Bash shell to execute. sed : Utilized for modifying file content. find : Used to locate markdown files within a directory. Description The fix-markdown-links.sh script is designed to process markdown files and prepend a leading slash to relative links, ensuring they start from a specified base directory. This script will be particularly useful when restructuring projects where the markdown files are moved under a new directory hierarchy, or when you need uniform link formatting across multiple files. The script uses the sed command to search and replace link patterns without a leading slash, adding one where necessary. It takes two arguments: a base directory and either a markdown file or a directory containing markdown files. Once executed, the script reads all markdown files, either directly or recursively through directories, adjusts the links, and confirms each processed file. Usage To execute the script: $ ./fix-markdown-links.sh /base/directory /path/to/markdown/file/or/directory \\<base_dir> : The base directory to which markdown links should be relative. \\<file or directory> : The markdown file or the directory containing markdown files. For example, if you want to process all markdown files under /home/matias/projects and make the links relative to /home/matias : ./fix-markdown-links.sh /home/matias /home/matias/projects The script will adjust the links and confirm processing by outputting each file name. [!NOTE] The script assumes that links not starting with a slash are meant to be file-relative links, which may not always be the case. It is designed specifically for the scenario where markdown files need links adjusted to a new consistent base directory. Be cautious with different link types or structures that might not fit this assumption. Future improvements could include complex path restructuring or more flexible link pattern matching.","title":"Fix Markdown Links Script"},{"location":"scripts/fix-markdown-links.sh/#fix-markdown-links-script","text":"fix-markdown-links.sh : Adjust relative paths in markdown links to start from a base directory","title":"Fix Markdown Links Script"},{"location":"scripts/fix-markdown-links.sh/#dependencies","text":"bash : This script requires the Bash shell to execute. sed : Utilized for modifying file content. find : Used to locate markdown files within a directory.","title":"Dependencies"},{"location":"scripts/fix-markdown-links.sh/#description","text":"The fix-markdown-links.sh script is designed to process markdown files and prepend a leading slash to relative links, ensuring they start from a specified base directory. This script will be particularly useful when restructuring projects where the markdown files are moved under a new directory hierarchy, or when you need uniform link formatting across multiple files. The script uses the sed command to search and replace link patterns without a leading slash, adding one where necessary. It takes two arguments: a base directory and either a markdown file or a directory containing markdown files. Once executed, the script reads all markdown files, either directly or recursively through directories, adjusts the links, and confirms each processed file.","title":"Description"},{"location":"scripts/fix-markdown-links.sh/#usage","text":"To execute the script: $ ./fix-markdown-links.sh /base/directory /path/to/markdown/file/or/directory \\<base_dir> : The base directory to which markdown links should be relative. \\<file or directory> : The markdown file or the directory containing markdown files. For example, if you want to process all markdown files under /home/matias/projects and make the links relative to /home/matias : ./fix-markdown-links.sh /home/matias /home/matias/projects The script will adjust the links and confirm processing by outputting each file name. [!NOTE] The script assumes that links not starting with a slash are meant to be file-relative links, which may not always be the case. It is designed specifically for the scenario where markdown files need links adjusted to a new consistent base directory. Be cautious with different link types or structures that might not fit this assumption. Future improvements could include complex path restructuring or more flexible link pattern matching.","title":"Usage"},{"location":"scripts/flexoki_show.sh/","text":"Flexoki Color Palette Preview flexoki_show.sh : Script to visually display the Flexoki color palette and roles in your terminal Dependencies bash \u2013 Standard shell for script execution. A truecolor-compatible terminal (e.g., alacritty , kitty , gnome-terminal , etc.) Required to properly display 24-bit colors with ANSI escape codes. (Optional) echo with -e support \u2013 Most modern shells complete this requirement. Description This script, flexoki_show.sh , prints a formatted table to your terminal that visually previews the Flexoki palette (HEX/RGB values), associated color roles, and UI/syntax information. Each line defines a Flexoki color (e.g., reds, oranges, base colors, etc.). ANSI escape sequences ( \\e[38;2;R;G;Bm ) are used for truecolor output, allowing you to view real color swatches directly within your terminal. Columns include: HEX code RGB value Color name and \"short\" alias UI mapping and syntax hint A colored block visually representing the color Italics and reversed backgrounds/style are also used for visual cues, e.g., to mark certain color roles. Typical use cases: - Quick reference for Flexoki color assignment when theming Qtile, status bars, or Neovim. - Visual confirmation of color mapping for custom scripts or theme development. Usage You can: - Run it directly from your terminal: ~/.scripts/bin/flexoki_show.sh or (if not exported to $PATH ): bash /home/matias/.scripts/bin/flexoki_show.sh Bind to a Qtile key: In your ~/.config/qtile/config.py , add a keybinding such as: python Key([mod], \"F7\", lazy.spawn(\"alacritty -e ~/.scripts/bin/flexoki_show.sh\")) Replace alacritty with your preferred terminal. Pipe or redirect output if you want a raw text (though you\u2019ll lose color formatting): ~/.scripts/bin/flexoki_show.sh > colors.txt [!TIP] - The script is robust for its intended visual role with Bash, but: - Readability : Column alignment is unequal because the formatted color blocks and escape codes cause uneven spacing in different terminals. For best results, use a monospace font and ensure your terminal supports full ANSI/UTF-8 rendering. - Portability : Use of echo -e with ANSI and Unicode blocks works on modern shells but can be inconsistent across older systems or with different versions of echo . For maximum portability and alignment, consider using printf instead of echo -e . - Enhancement : If you plan on scripting or theming more, you may want to add flags (e.g., --short , --ui , --hex-only ) or allow export in JSON/CSV/YAML formats for tooling and automation. - Performance : Not an issue here due to the static nature of the script. - Documentation : The on-screen legend is helpful, but adding in-script comments or usage ( --help output) could be considered.","title":"Flexoki Color Palette Preview"},{"location":"scripts/flexoki_show.sh/#flexoki-color-palette-preview","text":"flexoki_show.sh : Script to visually display the Flexoki color palette and roles in your terminal","title":"Flexoki Color Palette Preview"},{"location":"scripts/flexoki_show.sh/#dependencies","text":"bash \u2013 Standard shell for script execution. A truecolor-compatible terminal (e.g., alacritty , kitty , gnome-terminal , etc.) Required to properly display 24-bit colors with ANSI escape codes. (Optional) echo with -e support \u2013 Most modern shells complete this requirement.","title":"Dependencies"},{"location":"scripts/flexoki_show.sh/#description","text":"This script, flexoki_show.sh , prints a formatted table to your terminal that visually previews the Flexoki palette (HEX/RGB values), associated color roles, and UI/syntax information. Each line defines a Flexoki color (e.g., reds, oranges, base colors, etc.). ANSI escape sequences ( \\e[38;2;R;G;Bm ) are used for truecolor output, allowing you to view real color swatches directly within your terminal. Columns include: HEX code RGB value Color name and \"short\" alias UI mapping and syntax hint A colored block visually representing the color Italics and reversed backgrounds/style are also used for visual cues, e.g., to mark certain color roles. Typical use cases: - Quick reference for Flexoki color assignment when theming Qtile, status bars, or Neovim. - Visual confirmation of color mapping for custom scripts or theme development.","title":"Description"},{"location":"scripts/flexoki_show.sh/#usage","text":"You can: - Run it directly from your terminal: ~/.scripts/bin/flexoki_show.sh or (if not exported to $PATH ): bash /home/matias/.scripts/bin/flexoki_show.sh Bind to a Qtile key: In your ~/.config/qtile/config.py , add a keybinding such as: python Key([mod], \"F7\", lazy.spawn(\"alacritty -e ~/.scripts/bin/flexoki_show.sh\")) Replace alacritty with your preferred terminal. Pipe or redirect output if you want a raw text (though you\u2019ll lose color formatting): ~/.scripts/bin/flexoki_show.sh > colors.txt [!TIP] - The script is robust for its intended visual role with Bash, but: - Readability : Column alignment is unequal because the formatted color blocks and escape codes cause uneven spacing in different terminals. For best results, use a monospace font and ensure your terminal supports full ANSI/UTF-8 rendering. - Portability : Use of echo -e with ANSI and Unicode blocks works on modern shells but can be inconsistent across older systems or with different versions of echo . For maximum portability and alignment, consider using printf instead of echo -e . - Enhancement : If you plan on scripting or theming more, you may want to add flags (e.g., --short , --ui , --hex-only ) or allow export in JSON/CSV/YAML formats for tooling and automation. - Performance : Not an issue here due to the static nature of the script. - Documentation : The on-screen legend is helpful, but adding in-script comments or usage ( --help output) could be considered.","title":"Usage"},{"location":"scripts/ftp-data-mount.sh/","text":"FTP Data Mount Script ftp-data-mount.sh : Mounts a remote DATA folder from Mega via FTP to /mnt/ftp/DATA Dependencies mega-ftp : Command-line tool for managing Mega.nz storage via FTP interface. curlftpfs : Mounts remote FTP folders as local filesystems using FUSE. rg : Ripgrep, a fast grep alternative for searching text (used here for output parsing). cut : Basic UNIX command for splitting lines of text. Bash (intended for /usr/bin/bash , not /bin/sh). Description This script is designed to mount a specific folder named DATA from your Mega.nz account (or any service accessible via mega-ftp ) to a local directory at /mnt/ftp/DATA . Core steps: 1. It defines FOLDER as DATA and DEST as /mnt/ftp . 2. It invokes mega-ftp with the folder name, presumably to initialize or refresh authorization or listing. 3. It then obtains the FTP URL corresponding to the DATA folder using: - mega-ftp to list FTP targets, - rg to search for the DATA folder line, - cut -d' ' -f2 to extract the FTP URL/Path. 4. It mounts the remote folder to /mnt/ftp/DATA using curlftpfs . The script assumes that: - The output of mega-ftp contains lines with the folder name and its corresponding FTP URL, separated by spaces. - The destination directory /mnt/ftp (and /mnt/ftp/DATA ) exists and is writable. Usage Mount DATA folder to /mnt/ftp/DATA: ~/.scripts/bin/ftp-data-mount.sh Typical workflow: - You can run this script manually in a terminal. - For integration in qtile, assign it to a keybinding for quick mount operations. - To unmount, use: bash fusermount -u /mnt/ftp/DATA Automate on login/startup: You may call this script from your .xprofile or as a hook in your qtile config. [!NOTE] - The script lacks error handling: If mega-ftp fails or if the folder doesn't exist, the script will either do nothing or may return confusing errors. - There are hardcoded paths and folder names ( DATA and /mnt/ftp ). Make these script parameters for reuse and flexibility. - It assumes output formats for both mega-ftp and the folder listings. Changes upstream may break parsing. - Ensure the DEST path exists before running, or add logic to create it as-needed. - Consider saving logs, and providing feedback to the user upon failure/success.","title":"FTP Data Mount Script"},{"location":"scripts/ftp-data-mount.sh/#ftp-data-mount-script","text":"ftp-data-mount.sh : Mounts a remote DATA folder from Mega via FTP to /mnt/ftp/DATA","title":"FTP Data Mount Script"},{"location":"scripts/ftp-data-mount.sh/#dependencies","text":"mega-ftp : Command-line tool for managing Mega.nz storage via FTP interface. curlftpfs : Mounts remote FTP folders as local filesystems using FUSE. rg : Ripgrep, a fast grep alternative for searching text (used here for output parsing). cut : Basic UNIX command for splitting lines of text. Bash (intended for /usr/bin/bash , not /bin/sh).","title":"Dependencies"},{"location":"scripts/ftp-data-mount.sh/#description","text":"This script is designed to mount a specific folder named DATA from your Mega.nz account (or any service accessible via mega-ftp ) to a local directory at /mnt/ftp/DATA . Core steps: 1. It defines FOLDER as DATA and DEST as /mnt/ftp . 2. It invokes mega-ftp with the folder name, presumably to initialize or refresh authorization or listing. 3. It then obtains the FTP URL corresponding to the DATA folder using: - mega-ftp to list FTP targets, - rg to search for the DATA folder line, - cut -d' ' -f2 to extract the FTP URL/Path. 4. It mounts the remote folder to /mnt/ftp/DATA using curlftpfs . The script assumes that: - The output of mega-ftp contains lines with the folder name and its corresponding FTP URL, separated by spaces. - The destination directory /mnt/ftp (and /mnt/ftp/DATA ) exists and is writable.","title":"Description"},{"location":"scripts/ftp-data-mount.sh/#usage","text":"Mount DATA folder to /mnt/ftp/DATA: ~/.scripts/bin/ftp-data-mount.sh Typical workflow: - You can run this script manually in a terminal. - For integration in qtile, assign it to a keybinding for quick mount operations. - To unmount, use: bash fusermount -u /mnt/ftp/DATA Automate on login/startup: You may call this script from your .xprofile or as a hook in your qtile config. [!NOTE] - The script lacks error handling: If mega-ftp fails or if the folder doesn't exist, the script will either do nothing or may return confusing errors. - There are hardcoded paths and folder names ( DATA and /mnt/ftp ). Make these script parameters for reuse and flexibility. - It assumes output formats for both mega-ftp and the folder listings. Changes upstream may break parsing. - Ensure the DEST path exists before running, or add logic to create it as-needed. - Consider saving logs, and providing feedback to the user upon failure/success.","title":"Usage"},{"location":"scripts/fzf-file-manager.sh/","text":"Fuzzy File Manager with fzf fzf-file-manager.sh : Interactive terminal-based file manager leveraging fzf and eza for rapid navigation. Dependencies fzf : Fuzzy finder for the terminal, provides search and selection UI. eza : Enhanced ls replacement, used for directory listings and preview formatting. bat : Syntax-highlighting cat clone, renders content previews. rg (ripgrep): Rapid grep tool, used for environment variable searching and file content matching. pastel : Command-line color manipulation tool, formats color for previews. kitten icat : For inline image previews in compatible terminals. awk , sed , file : Standard command-line tools for processing outputs. notify-send : Sends desktop notifications, used for debug/informational purposes. Description This script implements a robust, interactive file manager for your terminal window manager (like qtile), utilizing a rich set of tools for both navigation and file previewing. The workflow pivots around the powerful fuzzy searching provided by fzf , which is deeply integrated with eza 's colorful and featureful directory listings. Key Features: - Directory Navigation : Navigate up and down the directory tree using fuzzy search results, with support for both 'forward' and 'backward' movement via line selection. - File Preview : Inline preview for: - Directories (tree with eza ) - Text files (syntax highlighting with bat ) - Image files (shown inline using kitten icat when supported) - File and directory metadata (via file , eza_def , and labels) - Custom Theming : Color extraction from the environment (expecting FLEXOKI* variables) for fine-tuned appearance. - Interactive Controls : Keybindings within fzf for toggling preview, changing prompt, jumping, directional navigation, and refreshing preview. - Continuous Navigation Loop : Loops until an entry is selected or quit, updating the current directory based on selection logic. Usage Run Directly in Terminal bash ~/.scripts/bin/fzf-file-manager.sh Assign to a Keybinding (qtile example) Add to your .config/qtile/config.py : Key([mod], \"e\", lazy.spawn(\"bash ~/.scripts/bin/fzf-file-manager.sh\")), Key Interactions While Running Within the fzf interface: - Alt+P : Toggle preview window. - Alt+Space : Execute a fresh preview of the selection. - Alt+H : Toggle prompt label and reload listing (shows hidden files). - Directional navigation is embedded based on the \"forward\" or \"backward\" lines in the file details. - Ctrl+H / Ctrl+L : Move backward/forward in navigation. Note : The script expects your terminal to support truecolor and the Kitty graphics protocol for image preview. [!WARNING] - The script is quite monolithic and complex; breaking functionality into smaller scripts (e.g., dedicated preview/render helpers) could improve readability and maintenance. - Error handling is minimal: if dependencies (like kitten icat ) are missing, previews silently fail or produce odd behavior. - Certain features seem experimental or commented out, and some bindings are not fully documented\u2014adding an in-script help display would enhance usability. - Assumes a specific environment with color variables set ( FLEXOKI* ), which could cause issues on other setups; fallback defaults or checks for these would improve portability.","title":"Fuzzy File Manager with fzf"},{"location":"scripts/fzf-file-manager.sh/#fuzzy-file-manager-with-fzf","text":"fzf-file-manager.sh : Interactive terminal-based file manager leveraging fzf and eza for rapid navigation.","title":"Fuzzy File Manager with fzf"},{"location":"scripts/fzf-file-manager.sh/#dependencies","text":"fzf : Fuzzy finder for the terminal, provides search and selection UI. eza : Enhanced ls replacement, used for directory listings and preview formatting. bat : Syntax-highlighting cat clone, renders content previews. rg (ripgrep): Rapid grep tool, used for environment variable searching and file content matching. pastel : Command-line color manipulation tool, formats color for previews. kitten icat : For inline image previews in compatible terminals. awk , sed , file : Standard command-line tools for processing outputs. notify-send : Sends desktop notifications, used for debug/informational purposes.","title":"Dependencies"},{"location":"scripts/fzf-file-manager.sh/#description","text":"This script implements a robust, interactive file manager for your terminal window manager (like qtile), utilizing a rich set of tools for both navigation and file previewing. The workflow pivots around the powerful fuzzy searching provided by fzf , which is deeply integrated with eza 's colorful and featureful directory listings. Key Features: - Directory Navigation : Navigate up and down the directory tree using fuzzy search results, with support for both 'forward' and 'backward' movement via line selection. - File Preview : Inline preview for: - Directories (tree with eza ) - Text files (syntax highlighting with bat ) - Image files (shown inline using kitten icat when supported) - File and directory metadata (via file , eza_def , and labels) - Custom Theming : Color extraction from the environment (expecting FLEXOKI* variables) for fine-tuned appearance. - Interactive Controls : Keybindings within fzf for toggling preview, changing prompt, jumping, directional navigation, and refreshing preview. - Continuous Navigation Loop : Loops until an entry is selected or quit, updating the current directory based on selection logic.","title":"Description"},{"location":"scripts/fzf-file-manager.sh/#usage","text":"","title":"Usage"},{"location":"scripts/fzf-file-manager.sh/#run-directly-in-terminal","text":"bash ~/.scripts/bin/fzf-file-manager.sh","title":"Run Directly in Terminal"},{"location":"scripts/fzf-file-manager.sh/#assign-to-a-keybinding-qtile-example","text":"Add to your .config/qtile/config.py : Key([mod], \"e\", lazy.spawn(\"bash ~/.scripts/bin/fzf-file-manager.sh\")),","title":"Assign to a Keybinding (qtile example)"},{"location":"scripts/fzf-file-manager.sh/#key-interactions-while-running","text":"Within the fzf interface: - Alt+P : Toggle preview window. - Alt+Space : Execute a fresh preview of the selection. - Alt+H : Toggle prompt label and reload listing (shows hidden files). - Directional navigation is embedded based on the \"forward\" or \"backward\" lines in the file details. - Ctrl+H / Ctrl+L : Move backward/forward in navigation. Note : The script expects your terminal to support truecolor and the Kitty graphics protocol for image preview. [!WARNING] - The script is quite monolithic and complex; breaking functionality into smaller scripts (e.g., dedicated preview/render helpers) could improve readability and maintenance. - Error handling is minimal: if dependencies (like kitten icat ) are missing, previews silently fail or produce odd behavior. - Certain features seem experimental or commented out, and some bindings are not fully documented\u2014adding an in-script help display would enhance usability. - Assumes a specific environment with color variables set ( FLEXOKI* ), which could cause issues on other setups; fallback defaults or checks for these would improve portability.","title":"Key Interactions While Running"},{"location":"scripts/fzf_albumlauncher.xsh/","text":"FZF Album Launcher for cmus fzf_albumlauncher.xsh : Pick an album via fzf and queue/play it in cmus Dependencies xonsh \u2014 script interpreter. beets ( beet ) \u2014 provides album list; beet ls -a outputs albums. fzf \u2014 fuzzy finder for interactive selection. cmus and cmus-remote \u2014 audio player and its remote control. sed \u2014 used to extract album names from beets output. Description This xonsh script lets you fuzzy-search your beets album library and instantly queue and play the selection in cmus. Flow: - Lists albums with beet ls -a , then uses sed 's/.* - //g' to keep only the album title (dropping the artist). - Pipes into fzf for interactive selection; the chosen line is .strip() \u2019d. - If a selection is made, cmus is controlled via cmus-remote : - Switches to the queue view, clears it, then goes to the sorted library view. - Applies a filter album=\"<selection>\" , marks results, and adds them to the queue ( win-add-q ). - Clears the filter, returns to the queue, nudges playback ( -n , -p ), and saves the queue to /tmp/nowplaying.m3u . On Arch Linux, install dependencies with pacman: cmus , fzf , beets , xonsh , sed . Ensure cmus is running before using the script. Usage Make executable: chmod +x ~/.scripts/bin/fzf_albumlauncher.xsh Run from a terminal: ~/.scripts/bin/fzf_albumlauncher.xsh From qtile, bind a key (example): Key([mod], \"a\", lazy.spawn(\"~/.scripts/bin/fzf_albumlauncher.xsh\")) If fzf layout needs tuning, set FZF_DEFAULT_OPTS (e.g., --height 60% --reverse ) in your shell env. Result: Selected album is queued and starts playing; the current queue is saved to /tmp/nowplaying.m3u . [!TIP] Improvements and caveats: - Ambiguity: Only album names are used. If two artists have an album with the same title, both may be queued. Consider feeding fzf with \"$albumartist - $album\" and filtering with both fields (e.g., filter album=\"$album\" albumartist=\"$artist\" ). - Quoting: Albums containing double quotes will break the filter. Escape quotes in the query (e.g., replace \" with \\\" ). - sed split: Using s/.* - // assumes the format includes \u201c - \u201d once; album titles containing \u201c - \u201d will be truncated. Prefer beet ls -a -f '$albumartist\\t$album' and parse robustly. - cmus state: Ensure cmus is running; otherwise cmus-remote will fail. Consider auto-starting cmus if not detected.","title":"FZF Album Launcher for cmus"},{"location":"scripts/fzf_albumlauncher.xsh/#fzf-album-launcher-for-cmus","text":"fzf_albumlauncher.xsh : Pick an album via fzf and queue/play it in cmus","title":"FZF Album Launcher for cmus"},{"location":"scripts/fzf_albumlauncher.xsh/#dependencies","text":"xonsh \u2014 script interpreter. beets ( beet ) \u2014 provides album list; beet ls -a outputs albums. fzf \u2014 fuzzy finder for interactive selection. cmus and cmus-remote \u2014 audio player and its remote control. sed \u2014 used to extract album names from beets output.","title":"Dependencies"},{"location":"scripts/fzf_albumlauncher.xsh/#description","text":"This xonsh script lets you fuzzy-search your beets album library and instantly queue and play the selection in cmus. Flow: - Lists albums with beet ls -a , then uses sed 's/.* - //g' to keep only the album title (dropping the artist). - Pipes into fzf for interactive selection; the chosen line is .strip() \u2019d. - If a selection is made, cmus is controlled via cmus-remote : - Switches to the queue view, clears it, then goes to the sorted library view. - Applies a filter album=\"<selection>\" , marks results, and adds them to the queue ( win-add-q ). - Clears the filter, returns to the queue, nudges playback ( -n , -p ), and saves the queue to /tmp/nowplaying.m3u . On Arch Linux, install dependencies with pacman: cmus , fzf , beets , xonsh , sed . Ensure cmus is running before using the script.","title":"Description"},{"location":"scripts/fzf_albumlauncher.xsh/#usage","text":"Make executable: chmod +x ~/.scripts/bin/fzf_albumlauncher.xsh Run from a terminal: ~/.scripts/bin/fzf_albumlauncher.xsh From qtile, bind a key (example): Key([mod], \"a\", lazy.spawn(\"~/.scripts/bin/fzf_albumlauncher.xsh\")) If fzf layout needs tuning, set FZF_DEFAULT_OPTS (e.g., --height 60% --reverse ) in your shell env. Result: Selected album is queued and starts playing; the current queue is saved to /tmp/nowplaying.m3u . [!TIP] Improvements and caveats: - Ambiguity: Only album names are used. If two artists have an album with the same title, both may be queued. Consider feeding fzf with \"$albumartist - $album\" and filtering with both fields (e.g., filter album=\"$album\" albumartist=\"$artist\" ). - Quoting: Albums containing double quotes will break the filter. Escape quotes in the query (e.g., replace \" with \\\" ). - sed split: Using s/.* - // assumes the format includes \u201c - \u201d once; album titles containing \u201c - \u201d will be truncated. Prefer beet ls -a -f '$albumartist\\t$album' and parse robustly. - cmus state: Ensure cmus is running; otherwise cmus-remote will fail. Consider auto-starting cmus if not detected.","title":"Usage"},{"location":"scripts/fzf_songlauncher.sh/","text":"fzf Song Launcher fzf_songlauncher.sh : Quickly choose and play a song with cmus using fzf fuzzy finder Dependencies cmus-remote Command-line remote control for the cmus music player. find Standard UNIX utility to search for files in a directory hierarchy. fzf Command-line fuzzy finder, allows interactive selection. A music directory The script assumes music (relative to where it's run) contains your music files. Description This script provides a rapid way to browse and play songs with minimal keystrokes, leveraging fuzzy searching. It searches recursively for files in your music directory ( find -L music -type f ). -L ensures that symbolic links are followed. The results are piped into fzf , which presents an interactive fuzzy search interface in your terminal. The selected file's full path is passed as an argument to cmus-remote -f , instructing the running cmus instance to play that file immediately. This utility is particularly useful in a qtile environment on Arch Linux, where quick minimal interfaces are favored and scripts can be tightly integrated with keybindings. Usage Ensure cmus is running in a background terminal. Ensure your music files are placed inside a directory named music in your home or desired location. Execute the script: /home/matias/.scripts/bin/fzf_songlauncher.sh Or, make it executable and call directly: chmod +x ~/.scripts/bin/fzf_songlauncher.sh ~/.scripts/bin/fzf_songlauncher.sh Optionally, bind this script to a keybinding in your qtile config for instant access. tldr: cd ~/ # directory should contain 'music' ./.scripts/bin/fzf_songlauncher.sh You'll get a fuzzy file selector. Choose a song. It will play in cmus. [!TIP] - The music directory is hardcoded and relative; if run outside the intended location (e.g., from ~/ ), it may not find your files. Consider making the path absolute or configurable by environment variable or argument. - No filetype filtering: all files in music are selectable\u2014even non-audio files. Consider restricting the file types ( -iname \"*.mp3\" etc.). - No cmus instance check: if cmus isn't running, the script fails silently. - A minimal usage message or error reporting would improve user feedback.","title":"fzf Song Launcher"},{"location":"scripts/fzf_songlauncher.sh/#fzf-song-launcher","text":"fzf_songlauncher.sh : Quickly choose and play a song with cmus using fzf fuzzy finder","title":"fzf Song Launcher"},{"location":"scripts/fzf_songlauncher.sh/#dependencies","text":"cmus-remote Command-line remote control for the cmus music player. find Standard UNIX utility to search for files in a directory hierarchy. fzf Command-line fuzzy finder, allows interactive selection. A music directory The script assumes music (relative to where it's run) contains your music files.","title":"Dependencies"},{"location":"scripts/fzf_songlauncher.sh/#description","text":"This script provides a rapid way to browse and play songs with minimal keystrokes, leveraging fuzzy searching. It searches recursively for files in your music directory ( find -L music -type f ). -L ensures that symbolic links are followed. The results are piped into fzf , which presents an interactive fuzzy search interface in your terminal. The selected file's full path is passed as an argument to cmus-remote -f , instructing the running cmus instance to play that file immediately. This utility is particularly useful in a qtile environment on Arch Linux, where quick minimal interfaces are favored and scripts can be tightly integrated with keybindings.","title":"Description"},{"location":"scripts/fzf_songlauncher.sh/#usage","text":"Ensure cmus is running in a background terminal. Ensure your music files are placed inside a directory named music in your home or desired location. Execute the script: /home/matias/.scripts/bin/fzf_songlauncher.sh Or, make it executable and call directly: chmod +x ~/.scripts/bin/fzf_songlauncher.sh ~/.scripts/bin/fzf_songlauncher.sh Optionally, bind this script to a keybinding in your qtile config for instant access. tldr: cd ~/ # directory should contain 'music' ./.scripts/bin/fzf_songlauncher.sh You'll get a fuzzy file selector. Choose a song. It will play in cmus. [!TIP] - The music directory is hardcoded and relative; if run outside the intended location (e.g., from ~/ ), it may not find your files. Consider making the path absolute or configurable by environment variable or argument. - No filetype filtering: all files in music are selectable\u2014even non-audio files. Consider restricting the file types ( -iname \"*.mp3\" etc.). - No cmus instance check: if cmus isn't running, the script fails silently. - A minimal usage message or error reporting would improve user feedback.","title":"Usage"},{"location":"scripts/fzfmenu.sh/","text":"fzfmenu Helper (fzfmenu.sh) fzfmenu.sh : Helper script that runs fzf inside an alacritty terminal instance. Dependencies alacritty GPU-accelerated terminal emulator used to spawn a floating window for menu interaction. fzf Command-line fuzzy finder; provides interactive filtering UX. Bash Standard shell interpreter ( #!/bin/bash ). (Optional) External scripts or programs whose output is piped into this script. Description This script emulates the role of a \"rofi\" or \"dmenu\" prompt using alacritty and fzf for a more extensible, powerful selection interface. It acts as a drop-in interactive menu system, especially suitable for workflows in tiling WMs such as Qtile under Arch Linux. Functionality breakdown: - Receives arguments meant for fzf (such as options to customize prompt, layout, preview, etc.). - Securely escapes all provided arguments to ensure safe command parsing. - Spawns an alacritty terminal with the window title fzfmenu , executes fzf with the provided arguments, and connects its input and output directly to the parent process' standard input/output using /proc/$$/fd/{0,1} . This function is best invoked by other scripts as a helper to display selections in a floating/centered alacritty window. Usage You usually don't call this script directly, but as part of a larger menu script or from within keybindings in Qtile. However, standalone usage is possible for debugging. Example (Basic File Picker): ls | ~/.scripts/bin/fzfmenu.sh --prompt=\"Pick a file: \" With Custom Preview Window: find ~/Documents -type f | ~/.scripts/bin/fzfmenu.sh --preview='head -20 {}' --height=40% Integration in a Script (Pseudocode): choices=$(some_command_producing_list | ~/.scripts/bin/fzfmenu.sh [fzf options]) Qtile Keybinding (Python fragment): Key([mod], \"p\", lazy.spawn(\"my-launcher-script.sh\")) Each script that needs a selection/launcher menu can use fzfmenu.sh as the backend. [!TIP] While this script securely escapes and forwards options to fzf (improving safety compared to naive wrappers), several considerations could improve robustness: - No input checking : The script assumes that stdin, stdout, and /proc/$$/fd/{0,1} are available and properly connected. Not all terminals/shell invocations will provide these; a check and fallback for non-Linux/pseudo-terminal use would increase portability. - No error handling : If alacritty or fzf are missing, the script fails silently. Consider adding checks for dependencies or descriptive error messages for easier debugging. - Window management : By default, alacritty will open in a standard size; integrating options to open as a floating/centered window (using --class , --geometry , or external WM rules) might better emulate dmenu-like UX in Qtile. - Performance : For very large input lists, piping directly through the script may be slower than using fzf async sources. Consider allowing additional fzf features for large/remote datasets.","title":"fzfmenu Helper (fzfmenu.sh)"},{"location":"scripts/fzfmenu.sh/#fzfmenu-helper-fzfmenush","text":"fzfmenu.sh : Helper script that runs fzf inside an alacritty terminal instance.","title":"fzfmenu Helper (fzfmenu.sh)"},{"location":"scripts/fzfmenu.sh/#dependencies","text":"alacritty GPU-accelerated terminal emulator used to spawn a floating window for menu interaction. fzf Command-line fuzzy finder; provides interactive filtering UX. Bash Standard shell interpreter ( #!/bin/bash ). (Optional) External scripts or programs whose output is piped into this script.","title":"Dependencies"},{"location":"scripts/fzfmenu.sh/#description","text":"This script emulates the role of a \"rofi\" or \"dmenu\" prompt using alacritty and fzf for a more extensible, powerful selection interface. It acts as a drop-in interactive menu system, especially suitable for workflows in tiling WMs such as Qtile under Arch Linux. Functionality breakdown: - Receives arguments meant for fzf (such as options to customize prompt, layout, preview, etc.). - Securely escapes all provided arguments to ensure safe command parsing. - Spawns an alacritty terminal with the window title fzfmenu , executes fzf with the provided arguments, and connects its input and output directly to the parent process' standard input/output using /proc/$$/fd/{0,1} . This function is best invoked by other scripts as a helper to display selections in a floating/centered alacritty window.","title":"Description"},{"location":"scripts/fzfmenu.sh/#usage","text":"You usually don't call this script directly, but as part of a larger menu script or from within keybindings in Qtile. However, standalone usage is possible for debugging. Example (Basic File Picker): ls | ~/.scripts/bin/fzfmenu.sh --prompt=\"Pick a file: \" With Custom Preview Window: find ~/Documents -type f | ~/.scripts/bin/fzfmenu.sh --preview='head -20 {}' --height=40% Integration in a Script (Pseudocode): choices=$(some_command_producing_list | ~/.scripts/bin/fzfmenu.sh [fzf options]) Qtile Keybinding (Python fragment): Key([mod], \"p\", lazy.spawn(\"my-launcher-script.sh\")) Each script that needs a selection/launcher menu can use fzfmenu.sh as the backend. [!TIP] While this script securely escapes and forwards options to fzf (improving safety compared to naive wrappers), several considerations could improve robustness: - No input checking : The script assumes that stdin, stdout, and /proc/$$/fd/{0,1} are available and properly connected. Not all terminals/shell invocations will provide these; a check and fallback for non-Linux/pseudo-terminal use would increase portability. - No error handling : If alacritty or fzf are missing, the script fails silently. Consider adding checks for dependencies or descriptive error messages for easier debugging. - Window management : By default, alacritty will open in a standard size; integrating options to open as a floating/centered window (using --class , --geometry , or external WM rules) might better emulate dmenu-like UX in Qtile. - Performance : For very large input lists, piping directly through the script may be slower than using fzf async sources. Consider allowing additional fzf features for large/remote datasets.","title":"Usage"},{"location":"scripts/fzfmenu_cache.sh/","text":"fzfmenu cache builder for PATH executables fzfmenu_cache.sh : Cache PATH executables to RAM and print them, with background refresh Dependencies bash \u2014 shell interpreter fd \u2014 fast file finder; used to list executables/symlinks in PATH coreutils \u2014 sort , cat , tee , mv , rm fzf (optional) \u2014 consumer for interactive selection Description This helper builds and serves a fast, deduplicated list of launchable commands for your fzf-based launcher. It scans only the first level of each directory in PATH (prepending $HOME/.local/bin and /usr/bin ), collecting both executable files and symlinks using fd with -t x -t l --maxdepth 1 , then sorts them uniquely. The list is cached in RAM at /dev/shm/fzfmenu_path_cache to minimize disk I/O and keep startup snappy under Qtile on Arch. On normal invocation, it prints the cached list to stdout (creating it if missing) and simultaneously refreshes the cache in the background for the next run. A --refresh mode atomically rebuilds the cache and exits without printing. Color output is currently preserved via fd --color=always , which is useful when piping into fzf --ansi . Usage Print list (build if needed), suitable for piping: ~/.scripts/bin/fzfmenu_cache.sh Force a cache rebuild only (e.g., at login or on PATH changes): ~/.scripts/bin/fzfmenu_cache.sh --refresh Use with fzf to pick and launch a command (detached): cmd=\"$(~/.scripts/bin/fzfmenu_cache.sh | fzf --ansi)\" [ -n \"$cmd\" ] && setsid -f \"$cmd\" >/dev/null 2>&1 Pre-warm cache from Qtile autostart (once per session): ~/.scripts/bin/fzfmenu_cache.sh --refresh & Cron/systemd-user timer alternative: run --refresh periodically to keep it hot. [!TIP] - When no cache exists, two builds may run concurrently (one for output, one for refresh). Consider guarding refresh with flock or skipping the extra rebuild on first run. - The output is produced from a background job; if a consumer expects synchronous output, foreground the initial output and only refresh in the background. - Caching colored lines ( --color=always ) can leak ANSI codes to non-fzf consumers; consider storing plain output and adding a flag to colorize on demand. - Validate fd availability and provide a graceful fallback or hint (e.g., install fd on Arch). - You may want to include /usr/local/bin in PATH precedence if you rely on locally installed binaries.","title":"fzfmenu cache builder for PATH executables"},{"location":"scripts/fzfmenu_cache.sh/#fzfmenu-cache-builder-for-path-executables","text":"fzfmenu_cache.sh : Cache PATH executables to RAM and print them, with background refresh","title":"fzfmenu cache builder for PATH executables"},{"location":"scripts/fzfmenu_cache.sh/#dependencies","text":"bash \u2014 shell interpreter fd \u2014 fast file finder; used to list executables/symlinks in PATH coreutils \u2014 sort , cat , tee , mv , rm fzf (optional) \u2014 consumer for interactive selection","title":"Dependencies"},{"location":"scripts/fzfmenu_cache.sh/#description","text":"This helper builds and serves a fast, deduplicated list of launchable commands for your fzf-based launcher. It scans only the first level of each directory in PATH (prepending $HOME/.local/bin and /usr/bin ), collecting both executable files and symlinks using fd with -t x -t l --maxdepth 1 , then sorts them uniquely. The list is cached in RAM at /dev/shm/fzfmenu_path_cache to minimize disk I/O and keep startup snappy under Qtile on Arch. On normal invocation, it prints the cached list to stdout (creating it if missing) and simultaneously refreshes the cache in the background for the next run. A --refresh mode atomically rebuilds the cache and exits without printing. Color output is currently preserved via fd --color=always , which is useful when piping into fzf --ansi .","title":"Description"},{"location":"scripts/fzfmenu_cache.sh/#usage","text":"Print list (build if needed), suitable for piping: ~/.scripts/bin/fzfmenu_cache.sh Force a cache rebuild only (e.g., at login or on PATH changes): ~/.scripts/bin/fzfmenu_cache.sh --refresh Use with fzf to pick and launch a command (detached): cmd=\"$(~/.scripts/bin/fzfmenu_cache.sh | fzf --ansi)\" [ -n \"$cmd\" ] && setsid -f \"$cmd\" >/dev/null 2>&1 Pre-warm cache from Qtile autostart (once per session): ~/.scripts/bin/fzfmenu_cache.sh --refresh & Cron/systemd-user timer alternative: run --refresh periodically to keep it hot. [!TIP] - When no cache exists, two builds may run concurrently (one for output, one for refresh). Consider guarding refresh with flock or skipping the extra rebuild on first run. - The output is produced from a background job; if a consumer expects synchronous output, foreground the initial output and only refresh in the background. - Caching colored lines ( --color=always ) can leak ANSI codes to non-fzf consumers; consider storing plain output and adding a flag to colorize on demand. - Validate fd availability and provide a graceful fallback or hint (e.g., install fd on Arch). - You may want to include /usr/local/bin in PATH precedence if you rely on locally installed binaries.","title":"Usage"},{"location":"scripts/fzfmenu_run.sh/","text":"FZF Menu Runner fzfmenu_run.sh : Launches app selection using fzf in a floating terminal, as a dmenu_run replacement. Dependencies fzfmenu_cache.sh \u2013 Script to retrieve/caches a list of executable commands. improved-fzfmenu.sh \u2013 Wrapper to present the list through fzf in an improved (highlighted/ansi) way. fzf \u2013 Command-line fuzzy finder. systemd-run \u2013 Run a process in a user-scoped transient systemd unit. bash \u2013 Standard bash shell. xterm or alternative configured backend \u2013 Floating terminal is implied; if using with qtile, proper floating behavior must be configured. Description This script is intended as a modern, more powerful drop-in replacement for dmenu_run on a system using fzf (fuzzy finder) for interactive app launching. It is especially well-suited for advanced window managers like Qtile. Workflow : 1. Gathers available command entries via fzfmenu_cache.sh . 2. Pipes them into improved-fzfmenu.sh to display and select using fzf . 3. Captures the selected command; if none, simply exits. 4. Runs your selection in the background using systemd-run for resource isolation, invoking the command under bash . This pattern is robust for use under custom keybindings or as a modular launcher for frequently used programs in the Qtile environment. Usage Run directly in a floating terminal: ~/.scripts/bin/fzfmenu_run.sh Recommended: map to a qtile keybinding (for example, mod+p): Key([mod], \"p\", lazy.spawn(\"xterm -e ~/.scripts/bin/fzfmenu_run.sh\")) Depending on your usual terminal setup or launcher, you may want to ensure that the terminal opens in floating mode for best experience. tldr - Launch the script to choose and run any command interactively. - Nothing is executed if you don't make a selection. - Runs safely in its own systemd scope for stability. [!TIP] - This script is tightly coupled to custom helpers: fzfmenu_cache.sh and improved-fzfmenu.sh . These should be version-locked or managed carefully to avoid future breakage. - Consider handling multi-word/argument applications more explicitly (e.g., quoted entries) if not already handled downstream. - There is no error feedback if a selected program fails to launch; integrating simple notifications (e.g., notify-send on failure) could improve UX. - For maximum flexibility, you could allow overriding the terminal or make systemd-run optional via flags.","title":"FZF Menu Runner"},{"location":"scripts/fzfmenu_run.sh/#fzf-menu-runner","text":"fzfmenu_run.sh : Launches app selection using fzf in a floating terminal, as a dmenu_run replacement.","title":"FZF Menu Runner"},{"location":"scripts/fzfmenu_run.sh/#dependencies","text":"fzfmenu_cache.sh \u2013 Script to retrieve/caches a list of executable commands. improved-fzfmenu.sh \u2013 Wrapper to present the list through fzf in an improved (highlighted/ansi) way. fzf \u2013 Command-line fuzzy finder. systemd-run \u2013 Run a process in a user-scoped transient systemd unit. bash \u2013 Standard bash shell. xterm or alternative configured backend \u2013 Floating terminal is implied; if using with qtile, proper floating behavior must be configured.","title":"Dependencies"},{"location":"scripts/fzfmenu_run.sh/#description","text":"This script is intended as a modern, more powerful drop-in replacement for dmenu_run on a system using fzf (fuzzy finder) for interactive app launching. It is especially well-suited for advanced window managers like Qtile. Workflow : 1. Gathers available command entries via fzfmenu_cache.sh . 2. Pipes them into improved-fzfmenu.sh to display and select using fzf . 3. Captures the selected command; if none, simply exits. 4. Runs your selection in the background using systemd-run for resource isolation, invoking the command under bash . This pattern is robust for use under custom keybindings or as a modular launcher for frequently used programs in the Qtile environment.","title":"Description"},{"location":"scripts/fzfmenu_run.sh/#usage","text":"Run directly in a floating terminal: ~/.scripts/bin/fzfmenu_run.sh Recommended: map to a qtile keybinding (for example, mod+p): Key([mod], \"p\", lazy.spawn(\"xterm -e ~/.scripts/bin/fzfmenu_run.sh\")) Depending on your usual terminal setup or launcher, you may want to ensure that the terminal opens in floating mode for best experience. tldr - Launch the script to choose and run any command interactively. - Nothing is executed if you don't make a selection. - Runs safely in its own systemd scope for stability. [!TIP] - This script is tightly coupled to custom helpers: fzfmenu_cache.sh and improved-fzfmenu.sh . These should be version-locked or managed carefully to avoid future breakage. - Consider handling multi-word/argument applications more explicitly (e.g., quoted entries) if not already handled downstream. - There is no error feedback if a selected program fails to launch; integrating simple notifications (e.g., notify-send on failure) could improve UX. - For maximum flexibility, you could allow overriding the terminal or make systemd-run optional via flags.","title":"Usage"},{"location":"scripts/fzfpreview.sh/","text":"fzf File & Image Preview Demo fzfpreview.sh : Display file or image contents in fzf preview window using various tools and fallback logic Dependencies bat or batcat : Syntax-highlighting cat clone for text files. chafa : Convert images for terminal display (Sixel, etc). imgcat : Show images inline in iTerm2. kitty icat : Used for image previews in kitty. fzf : Fuzzy file finder (to provide the preview window). Standard utilities: file , cat , awk , stty , sed . Description This script is a robust utility for integrating file and image preview capabilities into fzf workflows. Depending on file type and available utilities, it: - Displays code/text files with syntax highlighting via bat / batcat (with cat fallback). - Shows images in the preview window using: - kitty icat when in Kitty terminal (with special flags for best preview UX, including scroll bug workarounds), - chafa for terminals supporting Sixel graphics (ensures multi-image support), - imgcat for iTerm2 environments, - or just displays file info if no suitable method is found. Special care is taken to detect binary files, avoid scrolling bugs, and substitute ~ home references. It dynamically sizes the preview window based on fzf environment variables, with fallbacks via stty . Usage You typically call this script from within an fzf command, setting it as the --preview argument: fzf --preview '/home/matias/.scripts/dev/fzfpreview.sh {}' Or, you can preview any file from the terminal: /home/matias/.scripts/dev/fzfpreview.sh ./path/to/file_or_image Arguments: - Takes one positional argument: the path to the file. Examples: - Preview a script file in fzf: fzf --preview '~/.scripts/dev/fzfpreview.sh {}' - Directly preview an image: ~/.scripts/dev/fzfpreview.sh ~/Pictures/test.jpg The script can be assigned to a qtile keybinding or composited into custom scripts for more integrated workflows. [!TIP] - The script assumes you have either bat or batcat for text previews, but doesn't error out if neither is found (falls back to cat without syntax highlighting). - imgcat is assumed to be appropriate if available, but without checks for actual iTerm2 use. The author notes this in the script, but in case you use imgcat outside iTerm2, you could add an explicit check using it2check . - For even better integration with fzf, you could allow the script to accept more than one argument (e.g., adding extra options) or improve error messages if preview tools aren't found. - If you plan to use this on other terminals (not Kitty/iTerm2), verify correct behavior, especially Sixel support. - Consider adding better handling when no dependencies are available, to let the user know which tools are missing for full functionality.","title":"fzf File &amp; Image Preview Demo"},{"location":"scripts/fzfpreview.sh/#fzf-file-image-preview-demo","text":"fzfpreview.sh : Display file or image contents in fzf preview window using various tools and fallback logic","title":"fzf File &amp; Image Preview Demo"},{"location":"scripts/fzfpreview.sh/#dependencies","text":"bat or batcat : Syntax-highlighting cat clone for text files. chafa : Convert images for terminal display (Sixel, etc). imgcat : Show images inline in iTerm2. kitty icat : Used for image previews in kitty. fzf : Fuzzy file finder (to provide the preview window). Standard utilities: file , cat , awk , stty , sed .","title":"Dependencies"},{"location":"scripts/fzfpreview.sh/#description","text":"This script is a robust utility for integrating file and image preview capabilities into fzf workflows. Depending on file type and available utilities, it: - Displays code/text files with syntax highlighting via bat / batcat (with cat fallback). - Shows images in the preview window using: - kitty icat when in Kitty terminal (with special flags for best preview UX, including scroll bug workarounds), - chafa for terminals supporting Sixel graphics (ensures multi-image support), - imgcat for iTerm2 environments, - or just displays file info if no suitable method is found. Special care is taken to detect binary files, avoid scrolling bugs, and substitute ~ home references. It dynamically sizes the preview window based on fzf environment variables, with fallbacks via stty .","title":"Description"},{"location":"scripts/fzfpreview.sh/#usage","text":"You typically call this script from within an fzf command, setting it as the --preview argument: fzf --preview '/home/matias/.scripts/dev/fzfpreview.sh {}' Or, you can preview any file from the terminal: /home/matias/.scripts/dev/fzfpreview.sh ./path/to/file_or_image Arguments: - Takes one positional argument: the path to the file. Examples: - Preview a script file in fzf: fzf --preview '~/.scripts/dev/fzfpreview.sh {}' - Directly preview an image: ~/.scripts/dev/fzfpreview.sh ~/Pictures/test.jpg The script can be assigned to a qtile keybinding or composited into custom scripts for more integrated workflows. [!TIP] - The script assumes you have either bat or batcat for text previews, but doesn't error out if neither is found (falls back to cat without syntax highlighting). - imgcat is assumed to be appropriate if available, but without checks for actual iTerm2 use. The author notes this in the script, but in case you use imgcat outside iTerm2, you could add an explicit check using it2check . - For even better integration with fzf, you could allow the script to accept more than one argument (e.g., adding extra options) or improve error messages if preview tools aren't found. - If you plan to use this on other terminals (not Kitty/iTerm2), verify correct behavior, especially Sixel support. - Consider adding better handling when no dependencies are available, to let the user know which tools are missing for full functionality.","title":"Usage"},{"location":"scripts/generate_commit_message.py/","text":"AI-powered Git commit message generator generate_commit_message.py : Generate commit messages from staged diff via OpenRouter; safe fallback Dependencies uv \u2014 runs the script with inline deps; zero-setup via the shebang python>=3.12 \u2014 runtime for the script requests \u2014 HTTP client (auto-resolved by uv ) git \u2014 to read the staged diff OPENROUTER_API_KEY \u2014 API key in env; also accepts openrouter or any var containing OPENROUTER Description Generates a concise commit message from the staged diff and prints it to stdout. It captures the diff with git diff --cached --no-color --no-ext-diff -U0 , then aggressively condenses large patches to keep the prompt small, skipping noisy paths like node_modules, dist/build artifacts, lockfiles, and minified/map files. Encoding is robust: raw bytes are decoded with COMMIT_DIFF_ENCODING (default utf-8 ) and COMMIT_DIFF_ERRORS (default replace ) to avoid crashes on binary or non-UTF8 data. If an OpenRouter API key is present, it calls https://openrouter.ai/api/v1/chat/completions with openai/gpt-oss-120b to produce a subject (\u226470 chars) plus a short body. Output is sanitized to strictly contain a valid commit message. If the key is missing or the request fails, it falls back to a deterministic summary built from git diff --numstat . Config knobs (env): - COMMIT_MAX_DIFF_CHARS (default 120000) - COMMIT_PER_FILE_CHANGE_LIMIT (default 2000) - COMMIT_MAX_MESSAGE_CHARS (default 4000) - COMMIT_DIFF_ENCODING , COMMIT_DIFF_ERRORS Usage tldr: # Arch: ensure uv is installed (pacman -S uv) and script is on PATH export OPENROUTER_API_KEY=sk-or-... git add -A git commit -m \"$(~/.scripts/bin/generate_commit_message.py)\" Git alias: git config --global alias.gcm '!~/.scripts/bin/generate_commit_message.py' git commit -m \"$(git gcm)\" Prepare-commit-msg hook: cat > .git/hooks/prepare-commit-msg <<'SH' #!/usr/bin/env bash case \"$2\" in merge|squash) exit 0;; esac msg=\"$(~/.scripts/bin/generate_commit_message.py)\" || exit 0 [ -n \"$msg\" ] && printf '%s\\n' \"$msg\" > \"$1\" SH chmod +x .git/hooks/prepare-commit-msg Tuning (optional): export COMMIT_MAX_DIFF_CHARS=80000 export COMMIT_PER_FILE_CHANGE_LIMIT=1200 export COMMIT_DIFF_ENCODING='utf-8' export COMMIT_DIFF_ERRORS='replace' export COMMIT_MAX_MESSAGE_CHARS=2000 Wayland clipboard (qtile): ~/.scripts/bin/generate_commit_message.py | wl-copy [!TIP] Improvements: accept CLI flags to override model , url , temperature, and limits; add provider selection (OpenAI, local LLM) via env/args; cache/timeout backoffs; optionally insert co-authors or conventional commit prefixes; unit tests for diff condensation and sanitization; support reading unstaged diff or specific paths; add a dry-run/verbose mode.","title":"AI-powered Git commit message generator"},{"location":"scripts/generate_commit_message.py/#ai-powered-git-commit-message-generator","text":"generate_commit_message.py : Generate commit messages from staged diff via OpenRouter; safe fallback","title":"AI-powered Git commit message generator"},{"location":"scripts/generate_commit_message.py/#dependencies","text":"uv \u2014 runs the script with inline deps; zero-setup via the shebang python>=3.12 \u2014 runtime for the script requests \u2014 HTTP client (auto-resolved by uv ) git \u2014 to read the staged diff OPENROUTER_API_KEY \u2014 API key in env; also accepts openrouter or any var containing OPENROUTER","title":"Dependencies"},{"location":"scripts/generate_commit_message.py/#description","text":"Generates a concise commit message from the staged diff and prints it to stdout. It captures the diff with git diff --cached --no-color --no-ext-diff -U0 , then aggressively condenses large patches to keep the prompt small, skipping noisy paths like node_modules, dist/build artifacts, lockfiles, and minified/map files. Encoding is robust: raw bytes are decoded with COMMIT_DIFF_ENCODING (default utf-8 ) and COMMIT_DIFF_ERRORS (default replace ) to avoid crashes on binary or non-UTF8 data. If an OpenRouter API key is present, it calls https://openrouter.ai/api/v1/chat/completions with openai/gpt-oss-120b to produce a subject (\u226470 chars) plus a short body. Output is sanitized to strictly contain a valid commit message. If the key is missing or the request fails, it falls back to a deterministic summary built from git diff --numstat . Config knobs (env): - COMMIT_MAX_DIFF_CHARS (default 120000) - COMMIT_PER_FILE_CHANGE_LIMIT (default 2000) - COMMIT_MAX_MESSAGE_CHARS (default 4000) - COMMIT_DIFF_ENCODING , COMMIT_DIFF_ERRORS","title":"Description"},{"location":"scripts/generate_commit_message.py/#usage","text":"tldr: # Arch: ensure uv is installed (pacman -S uv) and script is on PATH export OPENROUTER_API_KEY=sk-or-... git add -A git commit -m \"$(~/.scripts/bin/generate_commit_message.py)\" Git alias: git config --global alias.gcm '!~/.scripts/bin/generate_commit_message.py' git commit -m \"$(git gcm)\" Prepare-commit-msg hook: cat > .git/hooks/prepare-commit-msg <<'SH' #!/usr/bin/env bash case \"$2\" in merge|squash) exit 0;; esac msg=\"$(~/.scripts/bin/generate_commit_message.py)\" || exit 0 [ -n \"$msg\" ] && printf '%s\\n' \"$msg\" > \"$1\" SH chmod +x .git/hooks/prepare-commit-msg Tuning (optional): export COMMIT_MAX_DIFF_CHARS=80000 export COMMIT_PER_FILE_CHANGE_LIMIT=1200 export COMMIT_DIFF_ENCODING='utf-8' export COMMIT_DIFF_ERRORS='replace' export COMMIT_MAX_MESSAGE_CHARS=2000 Wayland clipboard (qtile): ~/.scripts/bin/generate_commit_message.py | wl-copy [!TIP] Improvements: accept CLI flags to override model , url , temperature, and limits; add provider selection (OpenAI, local LLM) via env/args; cache/timeout backoffs; optionally insert co-authors or conventional commit prefixes; unit tests for diff condensation and sanitization; support reading unstaged diff or specific paths; add a dry-run/verbose mode.","title":"Usage"},{"location":"scripts/get-window-thumbnails.sh/","text":"Get Window Thumbnails Script get-window-thumbnails.sh : Creates thumbnails of currently open windows on your qtile environment. Dependencies wmctrl : Utility for interacting with an EWMH/NetWM compatible X Window Manager. xwininfo : Provides information about windows on an X server. xdotool : Simulates keyboard input and manipulate windows. imagemagick ( import and mogrify tools): Used to capture screenshots and resize images respectively. Description This script captures the thumbnails of all currently open windows in a qtile environment. The script does the following: Setup the Output Directory: It creates a directory window_screenshots in the user's home directory to store the output images. Enumerate Windows: The script uses wmctrl to fetch a list of window IDs for all open windows. Processing Each Window: Fetches the window name using xwininfo . Uses xdotool to make the window visible on the screen. Delays to ensure the window is properly rendered. Utilizes imagemagick's import to capture the screenshot of the window. Uses xdotool to hide the window. Resizes the captured screenshot to a 200x200 pixels thumbnail using imagemagick's mogrify . Windows names are stripped down to alphanumeric, '.' and '_' characters to ensure valid filenames are created. The resulting thumbnails are stored in $HOME/window_screenshots . Usage To utilize this script, you can run it directly from a terminal. Ensure it has execute permission: chmod +x /home/matias/.scripts/dev/get-window-thumbnails.sh /home/matias/.scripts/dev/get-window-thumbnails.sh Once executed, the thumbnails will appear in your window_screenshots directory. This script is suitable to be run as a cron job or attached to a hotkey within qtile, depending on how frequently you need window thumbnails. [!TIP] Due to the use of xdotool for hiding and showing windows, the script may cause a slight flicker on the screen. Additionally, the script does not handle potential errors when import or mogrify fail, which could be improved with error checking. Lastly, adding an option to define the output directory or thumbnail size through command line arguments could make the script more flexible.","title":"Get Window Thumbnails Script"},{"location":"scripts/get-window-thumbnails.sh/#get-window-thumbnails-script","text":"get-window-thumbnails.sh : Creates thumbnails of currently open windows on your qtile environment.","title":"Get Window Thumbnails Script"},{"location":"scripts/get-window-thumbnails.sh/#dependencies","text":"wmctrl : Utility for interacting with an EWMH/NetWM compatible X Window Manager. xwininfo : Provides information about windows on an X server. xdotool : Simulates keyboard input and manipulate windows. imagemagick ( import and mogrify tools): Used to capture screenshots and resize images respectively.","title":"Dependencies"},{"location":"scripts/get-window-thumbnails.sh/#description","text":"This script captures the thumbnails of all currently open windows in a qtile environment. The script does the following: Setup the Output Directory: It creates a directory window_screenshots in the user's home directory to store the output images. Enumerate Windows: The script uses wmctrl to fetch a list of window IDs for all open windows. Processing Each Window: Fetches the window name using xwininfo . Uses xdotool to make the window visible on the screen. Delays to ensure the window is properly rendered. Utilizes imagemagick's import to capture the screenshot of the window. Uses xdotool to hide the window. Resizes the captured screenshot to a 200x200 pixels thumbnail using imagemagick's mogrify . Windows names are stripped down to alphanumeric, '.' and '_' characters to ensure valid filenames are created. The resulting thumbnails are stored in $HOME/window_screenshots .","title":"Description"},{"location":"scripts/get-window-thumbnails.sh/#usage","text":"To utilize this script, you can run it directly from a terminal. Ensure it has execute permission: chmod +x /home/matias/.scripts/dev/get-window-thumbnails.sh /home/matias/.scripts/dev/get-window-thumbnails.sh Once executed, the thumbnails will appear in your window_screenshots directory. This script is suitable to be run as a cron job or attached to a hotkey within qtile, depending on how frequently you need window thumbnails. [!TIP] Due to the use of xdotool for hiding and showing windows, the script may cause a slight flicker on the screen. Additionally, the script does not handle potential errors when import or mogrify fail, which could be improved with error checking. Lastly, adding an option to define the output directory or thumbnail size through command line arguments could make the script more flexible.","title":"Usage"},{"location":"scripts/get-windows.sh/","text":"qtile: Get Windows Script get-windows.sh : Outputs information about currently open windows in qtile (ID, group, name, wm_class) Dependencies qtile Used to query the current state of windows via the cmd-obj command. uv Runs the script using the uv Python runtime environment. bash Script is written for the Bash shell. Description This script retrieves a list of all windows managed by your current qtile session and prints out essential information for each window in a tab-separated format. Specifically, it uses the following workflow: Calls qtile's cmd-obj -o root -f windows to retrieve structured data about each window. Embeds this data into a Python snippet executed under uv run . Extracts and displays per-window: X11 window ID Associated group Window name (title) Window class ( wm_class ) The main script block manipulates the response from qtile, extracting only relevant fields into a simplified tabular output, which can be useful for debugging window/group assignments, scripting, external status bars, or custom workflows within your Arch/qtile environment. Usage You can run this script directly in a shell, or bind it to a key or invoke it from other scripts. For instance: ~/.scripts/dev/get-windows.sh Example output: 50331658 2 Alacritty alacritty 65011718 3 Fox Firefox ... Typical ways to use: Run interactively in a terminal to quickly inspect windows. Pipe output to other scripts or utilities for automation/parsing: ~/.scripts/dev/get-windows.sh | grep Alacritty Bind to a key in your qtile configuration to show window info on demand. [!TIP] There are a few aspects to consider for improvement: - The direct shell interpolation of $(qtile cmd-obj ...) into the Python win = ... statement is potentially brittle if the output is very large or contains characters that confuse bash or Python parsing (e.g. quotes). - It may be more robust to run the qtile command directly in Python using subprocess or through the qtile IPC API, especially for handling the structured outputs without Bash mediation. - The script assumes all dependencies are available in the environment; consider adding checks or error handling for missing utilities. - Consider adding a header row to the output for clarity, or making the output format configurable (e.g., CSV for further integrations). - To avoid uv run dependency if not strictly needed, a pure python executable would increase portability.","title":"qtile: Get Windows Script"},{"location":"scripts/get-windows.sh/#qtile-get-windows-script","text":"get-windows.sh : Outputs information about currently open windows in qtile (ID, group, name, wm_class)","title":"qtile: Get Windows Script"},{"location":"scripts/get-windows.sh/#dependencies","text":"qtile Used to query the current state of windows via the cmd-obj command. uv Runs the script using the uv Python runtime environment. bash Script is written for the Bash shell.","title":"Dependencies"},{"location":"scripts/get-windows.sh/#description","text":"This script retrieves a list of all windows managed by your current qtile session and prints out essential information for each window in a tab-separated format. Specifically, it uses the following workflow: Calls qtile's cmd-obj -o root -f windows to retrieve structured data about each window. Embeds this data into a Python snippet executed under uv run . Extracts and displays per-window: X11 window ID Associated group Window name (title) Window class ( wm_class ) The main script block manipulates the response from qtile, extracting only relevant fields into a simplified tabular output, which can be useful for debugging window/group assignments, scripting, external status bars, or custom workflows within your Arch/qtile environment.","title":"Description"},{"location":"scripts/get-windows.sh/#usage","text":"You can run this script directly in a shell, or bind it to a key or invoke it from other scripts. For instance: ~/.scripts/dev/get-windows.sh Example output: 50331658 2 Alacritty alacritty 65011718 3 Fox Firefox ...","title":"Usage"},{"location":"scripts/get-windows.sh/#typical-ways-to-use","text":"Run interactively in a terminal to quickly inspect windows. Pipe output to other scripts or utilities for automation/parsing: ~/.scripts/dev/get-windows.sh | grep Alacritty Bind to a key in your qtile configuration to show window info on demand. [!TIP] There are a few aspects to consider for improvement: - The direct shell interpolation of $(qtile cmd-obj ...) into the Python win = ... statement is potentially brittle if the output is very large or contains characters that confuse bash or Python parsing (e.g. quotes). - It may be more robust to run the qtile command directly in Python using subprocess or through the qtile IPC API, especially for handling the structured outputs without Bash mediation. - The script assumes all dependencies are available in the environment; consider adding checks or error handling for missing utilities. - Consider adding a header row to the output for clarity, or making the output format configurable (e.g., CSV for further integrations). - To avoid uv run dependency if not strictly needed, a pure python executable would increase portability.","title":"Typical ways to use:"},{"location":"scripts/get_hyperlinks_in_folder.py/","text":"Visualize Markdown Note Hyperlinks in a Folder get_hyperlinks_in_folder.py : Scans a folder of markdown notes and builds a hyperlink graph visualization. Dependencies python (with modules: click , matplotlib , networkx , tqdm ) fd : Fast alternative to find for listing markdown files. rg (ripgrep): Recursively searches markdown links in notes. jq : Processes line-oriented json from ripgrep output. bash (subprocesses) All dependencies should be installed and available in PATH . On Arch Linux, install with pacman or pip as appropriate. Description This script parses a directory for markdown ( .md ) notes and analyzes all internal wiki-style links ( [[note name]] or [[note name|alias]] ). The information is compiled into a directed graph representing hyperlinks between notes. Optionally, the script can visualize the network using matplotlib (via networkx ). Script Workflow Path Resolution: Expands variables/tilde and validates the provided note folder. Markdown File Listing: Uses fd to quickly list all markdown files in the search path. Reference Extraction: Uses ripgrep ( rg ) to find wiki-style links in notes. Pipes results into jq to parse out file/link targets efficiently. Graph Construction: Maps files and their outbound links to a directed graph. Each node is a note; each edge is a hyperlink. Visualization: Optionally plots the graph using matplotlib . Usage Tip: Run interactively via terminal, or bind to a qtile key/chord for faster access. Scan a note folder and print progress: get_hyperlinks_in_folder.py --path \"/path/to/notes\" Scan current directory (default) and visualize hyperlink graph: get_hyperlinks_in_folder.py --draw Common workflow example: cd ~/zettelkasten get_hyperlinks_in_folder.py --draw No output? Ensure you have markdown files and wiki-links in your folder! [!NOTE] - The script assumes your note links conform to [[...]] (Obsidian style). - Error handling could be improved, e.g., if subprocesses fail or output unexpected formats. - The node IDs are mapped by filename order, which means graph node numbers may not always correspond to the same note if files are added/removed. - The script opens a matplotlib window, which may block execution if run inside qtile keybindings without matplotlib set to use a non-interactive backend. - Consider adding file labels or note titles as node labels for more meaningful visualization. - Strongly dependent on GNU/Linux CLI ecosystem; will not work natively on Windows.","title":"Visualize Markdown Note Hyperlinks in a Folder"},{"location":"scripts/get_hyperlinks_in_folder.py/#visualize-markdown-note-hyperlinks-in-a-folder","text":"get_hyperlinks_in_folder.py : Scans a folder of markdown notes and builds a hyperlink graph visualization.","title":"Visualize Markdown Note Hyperlinks in a Folder"},{"location":"scripts/get_hyperlinks_in_folder.py/#dependencies","text":"python (with modules: click , matplotlib , networkx , tqdm ) fd : Fast alternative to find for listing markdown files. rg (ripgrep): Recursively searches markdown links in notes. jq : Processes line-oriented json from ripgrep output. bash (subprocesses) All dependencies should be installed and available in PATH . On Arch Linux, install with pacman or pip as appropriate.","title":"Dependencies"},{"location":"scripts/get_hyperlinks_in_folder.py/#description","text":"This script parses a directory for markdown ( .md ) notes and analyzes all internal wiki-style links ( [[note name]] or [[note name|alias]] ). The information is compiled into a directed graph representing hyperlinks between notes. Optionally, the script can visualize the network using matplotlib (via networkx ).","title":"Description"},{"location":"scripts/get_hyperlinks_in_folder.py/#script-workflow","text":"Path Resolution: Expands variables/tilde and validates the provided note folder. Markdown File Listing: Uses fd to quickly list all markdown files in the search path. Reference Extraction: Uses ripgrep ( rg ) to find wiki-style links in notes. Pipes results into jq to parse out file/link targets efficiently. Graph Construction: Maps files and their outbound links to a directed graph. Each node is a note; each edge is a hyperlink. Visualization: Optionally plots the graph using matplotlib .","title":"Script Workflow"},{"location":"scripts/get_hyperlinks_in_folder.py/#usage","text":"Tip: Run interactively via terminal, or bind to a qtile key/chord for faster access. Scan a note folder and print progress: get_hyperlinks_in_folder.py --path \"/path/to/notes\" Scan current directory (default) and visualize hyperlink graph: get_hyperlinks_in_folder.py --draw Common workflow example: cd ~/zettelkasten get_hyperlinks_in_folder.py --draw No output? Ensure you have markdown files and wiki-links in your folder! [!NOTE] - The script assumes your note links conform to [[...]] (Obsidian style). - Error handling could be improved, e.g., if subprocesses fail or output unexpected formats. - The node IDs are mapped by filename order, which means graph node numbers may not always correspond to the same note if files are added/removed. - The script opens a matplotlib window, which may block execution if run inside qtile keybindings without matplotlib set to use a non-interactive backend. - Consider adding file labels or note titles as node labels for more meaningful visualization. - Strongly dependent on GNU/Linux CLI ecosystem; will not work natively on Windows.","title":"Usage"},{"location":"scripts/get_repos_present_on_host.sh/","text":"get_repos_present_on_host.sh get_repos_present_on_host.sh : List and register two-level git repos present under $GIT_REPOS for this host. Dependencies bash : Required to run the script. find : Used to recursively locate .git folders. sed , awk , sort , cat , mkdir : Standard GNU core utilities for stream editing, text processing, sorting, file concatenation, and directory management. Environment variables (required): $GIT_REPOS : Root path where git repositories are stored. $LOCALDATA : Root data directory where results are written. Description This script catalogs git repositories under a set location on your Arch Linux system. It determines all repositories present under the $GIT_REPOS directory which are exactly two directory levels deep ( org/repo/.git ), formats their paths, and records them in a host-specific file as well as a central index of all repositories. Main Steps: - Checks for the existence of the required environment variables. - Dynamically builds output paths, segregated per host using the output of hostnamectl hostname . - Uses find to gather all .git directories under $GIT_REPOS , sed to convert them to org/repo format, and awk to filter for two-level deep results only. - Writes results to a host-specific file, deduplicates it, and appends/sorts into an all-repos.txt containing all discovered repositories across hosts. - Ensures output directories exist before use. Utility: Ideal for syncing or auditing repositories per-machine, especially useful for dotfile management, multi-host setups, or scripting hooks within your qtile environment. Usage Before running, you must ensure the two environment variables are set: export GIT_REPOS=\"$HOME/repos\" export LOCALDATA=\"$HOME/.local/share\" To run interactively or in scripts: ~/.scripts/bin/get_repos_present_on_host.sh Typical output files: - $LOCALDATA/docs/git_repos/$(hostname)-repos.txt : Repos for this host. - $LOCALDATA/docs/git_repos/all-repos.txt : Master list of all repos. Examples # Standard execution GIT_REPOS=~/repos LOCALDATA=~/.local/share ~/.scripts/bin/get_repos_present_on_host.sh # Manually set and run in one line GIT_REPOS=/mnt/store/git LOCALDATA=/data ~/.scripts/bin/get_repos_present_on_host.sh [!NOTE] - Only repositories at two directory levels (like org/repo/.git ) are counted; deeper or shallower structures are ignored. - The script appends to all-repos.txt before deduplication, so historical order is not strictly preserved. - There is no check for writable permissions; if the script fails, ensure both directories specified by $LOCALDATA exist and are writable. - If run frequently on large directory trees, consider limiting depth in the find call for performance, or moving deduplication outside append loop for efficiency. - Hostname extraction assumes nothing unusual about your hostname (no special chars, embedded slashes, etc).","title":"get_repos_present_on_host.sh"},{"location":"scripts/get_repos_present_on_host.sh/#get_repos_present_on_hostsh","text":"get_repos_present_on_host.sh : List and register two-level git repos present under $GIT_REPOS for this host.","title":"get_repos_present_on_host.sh"},{"location":"scripts/get_repos_present_on_host.sh/#dependencies","text":"bash : Required to run the script. find : Used to recursively locate .git folders. sed , awk , sort , cat , mkdir : Standard GNU core utilities for stream editing, text processing, sorting, file concatenation, and directory management. Environment variables (required): $GIT_REPOS : Root path where git repositories are stored. $LOCALDATA : Root data directory where results are written.","title":"Dependencies"},{"location":"scripts/get_repos_present_on_host.sh/#description","text":"This script catalogs git repositories under a set location on your Arch Linux system. It determines all repositories present under the $GIT_REPOS directory which are exactly two directory levels deep ( org/repo/.git ), formats their paths, and records them in a host-specific file as well as a central index of all repositories. Main Steps: - Checks for the existence of the required environment variables. - Dynamically builds output paths, segregated per host using the output of hostnamectl hostname . - Uses find to gather all .git directories under $GIT_REPOS , sed to convert them to org/repo format, and awk to filter for two-level deep results only. - Writes results to a host-specific file, deduplicates it, and appends/sorts into an all-repos.txt containing all discovered repositories across hosts. - Ensures output directories exist before use. Utility: Ideal for syncing or auditing repositories per-machine, especially useful for dotfile management, multi-host setups, or scripting hooks within your qtile environment.","title":"Description"},{"location":"scripts/get_repos_present_on_host.sh/#usage","text":"Before running, you must ensure the two environment variables are set: export GIT_REPOS=\"$HOME/repos\" export LOCALDATA=\"$HOME/.local/share\" To run interactively or in scripts: ~/.scripts/bin/get_repos_present_on_host.sh Typical output files: - $LOCALDATA/docs/git_repos/$(hostname)-repos.txt : Repos for this host. - $LOCALDATA/docs/git_repos/all-repos.txt : Master list of all repos. Examples # Standard execution GIT_REPOS=~/repos LOCALDATA=~/.local/share ~/.scripts/bin/get_repos_present_on_host.sh # Manually set and run in one line GIT_REPOS=/mnt/store/git LOCALDATA=/data ~/.scripts/bin/get_repos_present_on_host.sh [!NOTE] - Only repositories at two directory levels (like org/repo/.git ) are counted; deeper or shallower structures are ignored. - The script appends to all-repos.txt before deduplication, so historical order is not strictly preserved. - There is no check for writable permissions; if the script fails, ensure both directories specified by $LOCALDATA exist and are writable. - If run frequently on large directory trees, consider limiting depth in the find call for performance, or moving deduplication outside append loop for efficiency. - Hostname extraction assumes nothing unusual about your hostname (no special chars, embedded slashes, etc).","title":"Usage"},{"location":"scripts/get_scripts_relations.py/","text":"Script Relations Visualizer get_scripts_relations.py : Scans user scripts to detect and visualize script dependencies. Dependencies python (Python 3.x) matplotlib ( matplotlib Python module; used for graph plotting) networkx ( networkx Python module; used for network analysis and visualization) fd (Rust-based alternative to find ; used for fast file discovery) rg ( ripgrep ; used for quickly searching file content) SCRIPTS environment variable (optional; defines base scripts directory\u2014defaults to current dir) Description This script analyzes script files (presumed to be in your ${SCRIPTS} directory or current working directory if the variable is unset) to determine relationships based on inclusion or call patterns inferred via filename matching. Dependencies between scripts are mapped using the following steps: File Discovery: Lists all executable files using fd . Dependency Mapping: For each script, uses ripgrep ( rg ) to find references (by filename) in other scripts, implying a dependency or inclusion. Network Construction: Builds a directed dependency graph using networkx . Visualization: Visualizes the graph using matplotlib with nodes as scripts and directed edges as dependencies. Export: Saves the dependency network in GraphGML format at /tmp/get_scripts_relations.gml for use with Cytoscape or other tools. The script is particularly useful for understanding and maintaining a growing collection of user scripts, especially in complex or organically grown Arch setups. Usage This script is intended to be run from a terminal and is most useful when pointed at your scripts repository: # Ensure dependencies are installed pip install matplotlib networkx sudo pacman -S fd ripgrep # Option 1: Run using the SCRIPTS env variable export SCRIPTS=\"$HOME/.scripts/bin\" python /home/matias/.scripts/bin/get_scripts_relations.py # Option 2: Run with current directory as script base cd ~/.scripts/bin python get_scripts_relations.py Once run, a matplotlib window will appear visualizing the dependencies. The graph is also exported as /tmp/get_scripts_relations.gml . [!TIP] Potential Improvements & Considerations - Accuracy: The script assumes any mention of a script filename in another script is a dependency, which may produce false positives or miss script-sourced dependencies (e.g., variable usage or indirect calls). - Scalability: With a large number of scripts or large scripts, visualization could become cluttered and slow; consider filtering or grouping in the analysis. - Customization: Hardcodes export location ( /tmp/get_scripts_relations.gml )\u2014making this configurable would improve usability. - Cross-Platform Note: Designed for UNIX-like environments; will not work natively on Windows. - Visualization: Consider using Cytoscape for larger graphs, as matplotlib-based layouts can become unreadable for bigger script collections. - Refinement: If scripts reference others with relative paths or sourced includes ( . filename ), these may not be detected; further static analysis or parsing might yield more precise results.","title":"Script Relations Visualizer"},{"location":"scripts/get_scripts_relations.py/#script-relations-visualizer","text":"get_scripts_relations.py : Scans user scripts to detect and visualize script dependencies.","title":"Script Relations Visualizer"},{"location":"scripts/get_scripts_relations.py/#dependencies","text":"python (Python 3.x) matplotlib ( matplotlib Python module; used for graph plotting) networkx ( networkx Python module; used for network analysis and visualization) fd (Rust-based alternative to find ; used for fast file discovery) rg ( ripgrep ; used for quickly searching file content) SCRIPTS environment variable (optional; defines base scripts directory\u2014defaults to current dir)","title":"Dependencies"},{"location":"scripts/get_scripts_relations.py/#description","text":"This script analyzes script files (presumed to be in your ${SCRIPTS} directory or current working directory if the variable is unset) to determine relationships based on inclusion or call patterns inferred via filename matching. Dependencies between scripts are mapped using the following steps: File Discovery: Lists all executable files using fd . Dependency Mapping: For each script, uses ripgrep ( rg ) to find references (by filename) in other scripts, implying a dependency or inclusion. Network Construction: Builds a directed dependency graph using networkx . Visualization: Visualizes the graph using matplotlib with nodes as scripts and directed edges as dependencies. Export: Saves the dependency network in GraphGML format at /tmp/get_scripts_relations.gml for use with Cytoscape or other tools. The script is particularly useful for understanding and maintaining a growing collection of user scripts, especially in complex or organically grown Arch setups.","title":"Description"},{"location":"scripts/get_scripts_relations.py/#usage","text":"This script is intended to be run from a terminal and is most useful when pointed at your scripts repository: # Ensure dependencies are installed pip install matplotlib networkx sudo pacman -S fd ripgrep # Option 1: Run using the SCRIPTS env variable export SCRIPTS=\"$HOME/.scripts/bin\" python /home/matias/.scripts/bin/get_scripts_relations.py # Option 2: Run with current directory as script base cd ~/.scripts/bin python get_scripts_relations.py Once run, a matplotlib window will appear visualizing the dependencies. The graph is also exported as /tmp/get_scripts_relations.gml . [!TIP] Potential Improvements & Considerations - Accuracy: The script assumes any mention of a script filename in another script is a dependency, which may produce false positives or miss script-sourced dependencies (e.g., variable usage or indirect calls). - Scalability: With a large number of scripts or large scripts, visualization could become cluttered and slow; consider filtering or grouping in the analysis. - Customization: Hardcodes export location ( /tmp/get_scripts_relations.gml )\u2014making this configurable would improve usability. - Cross-Platform Note: Designed for UNIX-like environments; will not work natively on Windows. - Visualization: Consider using Cytoscape for larger graphs, as matplotlib-based layouts can become unreadable for bigger script collections. - Refinement: If scripts reference others with relative paths or sourced includes ( . filename ), these may not be detected; further static analysis or parsing might yield more precise results.","title":"Usage"},{"location":"scripts/get_scripts_relations.xsh/","text":"Script Relations Visualizer get_scripts_relations.xsh : Scans $SCRIPTS directory for scripts and visualizes intra-folder dependencies as a directed graph Dependencies xonsh : Shell to run .xsh scripts, blends Python and shell fd : Fast alternative to find , used for listing scripts in $SCRIPTS basename : CLI utility to get the filename, used to simplify paths rg (ripgrep): Fast text searching tool to find dependencies/uses python (with modules: json , networkx , matplotlib ): For graph generation and visualization Python packages: - networkx : For graph representation - matplotlib : For plotting the graph Description This script collects the relations between scripts inside your $SCRIPTS directory by: - Listing all scripts in $SCRIPTS (using fd ) - For each script, searching for references to its basename within the script directory (using rg ) - Building a dictionary mapping each script to those in which it appears to be referenced - Using Python (via xonsh) to construct a directed graph (with NetworkX) that shows which scripts depend on which others - Rendering and displaying a dependency graph via matplotlib Key variables/functions: - dic : Dictionary mapping script basenames to lists of scripts importing/calling them - networkx : Handles the construction of the dependency graph (nodes = scripts, edges = dependency links) - matplotlib : Visualizes the dependency network as a directed graph Note: Only scripts whose names are referenced (by basename match) are considered as dependencies. Usage Typically, set your $SCRIPTS to the directory you want to analyze: $SCRIPTS = ~/scripts/ ./get_scripts_relations.xsh Quick Example export SCRIPTS=~/scripts xonsh /home/matias/.scripts/dev/get_scripts_relations.xsh Run this either in a terminal or bind the command to a key in Qtile to quickly visualize your scripts' interconnections. The script opens a Matplotlib window with an interactive plot of the relations (no files are written). [!TIP] The script's dependency detection is based purely on a basename match, so it may generate false positives/negatives if script names are generic or commonly referenced in other contexts. There's no exclusion for comments or string matches, so the presence of a script name anywhere in a file is treated as a dependency. Consider outputting the graph to a file for integration into documentation or scripts! Error handling is minimal \u2014 missing dependencies or unset $SCRIPTS will cause the script to fail. For large script directories, the graph layout may be cluttered. Adding options for filtering or subgraphing could help.","title":"Script Relations Visualizer"},{"location":"scripts/get_scripts_relations.xsh/#script-relations-visualizer","text":"get_scripts_relations.xsh : Scans $SCRIPTS directory for scripts and visualizes intra-folder dependencies as a directed graph","title":"Script Relations Visualizer"},{"location":"scripts/get_scripts_relations.xsh/#dependencies","text":"xonsh : Shell to run .xsh scripts, blends Python and shell fd : Fast alternative to find , used for listing scripts in $SCRIPTS basename : CLI utility to get the filename, used to simplify paths rg (ripgrep): Fast text searching tool to find dependencies/uses python (with modules: json , networkx , matplotlib ): For graph generation and visualization Python packages: - networkx : For graph representation - matplotlib : For plotting the graph","title":"Dependencies"},{"location":"scripts/get_scripts_relations.xsh/#description","text":"This script collects the relations between scripts inside your $SCRIPTS directory by: - Listing all scripts in $SCRIPTS (using fd ) - For each script, searching for references to its basename within the script directory (using rg ) - Building a dictionary mapping each script to those in which it appears to be referenced - Using Python (via xonsh) to construct a directed graph (with NetworkX) that shows which scripts depend on which others - Rendering and displaying a dependency graph via matplotlib Key variables/functions: - dic : Dictionary mapping script basenames to lists of scripts importing/calling them - networkx : Handles the construction of the dependency graph (nodes = scripts, edges = dependency links) - matplotlib : Visualizes the dependency network as a directed graph Note: Only scripts whose names are referenced (by basename match) are considered as dependencies.","title":"Description"},{"location":"scripts/get_scripts_relations.xsh/#usage","text":"Typically, set your $SCRIPTS to the directory you want to analyze: $SCRIPTS = ~/scripts/ ./get_scripts_relations.xsh","title":"Usage"},{"location":"scripts/get_scripts_relations.xsh/#quick-example","text":"export SCRIPTS=~/scripts xonsh /home/matias/.scripts/dev/get_scripts_relations.xsh Run this either in a terminal or bind the command to a key in Qtile to quickly visualize your scripts' interconnections. The script opens a Matplotlib window with an interactive plot of the relations (no files are written). [!TIP] The script's dependency detection is based purely on a basename match, so it may generate false positives/negatives if script names are generic or commonly referenced in other contexts. There's no exclusion for comments or string matches, so the presence of a script name anywhere in a file is treated as a dependency. Consider outputting the graph to a file for integration into documentation or scripts! Error handling is minimal \u2014 missing dependencies or unset $SCRIPTS will cause the script to fail. For large script directories, the graph layout may be cluttered. Adding options for filtering or subgraphing could help.","title":"Quick Example"},{"location":"scripts/git_cd.sh/","text":"Git Project Directory Quick CD git_cd.sh : Quickly cd to any git project directory found on the system using a fuzzy search. Dependencies locate : Fast file name database query sed : Stream editor for filtering and transforming text eza : Modern replacement for ls , used here for directory listing with icons/colors fzf : Command-line fuzzy finder for interactive selection awk : Text processing utility for field extraction bash : The GNU Bash shell (shebang line) All dependencies are available or can easily be installed via pacman or paru on Arch Linux. Description This script provides an efficient way to jump to any git repository on your system, turning hours spent navigating into seconds. It performs the following steps: Uses locate to find all .git directories indexed on your filesystem. Processes the paths, stripping the trailing .git , and lists the parent directories with eza for an appealing view (color/icons). Replaces your home directory ( /home/matias ) with ~ for better clarity. Passes the results to fzf for fuzzy selection, allowing you to interactively choose your desired project. Uses awk to extract the directory path. Converts ~ back to your full home path and outputs the selected directory, before attempting to switch ( cd ) to it. It's perfect for scripting usage, keybinding (in qtile or your terminal), or ad-hoc project switches. Usage The script is designed for interactive terminal use. The recommended workflow is: bash ~/.scripts/bin/git_cd.sh Example tldr: Open a terminal. Run: sh ~/.scripts/bin/git_cd.sh Begin typing the name of the desired project in the fuzzy finder popup. Hit <Enter> to select. The full directory path is echoed, then the script attempts to cd into it. Pro tip: To use this as a keybinding from qtile or as a shell command, you may want to modify the script so the directory change persists in your terminal\u2014see the Critique section. [!NOTE] - Subshell Limitation: Because this script runs as a child process (subshell), the cd command will not persist after the script exits; in other words, it changes directory only inside the script, not your terminal session. To make persistent directory changes, consider modifying the script to output only the selected path and then use cd \"$(bash git_cd.sh)\" or turn it into a shell function/alias. - Hardcoded Home: The script is hardcoded for /home/matias . For portability, consider using $HOME instead. - locate Database Update: If new repos are added and not appearing, remember to periodically update the locate database with updatedb . - awk '{print $2}' assumes eza output is consistent; this could break if eza output format changes. Consider output parsing with more robust field handling.","title":"Git Project Directory Quick CD"},{"location":"scripts/git_cd.sh/#git-project-directory-quick-cd","text":"git_cd.sh : Quickly cd to any git project directory found on the system using a fuzzy search.","title":"Git Project Directory Quick CD"},{"location":"scripts/git_cd.sh/#dependencies","text":"locate : Fast file name database query sed : Stream editor for filtering and transforming text eza : Modern replacement for ls , used here for directory listing with icons/colors fzf : Command-line fuzzy finder for interactive selection awk : Text processing utility for field extraction bash : The GNU Bash shell (shebang line) All dependencies are available or can easily be installed via pacman or paru on Arch Linux.","title":"Dependencies"},{"location":"scripts/git_cd.sh/#description","text":"This script provides an efficient way to jump to any git repository on your system, turning hours spent navigating into seconds. It performs the following steps: Uses locate to find all .git directories indexed on your filesystem. Processes the paths, stripping the trailing .git , and lists the parent directories with eza for an appealing view (color/icons). Replaces your home directory ( /home/matias ) with ~ for better clarity. Passes the results to fzf for fuzzy selection, allowing you to interactively choose your desired project. Uses awk to extract the directory path. Converts ~ back to your full home path and outputs the selected directory, before attempting to switch ( cd ) to it. It's perfect for scripting usage, keybinding (in qtile or your terminal), or ad-hoc project switches.","title":"Description"},{"location":"scripts/git_cd.sh/#usage","text":"The script is designed for interactive terminal use. The recommended workflow is: bash ~/.scripts/bin/git_cd.sh Example tldr: Open a terminal. Run: sh ~/.scripts/bin/git_cd.sh Begin typing the name of the desired project in the fuzzy finder popup. Hit <Enter> to select. The full directory path is echoed, then the script attempts to cd into it. Pro tip: To use this as a keybinding from qtile or as a shell command, you may want to modify the script so the directory change persists in your terminal\u2014see the Critique section. [!NOTE] - Subshell Limitation: Because this script runs as a child process (subshell), the cd command will not persist after the script exits; in other words, it changes directory only inside the script, not your terminal session. To make persistent directory changes, consider modifying the script to output only the selected path and then use cd \"$(bash git_cd.sh)\" or turn it into a shell function/alias. - Hardcoded Home: The script is hardcoded for /home/matias . For portability, consider using $HOME instead. - locate Database Update: If new repos are added and not appearing, remember to periodically update the locate database with updatedb . - awk '{print $2}' assumes eza output is consistent; this could break if eza output format changes. Consider output parsing with more robust field handling.","title":"Usage"},{"location":"scripts/git_clone_by_author-repo.sh/","text":"GitHub Clone by author/repo Script git_clone_by_author-repo.sh : Clone a GitHub repository via SSH, HTTPS, or from a local path with developer-oriented subfolder convention. Dependencies git \u2014 Required for cloning repositories. Bash (standard on Arch Linux) [Environment variable] GIT_REPOS \u2014 (Optional) To set the base directory for cloned repositories. Defaults to $HOME/git . Description This script simplifies cloning GitHub repositories based on the familiar developer/package notation, with support for: Cloning via HTTPS (default): Standard GitHub HTTPS URL. Cloning via SSH: If you pass -s or --ssh , it uses the SSH protocol (e.g., git@github.com:author/package.git ). Cloning from a local repository: With -l <path> , it clones from a provided local path. Features: - All repos are placed in the target dir $GIT_REPOS/author/package . - Automatically creates the developer ( author ) directory if it doesn't exist. - Defensive argument parsing: mutually exclusive options for SSH/local, validation of required arguments. - Designed for interactive CLI use, but easily mapped to a keybinding or qtile command. Usage Clone a repo from GitHub via HTTPS (default): $ ~/git_clone_by_author-repo.sh matias/myproject Clones into: $GIT_REPOS/matias/myproject Clone using SSH: $ ~/git_clone_by_author-repo.sh -s matias/myproject or $ ~/git_clone_by_author-repo.sh --ssh matias/myproject Clones from git@github.com:matias/myproject.git . Clone from a local repo: $ ~/git_clone_by_author-repo.sh -l /some/path/to/repo matias/myproject or $ ~/git_clone_by_author-repo.sh --local /some/path/to/repo matias/myproject Clones from /some/path/to/repo into the appropriately named folder. Set custom base directory (optional): $ export GIT_REPOS=~/Projects $ ~/git_clone_by_author-repo.sh matias/myproject [!TIP] - The script is robust and well-organized for its purpose, but a few usability improvements are possible: - Currently, the script doesn\u2019t validate if the input is correctly in the author/repo format (no error if e.g. only one element is given). - Error handling in case the git clone command fails is absent; consider checking the exit code for a better user experience. - Consider supporting custom hosting (e.g., GitLab) via additional flags or config in the future. - The usage message could be a bit clearer about argument requirements for -l . - Flag handling would benefit from using standard tools such as getopts for more scalable option parsing.","title":"GitHub Clone by author/repo Script"},{"location":"scripts/git_clone_by_author-repo.sh/#github-clone-by-authorrepo-script","text":"git_clone_by_author-repo.sh : Clone a GitHub repository via SSH, HTTPS, or from a local path with developer-oriented subfolder convention.","title":"GitHub Clone by author/repo Script"},{"location":"scripts/git_clone_by_author-repo.sh/#dependencies","text":"git \u2014 Required for cloning repositories. Bash (standard on Arch Linux) [Environment variable] GIT_REPOS \u2014 (Optional) To set the base directory for cloned repositories. Defaults to $HOME/git .","title":"Dependencies"},{"location":"scripts/git_clone_by_author-repo.sh/#description","text":"This script simplifies cloning GitHub repositories based on the familiar developer/package notation, with support for: Cloning via HTTPS (default): Standard GitHub HTTPS URL. Cloning via SSH: If you pass -s or --ssh , it uses the SSH protocol (e.g., git@github.com:author/package.git ). Cloning from a local repository: With -l <path> , it clones from a provided local path. Features: - All repos are placed in the target dir $GIT_REPOS/author/package . - Automatically creates the developer ( author ) directory if it doesn't exist. - Defensive argument parsing: mutually exclusive options for SSH/local, validation of required arguments. - Designed for interactive CLI use, but easily mapped to a keybinding or qtile command.","title":"Description"},{"location":"scripts/git_clone_by_author-repo.sh/#usage","text":"Clone a repo from GitHub via HTTPS (default): $ ~/git_clone_by_author-repo.sh matias/myproject Clones into: $GIT_REPOS/matias/myproject Clone using SSH: $ ~/git_clone_by_author-repo.sh -s matias/myproject or $ ~/git_clone_by_author-repo.sh --ssh matias/myproject Clones from git@github.com:matias/myproject.git . Clone from a local repo: $ ~/git_clone_by_author-repo.sh -l /some/path/to/repo matias/myproject or $ ~/git_clone_by_author-repo.sh --local /some/path/to/repo matias/myproject Clones from /some/path/to/repo into the appropriately named folder. Set custom base directory (optional): $ export GIT_REPOS=~/Projects $ ~/git_clone_by_author-repo.sh matias/myproject [!TIP] - The script is robust and well-organized for its purpose, but a few usability improvements are possible: - Currently, the script doesn\u2019t validate if the input is correctly in the author/repo format (no error if e.g. only one element is given). - Error handling in case the git clone command fails is absent; consider checking the exit code for a better user experience. - Consider supporting custom hosting (e.g., GitLab) via additional flags or config in the future. - The usage message could be a bit clearer about argument requirements for -l . - Flag handling would benefit from using standard tools such as getopts for more scalable option parsing.","title":"Usage"},{"location":"scripts/git_update_all_other_repos.sh/","text":"Git: Update All Other Repos git_update_all_other_repos.sh : Batch-pulls all git repositories (with HTTPS remote) at exact depth 3 under $GIT_REPOS Dependencies fd : Fast alternative to find; used here for directory searching at specific depth. git : Distributed version control; required for repo operations. ripgrep ( rg ): Fast search tool; used to filter remote URLs. bat : Cat clone with syntax highlighting. sed : Stream editor, for formatting repository info. Environment Variable: GIT_REPOS The root path where your repositories are located. Must be set before running the script. Description This script scans a directory tree (set via the environment variable $GIT_REPOS ) at an exact depth of 3 for .git directories, identifying all potential git repositories at that level. For each repo found: It checks if the repo has a \"fetch\" remote configured with an HTTPS URL. If so, it prints formatted info about the repo using sed and pretty-prints it with bat using TOML highlighting. Then, it attempts to do a git pull for that repo. If the pull fails, an error message is displayed in highlighted color. This setup is ideal for batch-updating multiple project repositories arranged neatly under a common directory hierarchy, e.g. $GIT_REPOS/org/project/.git . Usage 1. Set the $GIT_REPOS environment variable to your main git repositories folder: export GIT_REPOS=\"$HOME/projects\" 2. Run the script: ~/.scripts/bin/git_update_all_other_repos.sh Can be run interactively in a terminal. The script prints each repo before pulling, highlighting line 2 for visibility. Only repositories with HTTPS remotes under the specified directory are touched. Suitable to assign to a keybinding from within qtile, or execute on demand. Example Run Output [my-repo] #org/my-repo remote: Enumerating objects: 5, done. remote: Counting objects: 100%... ... [!TIP] - The script expects your repositories to all reside at exactly depth 3 under $GIT_REPOS (e.g., $GIT_REPOS/org/project/.git ). If your layout differs, you may need to adjust the --exact-depth parameter. - The search is limited to HTTPS remotes; SSH remotes are excluded. You may want to support both in some cases. - The invocation of bat for highlighting is a nice touch, but using --highlight-line 2 may not always have the intended effect if the output of sed varies. - Failed pulls are shown with a red-background message, but you might want to log errors to a file for later review. - If any dependency is missing (such as fd , bat , or ripgrep ), the script will fail\u2014consider adding a check or a short dependency note at runtime.","title":"Git: Update All Other Repos"},{"location":"scripts/git_update_all_other_repos.sh/#git-update-all-other-repos","text":"git_update_all_other_repos.sh : Batch-pulls all git repositories (with HTTPS remote) at exact depth 3 under $GIT_REPOS","title":"Git: Update All Other Repos"},{"location":"scripts/git_update_all_other_repos.sh/#dependencies","text":"fd : Fast alternative to find; used here for directory searching at specific depth. git : Distributed version control; required for repo operations. ripgrep ( rg ): Fast search tool; used to filter remote URLs. bat : Cat clone with syntax highlighting. sed : Stream editor, for formatting repository info. Environment Variable: GIT_REPOS The root path where your repositories are located. Must be set before running the script.","title":"Dependencies"},{"location":"scripts/git_update_all_other_repos.sh/#description","text":"This script scans a directory tree (set via the environment variable $GIT_REPOS ) at an exact depth of 3 for .git directories, identifying all potential git repositories at that level. For each repo found: It checks if the repo has a \"fetch\" remote configured with an HTTPS URL. If so, it prints formatted info about the repo using sed and pretty-prints it with bat using TOML highlighting. Then, it attempts to do a git pull for that repo. If the pull fails, an error message is displayed in highlighted color. This setup is ideal for batch-updating multiple project repositories arranged neatly under a common directory hierarchy, e.g. $GIT_REPOS/org/project/.git .","title":"Description"},{"location":"scripts/git_update_all_other_repos.sh/#usage","text":"1. Set the $GIT_REPOS environment variable to your main git repositories folder: export GIT_REPOS=\"$HOME/projects\" 2. Run the script: ~/.scripts/bin/git_update_all_other_repos.sh Can be run interactively in a terminal. The script prints each repo before pulling, highlighting line 2 for visibility. Only repositories with HTTPS remotes under the specified directory are touched. Suitable to assign to a keybinding from within qtile, or execute on demand.","title":"Usage"},{"location":"scripts/git_update_all_other_repos.sh/#example-run-output","text":"[my-repo] #org/my-repo remote: Enumerating objects: 5, done. remote: Counting objects: 100%... ... [!TIP] - The script expects your repositories to all reside at exactly depth 3 under $GIT_REPOS (e.g., $GIT_REPOS/org/project/.git ). If your layout differs, you may need to adjust the --exact-depth parameter. - The search is limited to HTTPS remotes; SSH remotes are excluded. You may want to support both in some cases. - The invocation of bat for highlighting is a nice touch, but using --highlight-line 2 may not always have the intended effect if the output of sed varies. - Failed pulls are shown with a red-background message, but you might want to log errors to a file for later review. - If any dependency is missing (such as fd , bat , or ripgrep ), the script will fail\u2014consider adding a check or a short dependency note at runtime.","title":"Example Run Output"},{"location":"scripts/grub-tune-to-audio-python.py/","text":"Convert GRUB Tune to Audio (Python) grub-tune-to-audio-python.py : Converts a GRUB_INIT_TUNE string into an MP3 audio file Dependencies python (3.x): Interpreter for running the script pydub : Python library for audio manipulation and synthesis ( pip install pydub ) ffmpeg or libav : Required backend for pydub to handle MP3 export (install via pacman -S ffmpeg on Arch Linux) Description This script translates a GRUB/GRUB2-style GRUB_INIT_TUNE string into an audio file. GRUB allows specifying a boot-time tune using the format: TEMPO [FREQ1 DURATION1 FREQ2 DURATION2 ...] Where: - TEMPO is measured in beats per minute (BPM) - FREQ is the frequency of the note in Hz - DURATION is the relative length of the note, in beats The script parses this string, individually generates each tone using the frequency and duration specified, and concatenates them to form the full sequence. The final result is saved as output.mp3 in the current directory. Core Functions grub_tune_to_audio(tune_string) : Parses the input string Calculates duration per beat Iteratively constructs tones for each note with the correct frequency and duration Concatenates tones into a single AudioSegment Usage Example (you can run directly in the terminal): python /home/matias/.scripts/bin/grub-tune-to-audio-python.py \"480 880 2 988 2 1047 4\" This would produce a tune at 480 BPM, playing 880Hz for 2 beats, 988Hz for 2 beats, and 1047Hz for 4 beats. Output is always an MP3 named output.mp3 in the script's working directory. TL;DR 1. Supply a GRUB tune string as a single quoted argument. 2. The resulting tune is saved as output.mp3 . Integration with Qtile or automation You can bind this script to a key or menu in Qtile to quickly generate audio for GRUB tunes. Since there's no GUI, it is suitable for CLI/terminal usage or quick keybind execution. [!TIP] The script lacks error checking for malformed GRUB tune strings (e.g., missing or extra values, invalid numbers). Output filename is always output.mp3 and will be overwritten with each use\u2014consider adding an option to set the output name. Only MP3 is supported, dependent on ffmpeg or libav . If those are missing or misconfigured, the script will fail. No playback functionality\u2014consider adding an option to automatically play the generated audio for immediate feedback. Parameter parsing could be extended to support more complex GRUB_INIT_TUNE syntaxes or validation. For frequent use, a shell wrapper or integration with your existing workflow (Qtile dmenu, rofi script, etc.) may speed things up.","title":"Convert GRUB Tune to Audio (Python)"},{"location":"scripts/grub-tune-to-audio-python.py/#convert-grub-tune-to-audio-python","text":"grub-tune-to-audio-python.py : Converts a GRUB_INIT_TUNE string into an MP3 audio file","title":"Convert GRUB Tune to Audio (Python)"},{"location":"scripts/grub-tune-to-audio-python.py/#dependencies","text":"python (3.x): Interpreter for running the script pydub : Python library for audio manipulation and synthesis ( pip install pydub ) ffmpeg or libav : Required backend for pydub to handle MP3 export (install via pacman -S ffmpeg on Arch Linux)","title":"Dependencies"},{"location":"scripts/grub-tune-to-audio-python.py/#description","text":"This script translates a GRUB/GRUB2-style GRUB_INIT_TUNE string into an audio file. GRUB allows specifying a boot-time tune using the format: TEMPO [FREQ1 DURATION1 FREQ2 DURATION2 ...] Where: - TEMPO is measured in beats per minute (BPM) - FREQ is the frequency of the note in Hz - DURATION is the relative length of the note, in beats The script parses this string, individually generates each tone using the frequency and duration specified, and concatenates them to form the full sequence. The final result is saved as output.mp3 in the current directory.","title":"Description"},{"location":"scripts/grub-tune-to-audio-python.py/#core-functions","text":"grub_tune_to_audio(tune_string) : Parses the input string Calculates duration per beat Iteratively constructs tones for each note with the correct frequency and duration Concatenates tones into a single AudioSegment","title":"Core Functions"},{"location":"scripts/grub-tune-to-audio-python.py/#usage","text":"Example (you can run directly in the terminal): python /home/matias/.scripts/bin/grub-tune-to-audio-python.py \"480 880 2 988 2 1047 4\" This would produce a tune at 480 BPM, playing 880Hz for 2 beats, 988Hz for 2 beats, and 1047Hz for 4 beats. Output is always an MP3 named output.mp3 in the script's working directory. TL;DR 1. Supply a GRUB tune string as a single quoted argument. 2. The resulting tune is saved as output.mp3 .","title":"Usage"},{"location":"scripts/grub-tune-to-audio-python.py/#integration-with-qtile-or-automation","text":"You can bind this script to a key or menu in Qtile to quickly generate audio for GRUB tunes. Since there's no GUI, it is suitable for CLI/terminal usage or quick keybind execution. [!TIP] The script lacks error checking for malformed GRUB tune strings (e.g., missing or extra values, invalid numbers). Output filename is always output.mp3 and will be overwritten with each use\u2014consider adding an option to set the output name. Only MP3 is supported, dependent on ffmpeg or libav . If those are missing or misconfigured, the script will fail. No playback functionality\u2014consider adding an option to automatically play the generated audio for immediate feedback. Parameter parsing could be extended to support more complex GRUB_INIT_TUNE syntaxes or validation. For frequent use, a shell wrapper or integration with your existing workflow (Qtile dmenu, rofi script, etc.) may speed things up.","title":"Integration with Qtile or automation"},{"location":"scripts/gsi.sh/","text":"Git Repository Sync and Info Utility gsi.sh : Interactive, robust script for syncing a local Git repository with its remote, handling merges, conflicts, and summary display. Dependencies git : Core functionality for all sync operations. bat : Pretty-prints command lines and outputs for improved readability. glow : Markdown rendering for information and summaries in the terminal. realpath , sed , awk , date , wc , etc.: Standard GNU/Linux utilities for bash scripting. Optionally uses ${EDITOR:-vim} for conflict resolution. Expects bash as the interpreter. Description This script provides an enhanced, interactive command-line tool for keeping a local Git repository in sync with its remote, with a particular focus on visual clarity and safe automation. Features include: Colorized, bat-highlighted command outputs for easier tracking of actions. Markdown rendering (via glow ) for readable summaries. Intelligent handling of local changes: Warns about and stashes local modifications before pulling. Attempts fast-forward merges, followed by rebase if necessary. Can handle merge conflicts interactively: opens your $EDITOR, allows aborting/skipping, or manual resolution. Dry-run support to preview actions without making changes (via --dry-run ). Convenient push/commit logic: if local changes are detected, automatically adds, commits (with informative message), and pushes. Repository maintenance: runs git maintenance run post-sync. Human-friendly summary printed using Markdown and glow. Robust error handling : colored messages and immediate exit on errors. Usage and example display when not enough arguments are given. This script is particularly well-suited for workflow automation (e.g., bound to a key with Qtile), but is equally useful interactively. It's designed for fast switching between multiple Git repos, such as dotfiles or script collections. Usage Basic usage from the terminal: ./gsi.sh <repository_path> [--dry-run] Arguments: <repository_path> : (Required) Path to the git repository you want to sync. --dry-run : (Optional) Show what would happen, but make no changes. Examples: ./gsi.sh ~/.scripts ./gsi.sh $SCRIPTS ./gsi.sh $HOME/repos/dots --dry-run You can also alias in your shell or bind to a key in Qtile for rapid access. On merge conflicts: The script will prompt you for: - e : Open $EDITOR to resolve conflicts (or default to vim) - a : Abort - s : Skip this commit [!TIP] - The script is functionally robust, but a few improvements are possible: - No check for untracked files or dirty state pre-stash (could prompt the user or show a diff). - Usage of eval for command execution in run_command() can be dangerous if input data is not well-controlled. - For multi-remote repositories or detached HEAD state, remote/branch detection may not always yield the intended targets. - The conflict handler covers only merge conflicts, but fails for non-merge-related errors (e.g., rebase problems). - Some external tools ( bat , glow ) are optional, but script behavior might be less readable without them. - Error messages could be enhanced to offer remediation advice directly. Overall, this script is very powerful for personal workflow on Arch Linux + Qtile!","title":"Git Repository Sync and Info Utility"},{"location":"scripts/gsi.sh/#git-repository-sync-and-info-utility","text":"gsi.sh : Interactive, robust script for syncing a local Git repository with its remote, handling merges, conflicts, and summary display.","title":"Git Repository Sync and Info Utility"},{"location":"scripts/gsi.sh/#dependencies","text":"git : Core functionality for all sync operations. bat : Pretty-prints command lines and outputs for improved readability. glow : Markdown rendering for information and summaries in the terminal. realpath , sed , awk , date , wc , etc.: Standard GNU/Linux utilities for bash scripting. Optionally uses ${EDITOR:-vim} for conflict resolution. Expects bash as the interpreter.","title":"Dependencies"},{"location":"scripts/gsi.sh/#description","text":"This script provides an enhanced, interactive command-line tool for keeping a local Git repository in sync with its remote, with a particular focus on visual clarity and safe automation. Features include: Colorized, bat-highlighted command outputs for easier tracking of actions. Markdown rendering (via glow ) for readable summaries. Intelligent handling of local changes: Warns about and stashes local modifications before pulling. Attempts fast-forward merges, followed by rebase if necessary. Can handle merge conflicts interactively: opens your $EDITOR, allows aborting/skipping, or manual resolution. Dry-run support to preview actions without making changes (via --dry-run ). Convenient push/commit logic: if local changes are detected, automatically adds, commits (with informative message), and pushes. Repository maintenance: runs git maintenance run post-sync. Human-friendly summary printed using Markdown and glow. Robust error handling : colored messages and immediate exit on errors. Usage and example display when not enough arguments are given. This script is particularly well-suited for workflow automation (e.g., bound to a key with Qtile), but is equally useful interactively. It's designed for fast switching between multiple Git repos, such as dotfiles or script collections.","title":"Description"},{"location":"scripts/gsi.sh/#usage","text":"Basic usage from the terminal: ./gsi.sh <repository_path> [--dry-run]","title":"Usage"},{"location":"scripts/gsi.sh/#arguments","text":"<repository_path> : (Required) Path to the git repository you want to sync. --dry-run : (Optional) Show what would happen, but make no changes.","title":"Arguments:"},{"location":"scripts/gsi.sh/#examples","text":"./gsi.sh ~/.scripts ./gsi.sh $SCRIPTS ./gsi.sh $HOME/repos/dots --dry-run You can also alias in your shell or bind to a key in Qtile for rapid access.","title":"Examples:"},{"location":"scripts/gsi.sh/#on-merge-conflicts","text":"The script will prompt you for: - e : Open $EDITOR to resolve conflicts (or default to vim) - a : Abort - s : Skip this commit [!TIP] - The script is functionally robust, but a few improvements are possible: - No check for untracked files or dirty state pre-stash (could prompt the user or show a diff). - Usage of eval for command execution in run_command() can be dangerous if input data is not well-controlled. - For multi-remote repositories or detached HEAD state, remote/branch detection may not always yield the intended targets. - The conflict handler covers only merge conflicts, but fails for non-merge-related errors (e.g., rebase problems). - Some external tools ( bat , glow ) are optional, but script behavior might be less readable without them. - Error messages could be enhanced to offer remediation advice directly. Overall, this script is very powerful for personal workflow on Arch Linux + Qtile!","title":"On merge conflicts:"},{"location":"scripts/help-pastel.sh/","text":"Pastel Command Helper help-pastel.sh : Enhanced interactive subcommand and help browser for pastel CLI. Dependencies pastel - CLI tool for color manipulation. bat - A cat clone with syntax highlighting and Git integration. fzf - Fuzzy finder for the terminal. rg - ripgrep, for fast text searching. cat - Used for concatenating files. curl - To fetch the remote README. display_markdown.py - Script for markdown preview in terminal (likely a user script). bash - Script interpreter. Description help-pastel.sh is an interactive script designed to make exploring the pastel command-line color tool more efficient. Main features: - Lists all pastel subcommands and a README option in a fuzzy interface. - For any subcommand: pressing enter previews its detailed help, syntax-highlighted. - For the \"README.md\" line: fetches and previews the official pastel README from GitHub, rendered as markdown in your terminal. - Internally, the script: - Locates the subcommands section of pastel -h using ripgrep. - Streams the remaining help lines starting from this section using bat . - Appends a README.md entry as an extra option. - Filters out redundant 'help' lines. - Presents a colorized, preview-powered list in fzf . Usage Run directly in your terminal: $ help-pastel.sh Or assign to a keybinding in qtile for quick access! Usage Flow A list of pastel subcommands (plus \"README.md\") will appear in an fzf prompt. You can: Type to fuzzy search/filter subcommands. Use arrow keys, then press Enter on a selection. See a live help preview for each command. Select \"README.md\" to view the official spherical documentation. [!TIP] - help-pastel.sh is very handy but relies on several external tools. Consider making error-handling more robust for missing dependencies, or check/install them if not found. - The preview logic for the README is tied to a custom script ( display_markdown.py ). If it is missing or incompatible, the README preview will fail. - Appending \"README.md\" as a selectable line is clever, but if the format of pastel -h changes, or the README structure changes upstream, parts of the script may need updating. - The fuzzy list can get quite wide \u2013 you might want to limit line lengths or columns if terminal real estate becomes a problem. - For even more seamless integration, consider extracting the markdown render into its own stable utility (for reuse elsewhere).","title":"Pastel Command Helper"},{"location":"scripts/help-pastel.sh/#pastel-command-helper","text":"help-pastel.sh : Enhanced interactive subcommand and help browser for pastel CLI.","title":"Pastel Command Helper"},{"location":"scripts/help-pastel.sh/#dependencies","text":"pastel - CLI tool for color manipulation. bat - A cat clone with syntax highlighting and Git integration. fzf - Fuzzy finder for the terminal. rg - ripgrep, for fast text searching. cat - Used for concatenating files. curl - To fetch the remote README. display_markdown.py - Script for markdown preview in terminal (likely a user script). bash - Script interpreter.","title":"Dependencies"},{"location":"scripts/help-pastel.sh/#description","text":"help-pastel.sh is an interactive script designed to make exploring the pastel command-line color tool more efficient. Main features: - Lists all pastel subcommands and a README option in a fuzzy interface. - For any subcommand: pressing enter previews its detailed help, syntax-highlighted. - For the \"README.md\" line: fetches and previews the official pastel README from GitHub, rendered as markdown in your terminal. - Internally, the script: - Locates the subcommands section of pastel -h using ripgrep. - Streams the remaining help lines starting from this section using bat . - Appends a README.md entry as an extra option. - Filters out redundant 'help' lines. - Presents a colorized, preview-powered list in fzf .","title":"Description"},{"location":"scripts/help-pastel.sh/#usage","text":"Run directly in your terminal: $ help-pastel.sh Or assign to a keybinding in qtile for quick access!","title":"Usage"},{"location":"scripts/help-pastel.sh/#usage-flow","text":"A list of pastel subcommands (plus \"README.md\") will appear in an fzf prompt. You can: Type to fuzzy search/filter subcommands. Use arrow keys, then press Enter on a selection. See a live help preview for each command. Select \"README.md\" to view the official spherical documentation. [!TIP] - help-pastel.sh is very handy but relies on several external tools. Consider making error-handling more robust for missing dependencies, or check/install them if not found. - The preview logic for the README is tied to a custom script ( display_markdown.py ). If it is missing or incompatible, the README preview will fail. - Appending \"README.md\" as a selectable line is clever, but if the format of pastel -h changes, or the README structure changes upstream, parts of the script may need updating. - The fuzzy list can get quite wide \u2013 you might want to limit line lengths or columns if terminal real estate becomes a problem. - For even more seamless integration, consider extracting the markdown render into its own stable utility (for reuse elsewhere).","title":"Usage Flow"},{"location":"scripts/help_pwcli.sh/","text":"PipeWire CLI Helper help_pwcli.sh : Interactive helper for PipeWire CLI tools, displays per-command help with preview. Dependencies fzf : Interactive fuzzy finder for terminal. bat : A cat clone with syntax highlighting. PipeWire utilities: pw-cat , pw-config , pw-dot , pw-dump , pw-jack , pw-loopback , pw-mididump , pw-midirecord , pw-play , pw-record , pw-top , pw-cli , pw-container , pw-dsdplay , pw-encplay , pw-link , pw-metadata , pw-midiplay , pw-mon , pw-profiler , pw-reserve . These must be installed and available in your $PATH . Description This script provides an interactive terminal menu for browsing the available PipeWire CLI tools and viewing their respective help messages instantly. It leverages fzf for the interface: as you scroll or search through the list of PipeWire commands, the script dynamically shows the -h (help) output for the highlighted command in a pretty, syntax-colored preview using bat . Core Components: prev() : A function that takes a command, runs <command> -h , and pretty-prints the output by piping it through bat . doc() : Echoes a hardcoded, newline-separated list of relevant PipeWire CLI utilities. The named PipeWire tools are piped into fzf ; the preview window refreshes and calls prev to present context-sensitive help for the selected command. Usage You can launch it in your terminal as follows: $ bash /home/matias/.scripts/dev/help_pwcli.sh TL;DR: - Run the script in a terminal. - Start typing to fuzzy-find the PipeWire command you want. - Press Up/Down to browse; the right panel shows the -h output for the highlighted utility. - Enter to exit (no command executes, it's a reader only). Tip: For faster access, you may want to bind this script to a key combination using your qtile config or similar. [!TIP] The script sends every command in the list to <command> -h as preview, but does not check if the command actually exists or if bat syntax (\"pplhelp\") fits the help output. Adding a check (for command existence via command -v \"$1\" ) before running the preview can avoid preview errors for missing tools. The -pplhelp option for bat assumes there is a \"pplhelp\" syntax definition; unless you have defined it, use --language=help or simply let bat autodetect (or just use cat for fallback). If the PipeWire command list changes, you must update the script manually. A more robust solution would dynamically discover commands with a pattern like compgen -c | grep '^pw-' . No action is taken on selection other than previewing help; if you want further actions (like running commands), it would need to be extended.","title":"PipeWire CLI Helper"},{"location":"scripts/help_pwcli.sh/#pipewire-cli-helper","text":"help_pwcli.sh : Interactive helper for PipeWire CLI tools, displays per-command help with preview.","title":"PipeWire CLI Helper"},{"location":"scripts/help_pwcli.sh/#dependencies","text":"fzf : Interactive fuzzy finder for terminal. bat : A cat clone with syntax highlighting. PipeWire utilities: pw-cat , pw-config , pw-dot , pw-dump , pw-jack , pw-loopback , pw-mididump , pw-midirecord , pw-play , pw-record , pw-top , pw-cli , pw-container , pw-dsdplay , pw-encplay , pw-link , pw-metadata , pw-midiplay , pw-mon , pw-profiler , pw-reserve . These must be installed and available in your $PATH .","title":"Dependencies"},{"location":"scripts/help_pwcli.sh/#description","text":"This script provides an interactive terminal menu for browsing the available PipeWire CLI tools and viewing their respective help messages instantly. It leverages fzf for the interface: as you scroll or search through the list of PipeWire commands, the script dynamically shows the -h (help) output for the highlighted command in a pretty, syntax-colored preview using bat . Core Components: prev() : A function that takes a command, runs <command> -h , and pretty-prints the output by piping it through bat . doc() : Echoes a hardcoded, newline-separated list of relevant PipeWire CLI utilities. The named PipeWire tools are piped into fzf ; the preview window refreshes and calls prev to present context-sensitive help for the selected command.","title":"Description"},{"location":"scripts/help_pwcli.sh/#usage","text":"You can launch it in your terminal as follows: $ bash /home/matias/.scripts/dev/help_pwcli.sh TL;DR: - Run the script in a terminal. - Start typing to fuzzy-find the PipeWire command you want. - Press Up/Down to browse; the right panel shows the -h output for the highlighted utility. - Enter to exit (no command executes, it's a reader only). Tip: For faster access, you may want to bind this script to a key combination using your qtile config or similar. [!TIP] The script sends every command in the list to <command> -h as preview, but does not check if the command actually exists or if bat syntax (\"pplhelp\") fits the help output. Adding a check (for command existence via command -v \"$1\" ) before running the preview can avoid preview errors for missing tools. The -pplhelp option for bat assumes there is a \"pplhelp\" syntax definition; unless you have defined it, use --language=help or simply let bat autodetect (or just use cat for fallback). If the PipeWire command list changes, you must update the script manually. A more robust solution would dynamically discover commands with a pattern like compgen -c | grep '^pw-' . No action is taken on selection other than previewing help; if you want further actions (like running commands), it would need to be extended.","title":"Usage"},{"location":"scripts/html_viewer.py/","text":"Hypertext Viewer html_viewer.py : Simple graphical viewer for local HTML and Markdown, with folder browsing. Dependencies python3 \u2014 Required to run the script. PyQt6 \u2014 Provides the Qt GUI (widgets, WebEngine, core modules). PyQt6-WebEngine \u2014 Enables web page rendering. markdown \u2014 Converts Markdown files to HTML for display. (Optional) Your Arch Linux setup should have the necessary Qt6 and Python dependencies ( python-pyqt6 , python-pyqt6-webengine , python-markdown on Arch). Description This script implements a minimal hypertext file viewer for local HTML, Markdown documents, and folders, tailored for desktop use. It combines a web browser widget (via PyQt6's QWebEngineView ) with custom folder and Markdown handling: - Folder as Entry Point : Dropping a directory opens index.md , index.html , or README.md if present; else, it lists folder contents as clickable links. - Markdown Rendering : .md files are rendered as HTML using Python's markdown module, with support for Obsidian-style [[wiki links]] , auto-converted to Markdown link syntax before rendering. - Navigation : Maintains simple back/forward history, a URL bar for navigation, and clickable links in HTML/Markdown. - JavaScript Toggle : Simple menu/toolbar UI for toggling JS support\u2014ideal when opening unknown or potentially unsafe HTML. - Smart File-Finding : Resolves relative or missing files by recursively searching from a project_root (the first file/dir loaded). - Cross-link Handling : Local file and wiki links (in Markdown) transparently open without launching an external browser; web URLs (e.g., http:// ) are printed to stdout. The flexible design lets you browse, preview, and traverse documentation projects, code wikis, or general HTML/Markdown notes from within a PyQt-based app. Usage Run interactively or map to a qtile keybinding. Example invocations: # Open a Markdown file html_viewer.py ~/projects/wiki/NLP_notes.md # Open a directory (tries to open index.md/html, or browses files) html_viewer.py ~/projects/wiki/ # Disable JavaScript for web view (for security) html_viewer.py --disable-js somefile.html # Run with no argument, then open files using the GUI menu html_viewer.py URL bar: Enter a file or directory path to open directly. Use the File > Open File menu, or toolbar for navigation. Folders display clickable file lists. Go back/forward with toolbar buttons. [!CAUTION] - The script does not currently sanitize potentially unsafe HTML or JS\u2014use the JavaScript toggle when opening untrusted files. - There\u2019s no support for opening remote (http/https) URLs within the viewer; external links are just printed to stdout. - The file-finding logic is simple (considers only file names, not relative paths as hyperlinks may expect). - Large directories/folders are displayed with a minimal HTML template\u2014could be styled for improved navigation. - The GUI depends on PyQt6; startup time and resource usage are higher than CLI tools. Consider using xdg-mime or qtile custom keybindings for best integration in your environment. - Internationalization and accessibility features are not present; folder/file names with non-UTF8 chars may cause issues.","title":"Hypertext Viewer"},{"location":"scripts/html_viewer.py/#hypertext-viewer","text":"html_viewer.py : Simple graphical viewer for local HTML and Markdown, with folder browsing.","title":"Hypertext Viewer"},{"location":"scripts/html_viewer.py/#dependencies","text":"python3 \u2014 Required to run the script. PyQt6 \u2014 Provides the Qt GUI (widgets, WebEngine, core modules). PyQt6-WebEngine \u2014 Enables web page rendering. markdown \u2014 Converts Markdown files to HTML for display. (Optional) Your Arch Linux setup should have the necessary Qt6 and Python dependencies ( python-pyqt6 , python-pyqt6-webengine , python-markdown on Arch).","title":"Dependencies"},{"location":"scripts/html_viewer.py/#description","text":"This script implements a minimal hypertext file viewer for local HTML, Markdown documents, and folders, tailored for desktop use. It combines a web browser widget (via PyQt6's QWebEngineView ) with custom folder and Markdown handling: - Folder as Entry Point : Dropping a directory opens index.md , index.html , or README.md if present; else, it lists folder contents as clickable links. - Markdown Rendering : .md files are rendered as HTML using Python's markdown module, with support for Obsidian-style [[wiki links]] , auto-converted to Markdown link syntax before rendering. - Navigation : Maintains simple back/forward history, a URL bar for navigation, and clickable links in HTML/Markdown. - JavaScript Toggle : Simple menu/toolbar UI for toggling JS support\u2014ideal when opening unknown or potentially unsafe HTML. - Smart File-Finding : Resolves relative or missing files by recursively searching from a project_root (the first file/dir loaded). - Cross-link Handling : Local file and wiki links (in Markdown) transparently open without launching an external browser; web URLs (e.g., http:// ) are printed to stdout. The flexible design lets you browse, preview, and traverse documentation projects, code wikis, or general HTML/Markdown notes from within a PyQt-based app.","title":"Description"},{"location":"scripts/html_viewer.py/#usage","text":"Run interactively or map to a qtile keybinding. Example invocations: # Open a Markdown file html_viewer.py ~/projects/wiki/NLP_notes.md # Open a directory (tries to open index.md/html, or browses files) html_viewer.py ~/projects/wiki/ # Disable JavaScript for web view (for security) html_viewer.py --disable-js somefile.html # Run with no argument, then open files using the GUI menu html_viewer.py URL bar: Enter a file or directory path to open directly. Use the File > Open File menu, or toolbar for navigation. Folders display clickable file lists. Go back/forward with toolbar buttons. [!CAUTION] - The script does not currently sanitize potentially unsafe HTML or JS\u2014use the JavaScript toggle when opening untrusted files. - There\u2019s no support for opening remote (http/https) URLs within the viewer; external links are just printed to stdout. - The file-finding logic is simple (considers only file names, not relative paths as hyperlinks may expect). - Large directories/folders are displayed with a minimal HTML template\u2014could be styled for improved navigation. - The GUI depends on PyQt6; startup time and resource usage are higher than CLI tools. Consider using xdg-mime or qtile custom keybindings for best integration in your environment. - Internationalization and accessibility features are not present; folder/file names with non-UTF8 chars may cause issues.","title":"Usage"},{"location":"scripts/improved-fzfmenu.sh/","text":"Improved FZF launcher (Alacritty, pipe-aware) improved-fzfmenu.sh : Launch fzf in Alacritty with optional piping and preserved stdio Dependencies alacritty \u2013 terminal emulator used to host fzf fzf \u2013 fuzzy finder systemd-run \u2013 spawn the terminal in a user scope bash \u2013 script shell qtile (optional) \u2013 window rules can target the class floating bat (optional) \u2013 pretty previews in examples Description This script opens an fzf session inside Alacritty with a predictable window class and title, suitable for qtile floating rules. It preserves the caller\u2019s STDIN and, optionally, STDOUT across the terminal boundary using /proc file descriptors: Reads from caller input: fzf ... < /proc/$$/fd/0 Writes back to caller output when --pipe is set: > /proc/$$/fd/1 Arguments not recognized by the wrapper are safely shell-escaped and forwarded to fzf. Two wrapper options are handled: --pipe: send selection back to the caller\u2019s stdout --terminal-title=TITLE: set the Alacritty window title (default: i_fzfmenu) The terminal class is fixed to floating, making it easy to match in qtile. The command is started via systemd-run --user --scope for clean resource handling and isolation, then exec\u2019d to replace the wrapper process. Usage Basic (input via pipe, view result in the Alacritty window): printf \"apple\\nbanana\\ncherry\\n\" | ~/.scripts/bin/improved-fzfmenu.sh Return the selection to your shell (--pipe): printf \"a\\nb\\nc\\n\" | ~/.scripts/bin/improved-fzfmenu.sh --pipe Chain the result: rg -n \"\" | ~/.scripts/bin/improved-fzfmenu.sh --pipe | cut -d: -f1 | xargs -r nvim Pass fzf options (are forwarded as-is): fd . ~/projects \\ | ~/.scripts/bin/improved-fzfmenu.sh --pipe --terminal-title=Proj-Find \\ --preview 'bat --style=numbers --color=always {}' --ansi --height 80% -m Qtile keybinding example: Key([mod], \"p\", lazy.spawn(\"~/.scripts/bin/improved-fzfmenu.sh --pipe --reverse --height=90%\") ) [!TIP] - Hardcoded terminal/class: add flags like --term=kitty and --class=\u2026 to match diverse rules. - Relying on /proc/$$/fd works locally; it may fail across user boundaries (sudo) or sandboxing. - Without --pipe, selections won\u2019t reach the parent shell; document this prominently or default to --pipe when stdout is a pipe. - systemd-run overhead: consider --collect or properties to auto-clean transient scopes. - If no STDIN is provided, fzf reads from the parent TTY path; clarify expected input (usually via a pipe).","title":"Improved FZF launcher (Alacritty, pipe-aware)"},{"location":"scripts/improved-fzfmenu.sh/#improved-fzf-launcher-alacritty-pipe-aware","text":"improved-fzfmenu.sh : Launch fzf in Alacritty with optional piping and preserved stdio","title":"Improved FZF launcher (Alacritty, pipe-aware)"},{"location":"scripts/improved-fzfmenu.sh/#dependencies","text":"alacritty \u2013 terminal emulator used to host fzf fzf \u2013 fuzzy finder systemd-run \u2013 spawn the terminal in a user scope bash \u2013 script shell qtile (optional) \u2013 window rules can target the class floating bat (optional) \u2013 pretty previews in examples","title":"Dependencies"},{"location":"scripts/improved-fzfmenu.sh/#description","text":"This script opens an fzf session inside Alacritty with a predictable window class and title, suitable for qtile floating rules. It preserves the caller\u2019s STDIN and, optionally, STDOUT across the terminal boundary using /proc file descriptors: Reads from caller input: fzf ... < /proc/$$/fd/0 Writes back to caller output when --pipe is set: > /proc/$$/fd/1 Arguments not recognized by the wrapper are safely shell-escaped and forwarded to fzf. Two wrapper options are handled: --pipe: send selection back to the caller\u2019s stdout --terminal-title=TITLE: set the Alacritty window title (default: i_fzfmenu) The terminal class is fixed to floating, making it easy to match in qtile. The command is started via systemd-run --user --scope for clean resource handling and isolation, then exec\u2019d to replace the wrapper process.","title":"Description"},{"location":"scripts/improved-fzfmenu.sh/#usage","text":"Basic (input via pipe, view result in the Alacritty window): printf \"apple\\nbanana\\ncherry\\n\" | ~/.scripts/bin/improved-fzfmenu.sh Return the selection to your shell (--pipe): printf \"a\\nb\\nc\\n\" | ~/.scripts/bin/improved-fzfmenu.sh --pipe Chain the result: rg -n \"\" | ~/.scripts/bin/improved-fzfmenu.sh --pipe | cut -d: -f1 | xargs -r nvim Pass fzf options (are forwarded as-is): fd . ~/projects \\ | ~/.scripts/bin/improved-fzfmenu.sh --pipe --terminal-title=Proj-Find \\ --preview 'bat --style=numbers --color=always {}' --ansi --height 80% -m Qtile keybinding example: Key([mod], \"p\", lazy.spawn(\"~/.scripts/bin/improved-fzfmenu.sh --pipe --reverse --height=90%\") ) [!TIP] - Hardcoded terminal/class: add flags like --term=kitty and --class=\u2026 to match diverse rules. - Relying on /proc/$$/fd works locally; it may fail across user boundaries (sudo) or sandboxing. - Without --pipe, selections won\u2019t reach the parent shell; document this prominently or default to --pipe when stdout is a pipe. - systemd-run overhead: consider --collect or properties to auto-clean transient scopes. - If no STDIN is provided, fzf reads from the parent TTY path; clarify expected input (usually via a pipe).","title":"Usage"},{"location":"scripts/install_dependencies.sh/","text":"Install Core Utilities and Apps install_dependencies.sh : Bash script to bulk-install essential terminal and desktop utilities. Dependencies paru : An AUR helper for Arch Linux, used for package management. The script also installs the following packages (listed for reference, as they are dependencies of the script use-case, not the script execution): git (version control) fd (faster find ) bat (cat clone with syntax highlighting) fzf (fuzzy finder) ripgrep (fast search) neovim (text editor) chezmoi (dotfiles manager) dmenu (launcher menu) findutils (modern find/xargs) rofi (powermenu/launcher) dunst (notification daemon) python-pandas (data manipulation) python-colorama (terminal coloring) light (screen backlight control) xdotool (simulate keyboard/mouse input) Description This script is a straightforward tool for quickly provisioning a new or existing Arch Linux system (in your case optimized for a qtile-based setup) with a suite of essential desktop, editor, launcher, and utility tools. It works by passing a list of key packages via a Bash here-document directly into paru , which will install only those not already present ( --needed ). Using process substitution, the list is assembled and piped persistently and efficiently into paru . The approach lets you easily update the set of \"must have\" packages for your workflow by simply adding or removing lines from the here-document. Usage Run the script with: ~/.scripts/bin/install_dependencies.sh Interactive: The script can be run in a terminal and will prompt for password if required by paru . Automating dotfiles: It pairs well with dotfiles bootstrapping (e.g., as part of a chezmoi setup or post-install routine). Adding more packages Simply add new lines in the cat <<EOF block before EOF . Example tldr # To ensure you've got all tools for your qtile+Arch setup: bash ~/.scripts/bin/install_dependencies.sh [!TIP] The script is effective but assumes paru is already installed\u2014perhaps document or check for this explicitly. Error handling and reporting could also be improved (e.g., warn about missing paru or failed installs). Finally, for greater flexibility, consider accepting package names as arguments or allowing for grouped lists (e.g., \"minimal\"/\"full\").","title":"Install Core Utilities and Apps"},{"location":"scripts/install_dependencies.sh/#install-core-utilities-and-apps","text":"install_dependencies.sh : Bash script to bulk-install essential terminal and desktop utilities.","title":"Install Core Utilities and Apps"},{"location":"scripts/install_dependencies.sh/#dependencies","text":"paru : An AUR helper for Arch Linux, used for package management. The script also installs the following packages (listed for reference, as they are dependencies of the script use-case, not the script execution): git (version control) fd (faster find ) bat (cat clone with syntax highlighting) fzf (fuzzy finder) ripgrep (fast search) neovim (text editor) chezmoi (dotfiles manager) dmenu (launcher menu) findutils (modern find/xargs) rofi (powermenu/launcher) dunst (notification daemon) python-pandas (data manipulation) python-colorama (terminal coloring) light (screen backlight control) xdotool (simulate keyboard/mouse input)","title":"Dependencies"},{"location":"scripts/install_dependencies.sh/#description","text":"This script is a straightforward tool for quickly provisioning a new or existing Arch Linux system (in your case optimized for a qtile-based setup) with a suite of essential desktop, editor, launcher, and utility tools. It works by passing a list of key packages via a Bash here-document directly into paru , which will install only those not already present ( --needed ). Using process substitution, the list is assembled and piped persistently and efficiently into paru . The approach lets you easily update the set of \"must have\" packages for your workflow by simply adding or removing lines from the here-document.","title":"Description"},{"location":"scripts/install_dependencies.sh/#usage","text":"Run the script with: ~/.scripts/bin/install_dependencies.sh Interactive: The script can be run in a terminal and will prompt for password if required by paru . Automating dotfiles: It pairs well with dotfiles bootstrapping (e.g., as part of a chezmoi setup or post-install routine).","title":"Usage"},{"location":"scripts/install_dependencies.sh/#adding-more-packages","text":"Simply add new lines in the cat <<EOF block before EOF .","title":"Adding more packages"},{"location":"scripts/install_dependencies.sh/#example-tldr","text":"# To ensure you've got all tools for your qtile+Arch setup: bash ~/.scripts/bin/install_dependencies.sh [!TIP] The script is effective but assumes paru is already installed\u2014perhaps document or check for this explicitly. Error handling and reporting could also be improved (e.g., warn about missing paru or failed installs). Finally, for greater flexibility, consider accepting package names as arguments or allowing for grouped lists (e.g., \"minimal\"/\"full\").","title":"Example tldr"},{"location":"scripts/interactive_git_sync.sh/","text":"Interactive Git Repo Synchronizer interactive_git_sync.sh : Interactive script for syncing multiple git repositories with fzf selection. Dependencies fzf \u2014 Command-line fuzzy finder, for interactive repository selection. awk \u2014 Required for text parsing and command generation. bash \u2014 Shell interpreter. sync-repo.sh \u2014 (User script) Executes the actual sync for a chosen repository; must be located at the path contained in $SCRIPTS . Environment variables: $CHEZMOI : Path to your chezmoi repo. $SCRIPTS : Directory containing your user scripts. $LOCALDATA : Path to local data repo. $PSYRIS : Path to psyRIS repo. $GIT_REPOS : Base path to your git repositories. NB: All above environment variables must be exported before using the script. Description This script provides an interactive way to synchronize your frequent git repositories using a fzf menu. It builds a list of predefined repository directories, assembles a command to call an auxiliary script ( sync-repo.sh ) for syncing each repository, and presents a fuzzy-find list to select which repo to sync. How it works: - Defines a list of paths (presumably git repos) based on environment variables. - If run with --dry-run , appends the argument to the sync command for preview/no-op. - Uses awk to prepare a command for each listed repo. - Invokes fzf for interactive selection; user can fuzzy-search among repositories. - Executes the selected sync command (or none if canceled). Usage You can invoke this script from the terminal: ~/.scripts/bin/interactive_git_sync.sh If you want a dry run (no changes, just output): ~/.scripts/bin/interactive_git_sync.sh --dry-run Recommended: For fastest access, assign a qtile keybinding to run this script via your keyboard launcher or lazy.spawn . The script will display a list of your main repositories to fuzzy select from. Selecting one executes the sync script on that repo. [!NOTE] - The script assumes all required environment variables and sync-repo.sh are defined and valid. Consider adding error handling for unset variables. - The script directly uses eval on the constructed command, which is safe only if you control all variables and paths. Evaluate whether eval can be avoided for safety. - The use of awk in cmd_list seems overkill since it just concatenates two items per line. A simple while or even a for loop over the repo list might make the code clearer and less error-prone. - Hardcoded repo list means you have to update the script when you add/remove repos. Optionally, consider scanning $GIT_REPOS directories dynamically.","title":"Interactive Git Repo Synchronizer"},{"location":"scripts/interactive_git_sync.sh/#interactive-git-repo-synchronizer","text":"interactive_git_sync.sh : Interactive script for syncing multiple git repositories with fzf selection.","title":"Interactive Git Repo Synchronizer"},{"location":"scripts/interactive_git_sync.sh/#dependencies","text":"fzf \u2014 Command-line fuzzy finder, for interactive repository selection. awk \u2014 Required for text parsing and command generation. bash \u2014 Shell interpreter. sync-repo.sh \u2014 (User script) Executes the actual sync for a chosen repository; must be located at the path contained in $SCRIPTS . Environment variables: $CHEZMOI : Path to your chezmoi repo. $SCRIPTS : Directory containing your user scripts. $LOCALDATA : Path to local data repo. $PSYRIS : Path to psyRIS repo. $GIT_REPOS : Base path to your git repositories. NB: All above environment variables must be exported before using the script.","title":"Dependencies"},{"location":"scripts/interactive_git_sync.sh/#description","text":"This script provides an interactive way to synchronize your frequent git repositories using a fzf menu. It builds a list of predefined repository directories, assembles a command to call an auxiliary script ( sync-repo.sh ) for syncing each repository, and presents a fuzzy-find list to select which repo to sync. How it works: - Defines a list of paths (presumably git repos) based on environment variables. - If run with --dry-run , appends the argument to the sync command for preview/no-op. - Uses awk to prepare a command for each listed repo. - Invokes fzf for interactive selection; user can fuzzy-search among repositories. - Executes the selected sync command (or none if canceled).","title":"Description"},{"location":"scripts/interactive_git_sync.sh/#usage","text":"You can invoke this script from the terminal: ~/.scripts/bin/interactive_git_sync.sh If you want a dry run (no changes, just output): ~/.scripts/bin/interactive_git_sync.sh --dry-run Recommended: For fastest access, assign a qtile keybinding to run this script via your keyboard launcher or lazy.spawn . The script will display a list of your main repositories to fuzzy select from. Selecting one executes the sync script on that repo. [!NOTE] - The script assumes all required environment variables and sync-repo.sh are defined and valid. Consider adding error handling for unset variables. - The script directly uses eval on the constructed command, which is safe only if you control all variables and paths. Evaluate whether eval can be avoided for safety. - The use of awk in cmd_list seems overkill since it just concatenates two items per line. A simple while or even a for loop over the repo list might make the code clearer and less error-prone. - Hardcoded repo list means you have to update the script when you add/remove repos. Optionally, consider scanning $GIT_REPOS directories dynamically.","title":"Usage"},{"location":"scripts/json_to_markdown.py/","text":"JSON to Markdown Converter json_to_markdown.py : Converts a simple JSON file (list of dicts with \"role\" and \"content\") to a styled Markdown file. Dependencies python (tested on Python 3) Standard library modules only: json , os , sys Description This script enables rapid conversion of structured dialogue data (stored in JSON files) into readable Markdown, using a minimal and direct approach. The expected JSON file format is a list of dictionaries, each with the keys \"role\" and \"content\" : [ {\"role\": \"user\", \"content\": \"Hello!\"}, {\"role\": \"assistant\", \"content\": \"Hi there!\"} ] The script: - Takes a path to a JSON file as a command-line argument. - Reads the file and parses the content. - Iterates over each entry, formatting it in Markdown: - Displays the role (capitalized) as a header in bold and prefixed with hashes. - Follows with an underline and the content. - Delimits entries with horizontal rules (___). - Writes the Markdown output to a file in the same directory, with the same basename and .md extension. Usage Basic usage from terminal: python /home/matias/.scripts/bin/json_to_markdown.py <path_to_json_file> Example: python ~/.scripts/bin/json_to_markdown.py ~/my_dialogue.json If the input is ~/my_dialogue.json , the result will be ~/my_dialogue.md . Tip: - This script can be run from a qtile keybinding, or any launcher, as long as you pass the JSON file as the first argument. [!TIP] The script assumes that every entry in the JSON is a dictionary with \"role\" and \"content\" keys. If any item is missing these keys, it will crash with a KeyError . Consider adding a try-except block to handle malformed inputs gracefully. There\u2019s no command-line help ( -h ) or usage display, so running without arguments will throw an IndexError. Adding a usage message for missing/invalid arguments would improve robustness. Activity is silent: no console output or progress. For complex jobs or scripting integration, consider printing the output filename or a completion message. Scripts writes over existing .md files with the same name without warning. The MarkDown format is simple but could be enhanced with optional arguments (e.g. custom templates, append mode, etc.) for future iterations.","title":"JSON to Markdown Converter"},{"location":"scripts/json_to_markdown.py/#json-to-markdown-converter","text":"json_to_markdown.py : Converts a simple JSON file (list of dicts with \"role\" and \"content\") to a styled Markdown file.","title":"JSON to Markdown Converter"},{"location":"scripts/json_to_markdown.py/#dependencies","text":"python (tested on Python 3) Standard library modules only: json , os , sys","title":"Dependencies"},{"location":"scripts/json_to_markdown.py/#description","text":"This script enables rapid conversion of structured dialogue data (stored in JSON files) into readable Markdown, using a minimal and direct approach. The expected JSON file format is a list of dictionaries, each with the keys \"role\" and \"content\" : [ {\"role\": \"user\", \"content\": \"Hello!\"}, {\"role\": \"assistant\", \"content\": \"Hi there!\"} ] The script: - Takes a path to a JSON file as a command-line argument. - Reads the file and parses the content. - Iterates over each entry, formatting it in Markdown: - Displays the role (capitalized) as a header in bold and prefixed with hashes. - Follows with an underline and the content. - Delimits entries with horizontal rules (___). - Writes the Markdown output to a file in the same directory, with the same basename and .md extension.","title":"Description"},{"location":"scripts/json_to_markdown.py/#usage","text":"Basic usage from terminal: python /home/matias/.scripts/bin/json_to_markdown.py <path_to_json_file> Example: python ~/.scripts/bin/json_to_markdown.py ~/my_dialogue.json If the input is ~/my_dialogue.json , the result will be ~/my_dialogue.md . Tip: - This script can be run from a qtile keybinding, or any launcher, as long as you pass the JSON file as the first argument. [!TIP] The script assumes that every entry in the JSON is a dictionary with \"role\" and \"content\" keys. If any item is missing these keys, it will crash with a KeyError . Consider adding a try-except block to handle malformed inputs gracefully. There\u2019s no command-line help ( -h ) or usage display, so running without arguments will throw an IndexError. Adding a usage message for missing/invalid arguments would improve robustness. Activity is silent: no console output or progress. For complex jobs or scripting integration, consider printing the output filename or a completion message. Scripts writes over existing .md files with the same name without warning. The MarkDown format is simple but could be enhanced with optional arguments (e.g. custom templates, append mode, etc.) for future iterations.","title":"Usage"},{"location":"scripts/jupyter_new_notebook.xsh/","text":"Jupyter New Notebook Launcher jupyter_new_notebook.xsh : Quickly create and open a blank Jupyter notebook in Chromium via dmenu. Dependencies xonsh : Python-powered shell, required to run .xsh scripts. jupyter-notebook : Launches and serves Jupyter notebooks. chromium : Browser used to open the notebook. dmenu : Dynamic menu for interactive notebook naming. notify-send : Sends system notifications (for errors and prompts). ls , echo : Standard UNIX utilities. Description This script streamlines the creation of new Jupyter notebooks within your ~/projects directory: Prompts for a notebook name via dmenu . Appends \".ipynb\" to the chosen name. Checks if a notebook with that name already exists in ~/projects . If not, it creates an empty notebook file (with standard Jupyter JSON boilerplate) and opens it in Chromium via Jupyter Notebook. If the file exists, or no name is provided, an error notification is shown. The script is ideal for rapidly spawning new notebook workspaces and integrating them into your qtile workflow, especially when paired with a custom keybinding for fast access. Usage Simple, interactive usage: jupyter_new_notebook.xsh Typical workflow: 1. Run the script (bind to a key in qtile for maximum efficiency). 2. A dmenu prompt appears\u2014type a name for your new notebook. 3. If the name is unique, a blank notebook is created and automatically opened in Chromium. 4. If it already exists or no name is entered, a desktop notification displays the error. Example (terminal): ~/.scripts/bin/jupyter_new_notebook.xsh Example (qtile config): Key([mod], \"n\", lazy.spawn(\"~/.scripts/bin/jupyter_new_notebook.xsh\"), desc=\"New Jupyter Notebook\") [!TIP] - The script does not sanitize input thoroughly; entering file-unfriendly characters in dmenu (such as slashes or other specials) may create unusable files. - Error checking on the PROJECT_PATH directory is absent; ensure it exists, or the script will fail. - Consider adding further validation for notebook names and improving messaging (e.g., support for spaces, automatic trimming, or handling .ipynb suffixes). - Optionally, allow creation within subfolders or expose more notebook metadata (like kernel selection), for more flexibility. - The script always opens the notebook in Chromium; you might want to make the browser configurable.","title":"Jupyter New Notebook Launcher"},{"location":"scripts/jupyter_new_notebook.xsh/#jupyter-new-notebook-launcher","text":"jupyter_new_notebook.xsh : Quickly create and open a blank Jupyter notebook in Chromium via dmenu.","title":"Jupyter New Notebook Launcher"},{"location":"scripts/jupyter_new_notebook.xsh/#dependencies","text":"xonsh : Python-powered shell, required to run .xsh scripts. jupyter-notebook : Launches and serves Jupyter notebooks. chromium : Browser used to open the notebook. dmenu : Dynamic menu for interactive notebook naming. notify-send : Sends system notifications (for errors and prompts). ls , echo : Standard UNIX utilities.","title":"Dependencies"},{"location":"scripts/jupyter_new_notebook.xsh/#description","text":"This script streamlines the creation of new Jupyter notebooks within your ~/projects directory: Prompts for a notebook name via dmenu . Appends \".ipynb\" to the chosen name. Checks if a notebook with that name already exists in ~/projects . If not, it creates an empty notebook file (with standard Jupyter JSON boilerplate) and opens it in Chromium via Jupyter Notebook. If the file exists, or no name is provided, an error notification is shown. The script is ideal for rapidly spawning new notebook workspaces and integrating them into your qtile workflow, especially when paired with a custom keybinding for fast access.","title":"Description"},{"location":"scripts/jupyter_new_notebook.xsh/#usage","text":"Simple, interactive usage: jupyter_new_notebook.xsh Typical workflow: 1. Run the script (bind to a key in qtile for maximum efficiency). 2. A dmenu prompt appears\u2014type a name for your new notebook. 3. If the name is unique, a blank notebook is created and automatically opened in Chromium. 4. If it already exists or no name is entered, a desktop notification displays the error. Example (terminal): ~/.scripts/bin/jupyter_new_notebook.xsh Example (qtile config): Key([mod], \"n\", lazy.spawn(\"~/.scripts/bin/jupyter_new_notebook.xsh\"), desc=\"New Jupyter Notebook\") [!TIP] - The script does not sanitize input thoroughly; entering file-unfriendly characters in dmenu (such as slashes or other specials) may create unusable files. - Error checking on the PROJECT_PATH directory is absent; ensure it exists, or the script will fail. - Consider adding further validation for notebook names and improving messaging (e.g., support for spaces, automatic trimming, or handling .ipynb suffixes). - Optionally, allow creation within subfolders or expose more notebook metadata (like kernel selection), for more flexibility. - The script always opens the notebook in Chromium; you might want to make the browser configurable.","title":"Usage"},{"location":"scripts/keyboard-help.sh/","text":"Keyboard Layout Helper keyboard-help.sh : Displays keyboard layout help in a floating terminal with syntax highlighting Dependencies show_keyboard_layout.py \u2014 Script providing a list or visual of the system's keyboard layout(s). xterm \u2014 Terminal emulator used to display the output. setsid \u2014 Utility to run a command in a new session. bat \u2014 A cat clone with syntax highlighting and paging, improves readability. bash \u2014 The shell used to execute the command. Description This script is designed to quickly display your keyboard layout documentation in a floating terminal window\u2014making it useful for reference or learning custom keybindings. Here\u2019s how it works step by step: Finds the Keyboard Script: It locates show_keyboard_layout.py with which to ensure it picks the correct script file. Floating Terminal : It then runs the script in xterm , forcing a custom title ( KB_layout_floating ) and a large 20-point font for clarity. The setsid command ensures the terminal is launched as an independent session (preventing it from being closed if the calling session closes). Syntax Highlighting with bat : Output from your keyboard layout script is piped into bat , turning the terminal window into a scrollable, well-formatted display. Usage You can run this script directly from the command line or map it to a keybinding in qtile for quick access. Command-line: ~/.scripts/bin/keyboard-help.sh Qtile keybinding example (in your config.py ): Key([mod], \"F1\", lazy.spawn(\"~/.scripts/bin/keyboard-help.sh\")) Replace [mod] with your mod key (e.g., \"mod4\" for the Super/Windows key). What you'll see: A floating xterm window titled KB_layout_floating that displays your current keyboard layout in a readable, scrollable format. Use arrow keys to scroll, q to quit ( bat 's navigation). [!TIP] Potential improvements and critique : - The script assumes show_keyboard_layout.py is in your $PATH and executable; you may wish to check this explicitly and print a friendly error if missing. - If bat or xterm are not installed, the script will fail silently. Adding dependency checks and error messages can make debugging easier. - Consider supporting other terminal emulators (like alacritty or urxvt ) if you swap away from xterm in the future. - The terminal is not forced to float; if your qtile rules don\u2019t float windows with the given title/class, you may wish to set up a rule or call wmctrl /Qtile hooks to do so. - If you frequently need this, consider caching the keyboard layout if generation is slow.","title":"Keyboard Layout Helper"},{"location":"scripts/keyboard-help.sh/#keyboard-layout-helper","text":"keyboard-help.sh : Displays keyboard layout help in a floating terminal with syntax highlighting","title":"Keyboard Layout Helper"},{"location":"scripts/keyboard-help.sh/#dependencies","text":"show_keyboard_layout.py \u2014 Script providing a list or visual of the system's keyboard layout(s). xterm \u2014 Terminal emulator used to display the output. setsid \u2014 Utility to run a command in a new session. bat \u2014 A cat clone with syntax highlighting and paging, improves readability. bash \u2014 The shell used to execute the command.","title":"Dependencies"},{"location":"scripts/keyboard-help.sh/#description","text":"This script is designed to quickly display your keyboard layout documentation in a floating terminal window\u2014making it useful for reference or learning custom keybindings. Here\u2019s how it works step by step: Finds the Keyboard Script: It locates show_keyboard_layout.py with which to ensure it picks the correct script file. Floating Terminal : It then runs the script in xterm , forcing a custom title ( KB_layout_floating ) and a large 20-point font for clarity. The setsid command ensures the terminal is launched as an independent session (preventing it from being closed if the calling session closes). Syntax Highlighting with bat : Output from your keyboard layout script is piped into bat , turning the terminal window into a scrollable, well-formatted display.","title":"Description"},{"location":"scripts/keyboard-help.sh/#usage","text":"You can run this script directly from the command line or map it to a keybinding in qtile for quick access. Command-line: ~/.scripts/bin/keyboard-help.sh Qtile keybinding example (in your config.py ): Key([mod], \"F1\", lazy.spawn(\"~/.scripts/bin/keyboard-help.sh\")) Replace [mod] with your mod key (e.g., \"mod4\" for the Super/Windows key). What you'll see: A floating xterm window titled KB_layout_floating that displays your current keyboard layout in a readable, scrollable format. Use arrow keys to scroll, q to quit ( bat 's navigation). [!TIP] Potential improvements and critique : - The script assumes show_keyboard_layout.py is in your $PATH and executable; you may wish to check this explicitly and print a friendly error if missing. - If bat or xterm are not installed, the script will fail silently. Adding dependency checks and error messages can make debugging easier. - Consider supporting other terminal emulators (like alacritty or urxvt ) if you swap away from xterm in the future. - The terminal is not forced to float; if your qtile rules don\u2019t float windows with the given title/class, you may wish to set up a rule or call wmctrl /Qtile hooks to do so. - If you frequently need this, consider caching the keyboard layout if generation is slow.","title":"Usage"},{"location":"scripts/launch_tmux_with_music_player.sh/","text":"Launch Tmux with Music Player launch_tmux_with_music_player.sh : Creates a headless tmux session named \"MUSIC\" and starts the cmus music player within. Dependencies tmux : Terminal multiplexer for managing multiple terminal sessions. cmus : Lightweight CLI music player. /usr/bin/bash : The script runs in Bash; Arch Linux uses /usr/bin/bash by default. Description This script is designed to quickly set up a detached tmux session running the cmus music player, ideal for background music listening without launching a visible terminal window. Specifically, it: Creates a new tmux session named MUSIC . Opens a window inside the session, named cmus . Launches cmus within that window. Does not attach to the session, so it runs quietly in the background. This makes it easy to integrate with qtile keybindings or scripts; for example, you can bind this script to a hotkey to instantly start your music backend. Usage To use the script, simply execute: ~/.scripts/bin/launch_tmux_with_music_player.sh Example: Attach to the session To view or control cmus , simply attach to the tmux session: tmux attach-session -t MUSIC Or, if you want to close the player and kill the session: tmux kill-session -t MUSIC Typical workflow with qtile Bind this script to a keybinding in your qtile config.py . Control playback via cmus-remote commands, tmux, or by re-attaching as shown above. [!TIP] - The script does not check if a session called MUSIC already exists. Running it multiple times will result in a tmux error (\"duplicate session: MUSIC\"). You could improve the script by checking for an existing session and, optionally, switching to (or restarting) it. - Also, there is no error handling; failures of cmus (if it is not installed, for example) won't show up unless you manually check. - Consider accepting the session name or music player as an optional argument to make the script more flexible for future use.","title":"Launch Tmux with Music Player"},{"location":"scripts/launch_tmux_with_music_player.sh/#launch-tmux-with-music-player","text":"launch_tmux_with_music_player.sh : Creates a headless tmux session named \"MUSIC\" and starts the cmus music player within.","title":"Launch Tmux with Music Player"},{"location":"scripts/launch_tmux_with_music_player.sh/#dependencies","text":"tmux : Terminal multiplexer for managing multiple terminal sessions. cmus : Lightweight CLI music player. /usr/bin/bash : The script runs in Bash; Arch Linux uses /usr/bin/bash by default.","title":"Dependencies"},{"location":"scripts/launch_tmux_with_music_player.sh/#description","text":"This script is designed to quickly set up a detached tmux session running the cmus music player, ideal for background music listening without launching a visible terminal window. Specifically, it: Creates a new tmux session named MUSIC . Opens a window inside the session, named cmus . Launches cmus within that window. Does not attach to the session, so it runs quietly in the background. This makes it easy to integrate with qtile keybindings or scripts; for example, you can bind this script to a hotkey to instantly start your music backend.","title":"Description"},{"location":"scripts/launch_tmux_with_music_player.sh/#usage","text":"To use the script, simply execute: ~/.scripts/bin/launch_tmux_with_music_player.sh","title":"Usage"},{"location":"scripts/launch_tmux_with_music_player.sh/#example-attach-to-the-session","text":"To view or control cmus , simply attach to the tmux session: tmux attach-session -t MUSIC Or, if you want to close the player and kill the session: tmux kill-session -t MUSIC","title":"Example: Attach to the session"},{"location":"scripts/launch_tmux_with_music_player.sh/#typical-workflow-with-qtile","text":"Bind this script to a keybinding in your qtile config.py . Control playback via cmus-remote commands, tmux, or by re-attaching as shown above. [!TIP] - The script does not check if a session called MUSIC already exists. Running it multiple times will result in a tmux error (\"duplicate session: MUSIC\"). You could improve the script by checking for an existing session and, optionally, switching to (or restarting) it. - Also, there is no error handling; failures of cmus (if it is not installed, for example) won't show up unless you manually check. - Consider accepting the session name or music player as an optional argument to make the script more flexible for future use.","title":"Typical workflow with qtile"},{"location":"scripts/list-openai-models.sh/","text":"OpenAI Model Lister list-openai-models.sh : Lists and caches available OpenAI API models with creation dates Dependencies openai : OpenAI command-line interface; used to fetch the list of available models for your account. jq : Command-line JSON processor; used to extract model IDs and creation times from OpenAI's API output. bat : Syntax-highlighting cat clone; used to display the cached output with TSV highlighting. stat , sed , tr , and standard GNU utilities. Description This script fetches the list of available models from your OpenAI account using the openai CLI, extracting each model's creation date and ID. To improve efficiency and avoid frequent API calls, it caches the resulting model list as a TSV file in $XDG_CACHE_HOME/openai-model-list.tsv , refreshing it only if the cache is older than 24 hours. Core functionality: Checks if a recent cache exists (less than 24 hours old). If cache is valid, pretty-prints its content using bat as TSV. Otherwise, fetches a fresh model list: Calls openai api models.list , pipes through jq to get date/id info. Parses the creation dates with date , formats to %Y-%m-%d , or echoes raw values on failure. Reformats to TSV ( \\t separated), sorts, and saves to the cache. Displays the cache using bat . The script is well-suited for your Arch + qtile workflow, supporting both direct terminal usage and integration into custom keybindings or scripts. Usage To list available OpenAI models with their creation dates: ~/.scripts/bin/list-openai-models.sh Example keybinding in qtile (Python): Key([mod], \"o\", lazy.spawn(\"~/.scripts/bin/list-openai-models.sh\")) Output will use bat (with TSV highlighting). If you don't have a recent cache, the OpenAI API will be queried. Typical output: 2022-05-14 ada 2022-05-14 babbage 2023-03-01 gpt-4 ... [!NOTE] - The jq command .[\"created\", \"id\"] is not valid syntax for extracting both fields as a tuple or object. This could lead to no output or the wrong fields being fetched. Consider revising it to e.g. .data[] | [.created, .id] | @tsv to properly extract and format the fields you want. - The script assumes $XDG_CACHE_HOME is set. If it isn't, the cache path will be unset, causing failure or unexpected behavior. - Reliance on external commands ( bat , openai , jq , etc.) means the script will fail silently if any are missing. You may want to add checks or error messages for missing dependencies. - The caching logic uses stat --format=\"%Y\" , which gives the modification time in seconds since the epoch, but the cache freshness check should be tested to make sure time arithmetic is correct. - As written, the parsing pipeline is brittle and may not correctly process the OpenAI API\u2019s current output structure. Re-examine and test with current API responses. - For machine use or further automation, consider outputting clean TSV/CSV and allowing a --no-color flag for scripting.","title":"OpenAI Model Lister"},{"location":"scripts/list-openai-models.sh/#openai-model-lister","text":"list-openai-models.sh : Lists and caches available OpenAI API models with creation dates","title":"OpenAI Model Lister"},{"location":"scripts/list-openai-models.sh/#dependencies","text":"openai : OpenAI command-line interface; used to fetch the list of available models for your account. jq : Command-line JSON processor; used to extract model IDs and creation times from OpenAI's API output. bat : Syntax-highlighting cat clone; used to display the cached output with TSV highlighting. stat , sed , tr , and standard GNU utilities.","title":"Dependencies"},{"location":"scripts/list-openai-models.sh/#description","text":"This script fetches the list of available models from your OpenAI account using the openai CLI, extracting each model's creation date and ID. To improve efficiency and avoid frequent API calls, it caches the resulting model list as a TSV file in $XDG_CACHE_HOME/openai-model-list.tsv , refreshing it only if the cache is older than 24 hours. Core functionality: Checks if a recent cache exists (less than 24 hours old). If cache is valid, pretty-prints its content using bat as TSV. Otherwise, fetches a fresh model list: Calls openai api models.list , pipes through jq to get date/id info. Parses the creation dates with date , formats to %Y-%m-%d , or echoes raw values on failure. Reformats to TSV ( \\t separated), sorts, and saves to the cache. Displays the cache using bat . The script is well-suited for your Arch + qtile workflow, supporting both direct terminal usage and integration into custom keybindings or scripts.","title":"Description"},{"location":"scripts/list-openai-models.sh/#usage","text":"To list available OpenAI models with their creation dates: ~/.scripts/bin/list-openai-models.sh Example keybinding in qtile (Python): Key([mod], \"o\", lazy.spawn(\"~/.scripts/bin/list-openai-models.sh\")) Output will use bat (with TSV highlighting). If you don't have a recent cache, the OpenAI API will be queried. Typical output: 2022-05-14 ada 2022-05-14 babbage 2023-03-01 gpt-4 ... [!NOTE] - The jq command .[\"created\", \"id\"] is not valid syntax for extracting both fields as a tuple or object. This could lead to no output or the wrong fields being fetched. Consider revising it to e.g. .data[] | [.created, .id] | @tsv to properly extract and format the fields you want. - The script assumes $XDG_CACHE_HOME is set. If it isn't, the cache path will be unset, causing failure or unexpected behavior. - Reliance on external commands ( bat , openai , jq , etc.) means the script will fail silently if any are missing. You may want to add checks or error messages for missing dependencies. - The caching logic uses stat --format=\"%Y\" , which gives the modification time in seconds since the epoch, but the cache freshness check should be tested to make sure time arithmetic is correct. - As written, the parsing pipeline is brittle and may not correctly process the OpenAI API\u2019s current output structure. Re-examine and test with current API responses. - For machine use or further automation, consider outputting clean TSV/CSV and allowing a --no-color flag for scripting.","title":"Usage"},{"location":"scripts/list_process.sh/","text":"list_process.sh list_process.sh : Lists all systemd services, showing their statuses sorted by type Dependencies systemctl \u2013 The system and service manager used by systemd; core in Arch Linux. sort \u2013 Standard Unix sort utility; sorts output alphabetically by specified column. Description This script rapidly lists all available systemd services (units of type service ), including both active and inactive ones. The output is formatted with: No pager, so results display entirely in one go (helpful for scripting or redirecting output). No legend or heading, giving you a raw, parsable list. The results are piped into sort -k4 , which sorts the lines based on the fourth whitespace-delimited field (status, typically: enabled, disabled, static, etc.). This is useful if you want to quickly review the current state of service units without needing to interactively scroll, especially when working in minimal terminal environments inside your Arch + qtile setup. Usage You can run this script from any terminal. It does not require arguments. Example: ~/.scripts/bin/list_process.sh You can also bind this to a key combination in your qtile configuration for quick access, or pipe the results for further processing: ~/.scripts/bin/list_process.sh | grep running If you want to inspect only enabled services: ~/.scripts/bin/list_process.sh | grep enabled To save the list to a file: ~/.scripts/bin/list_process.sh > ~/service_list.txt [!NOTE] While the script is functional and minimalist, there are a few points for possible improvement: - Sorting by the fourth column ( -k4 ) might not reflect the most important attribute for all users. Sometimes sorting by unit name ( -k1 ) or state ( -k3 ) may be more insightful. - The script could accept a custom sort key as an argument for flexibility. - Consider renaming the file to avoid confusion: the current name ( list_process.sh ) suggests listing running processes, while it strictly lists systemd services . - A brief help section or usage hint for command-line arguments could be useful if expanded. - No color or highlighting is used. If visual clarity is needed, tools like column or grep --color=auto could be added.","title":"list_process.sh"},{"location":"scripts/list_process.sh/#list_processsh","text":"list_process.sh : Lists all systemd services, showing their statuses sorted by type","title":"list_process.sh"},{"location":"scripts/list_process.sh/#dependencies","text":"systemctl \u2013 The system and service manager used by systemd; core in Arch Linux. sort \u2013 Standard Unix sort utility; sorts output alphabetically by specified column.","title":"Dependencies"},{"location":"scripts/list_process.sh/#description","text":"This script rapidly lists all available systemd services (units of type service ), including both active and inactive ones. The output is formatted with: No pager, so results display entirely in one go (helpful for scripting or redirecting output). No legend or heading, giving you a raw, parsable list. The results are piped into sort -k4 , which sorts the lines based on the fourth whitespace-delimited field (status, typically: enabled, disabled, static, etc.). This is useful if you want to quickly review the current state of service units without needing to interactively scroll, especially when working in minimal terminal environments inside your Arch + qtile setup.","title":"Description"},{"location":"scripts/list_process.sh/#usage","text":"You can run this script from any terminal. It does not require arguments.","title":"Usage"},{"location":"scripts/list_process.sh/#example","text":"~/.scripts/bin/list_process.sh You can also bind this to a key combination in your qtile configuration for quick access, or pipe the results for further processing: ~/.scripts/bin/list_process.sh | grep running If you want to inspect only enabled services: ~/.scripts/bin/list_process.sh | grep enabled To save the list to a file: ~/.scripts/bin/list_process.sh > ~/service_list.txt [!NOTE] While the script is functional and minimalist, there are a few points for possible improvement: - Sorting by the fourth column ( -k4 ) might not reflect the most important attribute for all users. Sometimes sorting by unit name ( -k1 ) or state ( -k3 ) may be more insightful. - The script could accept a custom sort key as an argument for flexibility. - Consider renaming the file to avoid confusion: the current name ( list_process.sh ) suggests listing running processes, while it strictly lists systemd services . - A brief help section or usage hint for command-line arguments could be useful if expanded. - No color or highlighting is used. If visual clarity is needed, tools like column or grep --color=auto could be added.","title":"Example:"},{"location":"scripts/llama-all-scripts-describer.py/","text":"Llama-powered Script Documentation Generator llama-all-scripts-describer.py : Automated Github-style markdown documentation for scripts using Llama 3.1 Dependencies python (3.8+ recommended) colorama \u2013 For colored terminal output ( PyPI link ) ollama \u2013 Python client for interfacing with local Llama model API fd \u2013 Fast file finding utility (available on Arch as fd ) ripgrep (rg) \u2013 Fast grep alternative xargs \u2013 For passing arguments from stdin csv (Python stdlib) subprocess , os , sys , argparse (Python stdlib) Custom user script: utils_update_symlinks.sh (Ensures symlinks are up-to-date before doc generation) Local Llama 3.1 model accessible via ollama Description This script automates the generation (and maintenance) of markdown documentation for your personal script collection, leveraging Llama 3.1 as an AI-powered doc writer. Its workflow is as follows: Symlink Update Prompt: Before working, it asks to run your utils_update_symlinks.sh to ensure the symlink state matches your scripts. Script Enumeration: It lists all files within $SCRIPTS , filters out markdown files, and builds a set of known script files. Orphaned Doc Detection: After processing, it points out markdown docs that no longer correspond to any actual script (i.e., orphans). Binary/Script Differentiation: If it finds a binary file, it attempts to locate the source in $SCRIPTS/src using common source extensions. If found, it documents that source; if not, it warns and skips. Script Description: For each script (from your CSV, typically symlink structure), it: Reads the script (or source) Calls out to the Llama 3.1 Ollama endpoint to generate GitHub-flavored markdown documentation Writes this documentation to $SCRIPTS/docs/scripts/<scriptname>.md Updates $SCRIPTS/docs/index.md with a link to the new doc Index Updating: The index file is maintained for easy navigation. Usage Typical scenario on your qtile + Arch system: llama-all-scripts-describer.py [optional/path/to/symlink_data.csv] If you do not provide a CSV path, it assumes: $SCRIPTS/data/symlink_data.csv with environment variable SCRIPTS pointing to your scripts directory. Example Workflows Simply run: llama-all-scripts-describer.py Specify an alternate symlink data file: llama-all-scripts-describer.py /path/to/custom_symlink_data.csv Best used from a terminal or bound to a key in your qtile workflow. [!CAUTION] - The script assumes a specific directory structure governed by your $SCRIPTS env variable - this isn't portable unless others mimic your setup. - The binary/source pairing mechanism is extension-based and could miss custom extensions or source locations. - Docs are only generated if .md does not already exist; no updating of existing docs unless you remove them. - ollama setup (especially model name llama3.1 ) must be correct and available, or the script will silently skip doc generation. - The CSV parser skips the header but assumes full three-column CSV conformity ( original_path, symlink, command_name ); mismatches could cause runtime errors. - For robust automation, additional logging/reporting and error handling would be helpful, as errors (for instance, permission issues or subprocess failures) currently cause abrupt exits in some places.","title":"Llama-powered Script Documentation Generator"},{"location":"scripts/llama-all-scripts-describer.py/#llama-powered-script-documentation-generator","text":"llama-all-scripts-describer.py : Automated Github-style markdown documentation for scripts using Llama 3.1","title":"Llama-powered Script Documentation Generator"},{"location":"scripts/llama-all-scripts-describer.py/#dependencies","text":"python (3.8+ recommended) colorama \u2013 For colored terminal output ( PyPI link ) ollama \u2013 Python client for interfacing with local Llama model API fd \u2013 Fast file finding utility (available on Arch as fd ) ripgrep (rg) \u2013 Fast grep alternative xargs \u2013 For passing arguments from stdin csv (Python stdlib) subprocess , os , sys , argparse (Python stdlib) Custom user script: utils_update_symlinks.sh (Ensures symlinks are up-to-date before doc generation) Local Llama 3.1 model accessible via ollama","title":"Dependencies"},{"location":"scripts/llama-all-scripts-describer.py/#description","text":"This script automates the generation (and maintenance) of markdown documentation for your personal script collection, leveraging Llama 3.1 as an AI-powered doc writer. Its workflow is as follows: Symlink Update Prompt: Before working, it asks to run your utils_update_symlinks.sh to ensure the symlink state matches your scripts. Script Enumeration: It lists all files within $SCRIPTS , filters out markdown files, and builds a set of known script files. Orphaned Doc Detection: After processing, it points out markdown docs that no longer correspond to any actual script (i.e., orphans). Binary/Script Differentiation: If it finds a binary file, it attempts to locate the source in $SCRIPTS/src using common source extensions. If found, it documents that source; if not, it warns and skips. Script Description: For each script (from your CSV, typically symlink structure), it: Reads the script (or source) Calls out to the Llama 3.1 Ollama endpoint to generate GitHub-flavored markdown documentation Writes this documentation to $SCRIPTS/docs/scripts/<scriptname>.md Updates $SCRIPTS/docs/index.md with a link to the new doc Index Updating: The index file is maintained for easy navigation.","title":"Description"},{"location":"scripts/llama-all-scripts-describer.py/#usage","text":"Typical scenario on your qtile + Arch system: llama-all-scripts-describer.py [optional/path/to/symlink_data.csv] If you do not provide a CSV path, it assumes: $SCRIPTS/data/symlink_data.csv with environment variable SCRIPTS pointing to your scripts directory.","title":"Usage"},{"location":"scripts/llama-all-scripts-describer.py/#example-workflows","text":"Simply run: llama-all-scripts-describer.py Specify an alternate symlink data file: llama-all-scripts-describer.py /path/to/custom_symlink_data.csv Best used from a terminal or bound to a key in your qtile workflow. [!CAUTION] - The script assumes a specific directory structure governed by your $SCRIPTS env variable - this isn't portable unless others mimic your setup. - The binary/source pairing mechanism is extension-based and could miss custom extensions or source locations. - Docs are only generated if .md does not already exist; no updating of existing docs unless you remove them. - ollama setup (especially model name llama3.1 ) must be correct and available, or the script will silently skip doc generation. - The CSV parser skips the header but assumes full three-column CSV conformity ( original_path, symlink, command_name ); mismatches could cause runtime errors. - For robust automation, additional logging/reporting and error handling would be helpful, as errors (for instance, permission issues or subprocess failures) currently cause abrupt exits in some places.","title":"Example Workflows"},{"location":"scripts/llm-script-describer.py/","text":"LLM Script Describer \u2014 generate per-file docs and a README summary llm-script-describer.py : Generate per-script docs and README sections via OpenAI Dependencies uv \u2014 runs the script and resolves Python deps from the header python>=3.13 \u2014 required by the script header colorama \u2014 colored terminal output openai \u2014 OpenAI Chat Completions client fd \u2014 fast file discovery in $SCRIPTS ripgrep \u2014 filters paths (exclude patterns) utils_update_symlinks.sh \u2014 your helper to refresh symlink_data.csv (in $PATH) OPENAI_API_KEY \u2014 OpenAI API token SCRIPTS \u2014 root of the scripts repository Description This meta-tool walks your scripts repo, decides what needs documenting, and asks an LLM to generate GitHub-ready markdown. Flow: 1) Refresh symlinks via utils_update_symlinks.sh . 2) Find relevant files with fd (excluding archived/config/docs/log/data and media). 3) Cache-aware processing: compute sha256 per file and skip unchanged entries (persisted in script_info.json ). 4) Binary detection: if a file contains NUL bytes, look for a textual source in $SCRIPTS/src with one of: .c, .cpp, .py, .sh, .rs, .go, .js, .ts, .rb, .java, .cs. 5) Per-file docs: write to docs/scripts/<filename>.md , then update docs/index.md . 6) README: inject a global summary between <!-- llm_generated_output_start --> and <!-- llm_generated_output_end --> , and rebuild a table between <!-- table_start --> and <!-- table_end --> . Models: per-file uses PER_FILE_LLM (default \u201cgpt-5\u201d), and the README summary uses SUMMARY_LLM (\u201co4-mini-high\u201d). Usage Prepare environment: export SCRIPTS=\"$HOME/.scripts\" # repo root export OPENAI_API_KEY=\"sk-...\" # your key Ensure README has these tags: ``` - Run (Arch + uv): ~/.scripts/meta/llm-script-describer.py - Optional model arg (currently ignored by the script): ~/.scripts/meta/llm-script-describer.py gpt-4o-mini - Force a full rebuild: rm \"$SCRIPTS/script_info.json\" ~/.scripts/meta/llm-script-describer.py - Qtile keybinding example: Key([mod, \"shift\"], \"D\", lazy.spawn(\"~/.scripts/meta/llm-script-describer.py\")) ``` [!WARNING] - README tags are mandatory; missing tags will crash .index() lookups. - update_index sorts the whole file, potentially scrambling headings; restrict sorting to list items only. - The CLI model argument is parsed but never used; PER_FILE_LLM / SUMMARY_LLM are hard-coded. - \"[FILE]:\" in llm_summarize doesn\u2019t match the documented \"[FILE]\" format; fix for better summaries. - Short description extraction is brittle ( split('---') ); consider a dedicated front-matter parser. - Binary detection (NUL-in-first-1KiB) is heuristic; allow overrides or MIME checks. - Add retries/rate limiting and better error handling for OpenAI API failures.","title":"LLM Script Describer \u2014 generate per-file docs and a README summary"},{"location":"scripts/llm-script-describer.py/#llm-script-describer-generate-per-file-docs-and-a-readme-summary","text":"llm-script-describer.py : Generate per-script docs and README sections via OpenAI","title":"LLM Script Describer \u2014 generate per-file docs and a README summary"},{"location":"scripts/llm-script-describer.py/#dependencies","text":"uv \u2014 runs the script and resolves Python deps from the header python>=3.13 \u2014 required by the script header colorama \u2014 colored terminal output openai \u2014 OpenAI Chat Completions client fd \u2014 fast file discovery in $SCRIPTS ripgrep \u2014 filters paths (exclude patterns) utils_update_symlinks.sh \u2014 your helper to refresh symlink_data.csv (in $PATH) OPENAI_API_KEY \u2014 OpenAI API token SCRIPTS \u2014 root of the scripts repository","title":"Dependencies"},{"location":"scripts/llm-script-describer.py/#description","text":"This meta-tool walks your scripts repo, decides what needs documenting, and asks an LLM to generate GitHub-ready markdown. Flow: 1) Refresh symlinks via utils_update_symlinks.sh . 2) Find relevant files with fd (excluding archived/config/docs/log/data and media). 3) Cache-aware processing: compute sha256 per file and skip unchanged entries (persisted in script_info.json ). 4) Binary detection: if a file contains NUL bytes, look for a textual source in $SCRIPTS/src with one of: .c, .cpp, .py, .sh, .rs, .go, .js, .ts, .rb, .java, .cs. 5) Per-file docs: write to docs/scripts/<filename>.md , then update docs/index.md . 6) README: inject a global summary between <!-- llm_generated_output_start --> and <!-- llm_generated_output_end --> , and rebuild a table between <!-- table_start --> and <!-- table_end --> . Models: per-file uses PER_FILE_LLM (default \u201cgpt-5\u201d), and the README summary uses SUMMARY_LLM (\u201co4-mini-high\u201d).","title":"Description"},{"location":"scripts/llm-script-describer.py/#usage","text":"Prepare environment: export SCRIPTS=\"$HOME/.scripts\" # repo root export OPENAI_API_KEY=\"sk-...\" # your key Ensure README has these tags: ``` - Run (Arch + uv): ~/.scripts/meta/llm-script-describer.py - Optional model arg (currently ignored by the script): ~/.scripts/meta/llm-script-describer.py gpt-4o-mini - Force a full rebuild: rm \"$SCRIPTS/script_info.json\" ~/.scripts/meta/llm-script-describer.py - Qtile keybinding example: Key([mod, \"shift\"], \"D\", lazy.spawn(\"~/.scripts/meta/llm-script-describer.py\")) ``` [!WARNING] - README tags are mandatory; missing tags will crash .index() lookups. - update_index sorts the whole file, potentially scrambling headings; restrict sorting to list items only. - The CLI model argument is parsed but never used; PER_FILE_LLM / SUMMARY_LLM are hard-coded. - \"[FILE]:\" in llm_summarize doesn\u2019t match the documented \"[FILE]\" format; fix for better summaries. - Short description extraction is brittle ( split('---') ); consider a dedicated front-matter parser. - Binary detection (NUL-in-first-1KiB) is heuristic; allow overrides or MIME checks. - Add retries/rate limiting and better error handling for OpenAI API failures.","title":"Usage"},{"location":"scripts/m3u_creator.sh/","text":"m3u Creator Script m3u_creator.sh : Quickly generate an m3u playlist file from all files in the current directory Dependencies bash Standard GNU Bourne Again Shell. ls Coreutils tool to list directory contents. Description This script automates the creation of an .m3u playlist file containing all files (one per line) in the current directory. The generated playlist is named after the directory itself, following this pattern: <directory-name>.m3u For example, if you're in a directory called MyMusic , running this script will create a file called MyMusic.m3u that lists every file in that directory. How it works: Retrieves the base name of your current working directory ( $PWD ). Runs ls -1 to list all files (non-recursively) in the directory, one per line. Writes this file list into a new .m3u file whose name matches your current directory name. This is useful for quickly generating simple playlist files compatible with music players that support the M3U format. Usage You can run the script in any directory to create a playlist from the files in that directory. Direct Terminal execution: cd ~/Music/Albums/SomeAlbum ~/.scripts/bin/m3u_creator.sh This creates SomeAlbum.m3u in the current directory, containing a list of all files found there. Assigning to qtile keybinding: To map the script to a keybinding in your qtile config: Key([mod], \"F10\", lazy.spawn(\"~/.scripts/bin/m3u_creator.sh\")) (Replace [mod] and \"F10\" with your preferred modifier and key) TL;DR # From within any folder: m3u_creator.sh # A playlist .m3u appears with the same name as the directory, listing all files inside. [!TIP] The script lists all files , regardless of file type. Consider filtering for music files (e.g., .mp3 , .flac ) if you want your playlist to include only relevant formats. Files are listed in alphabetical order and not recursively. Subfolders and their contents are not included. Filenames containing newlines or special characters could cause issues with some players. If re-run, the script overwrites any existing .m3u with the same name, which might lead to data loss if your playlist was edited manually. For a more robust solution, use find and filtering, e.g. find . -maxdepth 1 -type f -iname \"*.mp3\" | sort > \"$playlist_file\" This way, only music files are included in the playlist.","title":"m3u Creator Script"},{"location":"scripts/m3u_creator.sh/#m3u-creator-script","text":"m3u_creator.sh : Quickly generate an m3u playlist file from all files in the current directory","title":"m3u Creator Script"},{"location":"scripts/m3u_creator.sh/#dependencies","text":"bash Standard GNU Bourne Again Shell. ls Coreutils tool to list directory contents.","title":"Dependencies"},{"location":"scripts/m3u_creator.sh/#description","text":"This script automates the creation of an .m3u playlist file containing all files (one per line) in the current directory. The generated playlist is named after the directory itself, following this pattern: <directory-name>.m3u For example, if you're in a directory called MyMusic , running this script will create a file called MyMusic.m3u that lists every file in that directory. How it works: Retrieves the base name of your current working directory ( $PWD ). Runs ls -1 to list all files (non-recursively) in the directory, one per line. Writes this file list into a new .m3u file whose name matches your current directory name. This is useful for quickly generating simple playlist files compatible with music players that support the M3U format.","title":"Description"},{"location":"scripts/m3u_creator.sh/#usage","text":"You can run the script in any directory to create a playlist from the files in that directory.","title":"Usage"},{"location":"scripts/m3u_creator.sh/#direct-terminal-execution","text":"cd ~/Music/Albums/SomeAlbum ~/.scripts/bin/m3u_creator.sh This creates SomeAlbum.m3u in the current directory, containing a list of all files found there.","title":"Direct Terminal execution:"},{"location":"scripts/m3u_creator.sh/#assigning-to-qtile-keybinding","text":"To map the script to a keybinding in your qtile config: Key([mod], \"F10\", lazy.spawn(\"~/.scripts/bin/m3u_creator.sh\")) (Replace [mod] and \"F10\" with your preferred modifier and key)","title":"Assigning to qtile keybinding:"},{"location":"scripts/m3u_creator.sh/#tldr","text":"# From within any folder: m3u_creator.sh # A playlist .m3u appears with the same name as the directory, listing all files inside. [!TIP] The script lists all files , regardless of file type. Consider filtering for music files (e.g., .mp3 , .flac ) if you want your playlist to include only relevant formats. Files are listed in alphabetical order and not recursively. Subfolders and their contents are not included. Filenames containing newlines or special characters could cause issues with some players. If re-run, the script overwrites any existing .m3u with the same name, which might lead to data loss if your playlist was edited manually. For a more robust solution, use find and filtering, e.g. find . -maxdepth 1 -type f -iname \"*.mp3\" | sort > \"$playlist_file\" This way, only music files are included in the playlist.","title":"TL;DR"},{"location":"scripts/mechen_music_transfert.py/","text":"Mechen Music Transfert Utility mechen_music_transfert.py : Syncs a subset of unlistened music albums to the MECHEN MP3 player, fitting within a max size. Dependencies python3 pandas : Data manipulation and filtering. beet (from beets): For querying the music library; used to list unlistened albums. du , rsync , mkdir , rm , sudo : Used for size calculation, syncing, and filesystem operations. Your music should be organized in /home/matias/music and the player mounted at /home/matias/MECHEN . Description This script helps you transfer a random subset of unlistened music albums to your MECHEN MP3 player device, keeping within a specified storage size ( 50MB by default, MAX_SPACE ). The process is as follows: Password Prompt : Requests your sudo password interactively (once per run). Album Discovery : Uses beet (beets) to find all unlistened albums by status. Size Calculation : Gathers directory sizes to stay within MAX_SPACE . Randomized Filtering : Randomly removes artists from the selection until the fit is right. Cleanup : Removes albums and artists from the device not in the current selection. Directory Creation : Makes sure album/artist folders exist on the player device. Sync : Uses rsync (with sudo ) to copy album contents. This script manages both the selection logic and the device's filesystem state, so your MECHEN always contains \"fresh\" unlistened albums, without going over its storage limit. Usage Make sure your player is mounted at /home/matias/MECHEN . You need to have your music library managed by beets and tagged appropriately. Run the script in a terminal: python3 /home/matias/.scripts/bin/mechen_music_transfert.py You will be prompted for your sudo password (used for file operations on the player device). The script will display progress as it selects albums, prepares folders, and syncs files. Tip: Set up a keybinding in your Qtile config to quickly launch this script in a terminal if you refresh your player frequently. [!TIP] - The script hardcodes paths (music library, player mount), space limits, and uses sudo, which makes it less portable and somewhat risky (danger of rm -rf ). Consider parameterizing these with command-line arguments or a config file, and add more user prompts for destructive actions. - Error handling is minimal\u2014if a subprocess fails, it silently continues. Checking exit statuses and printing errors would make it more robust. - Using getpass for the sudo password is practical for you, but reusing the password for every operation is slow; consider using a root-owned helper script or running the script with sudo directly. - You might want to log operations for troubleshooting, especially if synced files go missing! - This script is powerful for your workflow, but double-check your beets status tags and consider backing up the MECHEN folder before using.","title":"Mechen Music Transfert Utility"},{"location":"scripts/mechen_music_transfert.py/#mechen-music-transfert-utility","text":"mechen_music_transfert.py : Syncs a subset of unlistened music albums to the MECHEN MP3 player, fitting within a max size.","title":"Mechen Music Transfert Utility"},{"location":"scripts/mechen_music_transfert.py/#dependencies","text":"python3 pandas : Data manipulation and filtering. beet (from beets): For querying the music library; used to list unlistened albums. du , rsync , mkdir , rm , sudo : Used for size calculation, syncing, and filesystem operations. Your music should be organized in /home/matias/music and the player mounted at /home/matias/MECHEN .","title":"Dependencies"},{"location":"scripts/mechen_music_transfert.py/#description","text":"This script helps you transfer a random subset of unlistened music albums to your MECHEN MP3 player device, keeping within a specified storage size ( 50MB by default, MAX_SPACE ). The process is as follows: Password Prompt : Requests your sudo password interactively (once per run). Album Discovery : Uses beet (beets) to find all unlistened albums by status. Size Calculation : Gathers directory sizes to stay within MAX_SPACE . Randomized Filtering : Randomly removes artists from the selection until the fit is right. Cleanup : Removes albums and artists from the device not in the current selection. Directory Creation : Makes sure album/artist folders exist on the player device. Sync : Uses rsync (with sudo ) to copy album contents. This script manages both the selection logic and the device's filesystem state, so your MECHEN always contains \"fresh\" unlistened albums, without going over its storage limit.","title":"Description"},{"location":"scripts/mechen_music_transfert.py/#usage","text":"Make sure your player is mounted at /home/matias/MECHEN . You need to have your music library managed by beets and tagged appropriately. Run the script in a terminal: python3 /home/matias/.scripts/bin/mechen_music_transfert.py You will be prompted for your sudo password (used for file operations on the player device). The script will display progress as it selects albums, prepares folders, and syncs files. Tip: Set up a keybinding in your Qtile config to quickly launch this script in a terminal if you refresh your player frequently. [!TIP] - The script hardcodes paths (music library, player mount), space limits, and uses sudo, which makes it less portable and somewhat risky (danger of rm -rf ). Consider parameterizing these with command-line arguments or a config file, and add more user prompts for destructive actions. - Error handling is minimal\u2014if a subprocess fails, it silently continues. Checking exit statuses and printing errors would make it more robust. - Using getpass for the sudo password is practical for you, but reusing the password for every operation is slow; consider using a root-owned helper script or running the script with sudo directly. - You might want to log operations for troubleshooting, especially if synced files go missing! - This script is powerful for your workflow, but double-check your beets status tags and consider backing up the MECHEN folder before using.","title":"Usage"},{"location":"scripts/megacmd_launch_tmux.sh/","text":"megacmd_launch_tmux.sh megacmd_launch_tmux.sh : Launches mega-cmd inside a new detached tmux session. Dependencies tmux : Terminal multiplexer to manage sessions. mega-cmd : MEGA CLI client for interacting with MEGA cloud services. Description This script is a utility for starting the mega-cmd application in a detached tmux session. It creates a new tmux session called MEGA with a single window named megacmd , running the mega-cmd process in it. This is helpful to ensure that mega-cmd runs in the background and remains alive, independent from any terminal window. Key features: Starts tmux detached ( -d ). Sets session name ( -s MEGA ). Sets initial window name ( -n megacmd ) for clarity. Ensures that mega-cmd keeps running until explicitly killed or the tmux session is ended. Usage You can run this script directly from the terminal, or call it from another script, your qtile config, or a keybinding. Basic usage: ~/.scripts/bin/megacmd_launch_tmux.sh Check if the session is running: tmux ls Attach to the MEGA session: tmux attach -t MEGA Kill the session when you're done: tmux kill-session -t MEGA Automate from qtile: You can set up a qtile keybinding to execute this script, making mega-cmd management seamless from your window manager. [!TIP] - The script does not check if the MEGA session already exists, so running it multiple times will fail with a duplicate session error. - For idempotency, consider adding: tmux has-session -t MEGA 2>/dev/null || tmux new-session -d -s MEGA -n megacmd 'mega-cmd' - No logging or notification is implemented; if mega-cmd fails, you won't see errors. - If you want auto-start at login, consider adding the script to your .xprofile or an autostart mechanism in qtile.","title":"megacmd_launch_tmux.sh"},{"location":"scripts/megacmd_launch_tmux.sh/#megacmd_launch_tmuxsh","text":"megacmd_launch_tmux.sh : Launches mega-cmd inside a new detached tmux session.","title":"megacmd_launch_tmux.sh"},{"location":"scripts/megacmd_launch_tmux.sh/#dependencies","text":"tmux : Terminal multiplexer to manage sessions. mega-cmd : MEGA CLI client for interacting with MEGA cloud services.","title":"Dependencies"},{"location":"scripts/megacmd_launch_tmux.sh/#description","text":"This script is a utility for starting the mega-cmd application in a detached tmux session. It creates a new tmux session called MEGA with a single window named megacmd , running the mega-cmd process in it. This is helpful to ensure that mega-cmd runs in the background and remains alive, independent from any terminal window. Key features: Starts tmux detached ( -d ). Sets session name ( -s MEGA ). Sets initial window name ( -n megacmd ) for clarity. Ensures that mega-cmd keeps running until explicitly killed or the tmux session is ended.","title":"Description"},{"location":"scripts/megacmd_launch_tmux.sh/#usage","text":"You can run this script directly from the terminal, or call it from another script, your qtile config, or a keybinding. Basic usage: ~/.scripts/bin/megacmd_launch_tmux.sh Check if the session is running: tmux ls Attach to the MEGA session: tmux attach -t MEGA Kill the session when you're done: tmux kill-session -t MEGA Automate from qtile: You can set up a qtile keybinding to execute this script, making mega-cmd management seamless from your window manager. [!TIP] - The script does not check if the MEGA session already exists, so running it multiple times will fail with a duplicate session error. - For idempotency, consider adding: tmux has-session -t MEGA 2>/dev/null || tmux new-session -d -s MEGA -n megacmd 'mega-cmd' - No logging or notification is implemented; if mega-cmd fails, you won't see errors. - If you want auto-start at login, consider adding the script to your .xprofile or an autostart mechanism in qtile.","title":"Usage"},{"location":"scripts/megaignore_editor.sh/","text":"MegaIgnore File Editor megaignore_editor.sh : Fuzzy finder interface for searching, editing, and deleting .megaignore files. Dependencies fd : Fast and user-friendly alternative to find , used for locating .megaignore files. fzf : Command-line fuzzy finder to interactively select files. bat : A cat clone with syntax highlighting in the preview pane. nvim : Neovim editor, for opening selected files. rm : Standard UNIX tool for removing files. Bash shell. (Optionally) runs best under a terminal in Arch Linux with qtile window manager. Description This script provides an interactive tool for managing your .megaignore files scattered throughout your home and /mnt directories. It continuously presents you with a fuzzy finder list (via fzf ) of all .megaignore files found by fd . Key functions: - Preview : When browsing, the contents of each file are previewed with syntax highlighting by bat . - Edit : Pressing Enter opens the selected file in nvim for editing. - Delete : Pressing Ctrl-D deletes the selected file using rm . After each fuzzy finder session, you're asked if you want to continue; typing n exits the script, hitting Enter or any other key starts a new search cycle. Usage The script is designed to be run in a terminal session: ~/.scripts/bin/megaignore_editor.sh Upon running, you'll be presented a list of all .megaignore files. Use the interactive fuzzy search to filter files. Preview content: Automatically shown on selecting any file. Edit file : Press Enter \u2014opens in Neovim. Delete file : Press Ctrl-D . After exiting the fzf window, confirm if you'd like to continue. Example session Run the script: sh ~/.scripts/bin/megaignore_editor.sh Use fzf to select and preview .megaignore files. Hit Enter to edit, or Ctrl-D to delete. Respond to the prompt to repeat or exit. [!TIP] There\u2019s no confirmation for rm , which could lead to accidental file loss; consider adding a confirmation step. The script assumes all dependencies ( fd , fzf , bat , nvim ) are installed and available in your PATH . Users not running Neovim should adjust the editor to preference. If you have many .megaignore files or filesystem access is slow, there might be a short delay while running fd . Handling file names with spaces could be improved (e.g., quoting {} parameters more carefully). Long-running in an infinite loop; user can only exit cleanly by entering n at the prompt. Optional early exit (e.g., by pressing q in fzf ) could be a nice feature.","title":"MegaIgnore File Editor"},{"location":"scripts/megaignore_editor.sh/#megaignore-file-editor","text":"megaignore_editor.sh : Fuzzy finder interface for searching, editing, and deleting .megaignore files.","title":"MegaIgnore File Editor"},{"location":"scripts/megaignore_editor.sh/#dependencies","text":"fd : Fast and user-friendly alternative to find , used for locating .megaignore files. fzf : Command-line fuzzy finder to interactively select files. bat : A cat clone with syntax highlighting in the preview pane. nvim : Neovim editor, for opening selected files. rm : Standard UNIX tool for removing files. Bash shell. (Optionally) runs best under a terminal in Arch Linux with qtile window manager.","title":"Dependencies"},{"location":"scripts/megaignore_editor.sh/#description","text":"This script provides an interactive tool for managing your .megaignore files scattered throughout your home and /mnt directories. It continuously presents you with a fuzzy finder list (via fzf ) of all .megaignore files found by fd . Key functions: - Preview : When browsing, the contents of each file are previewed with syntax highlighting by bat . - Edit : Pressing Enter opens the selected file in nvim for editing. - Delete : Pressing Ctrl-D deletes the selected file using rm . After each fuzzy finder session, you're asked if you want to continue; typing n exits the script, hitting Enter or any other key starts a new search cycle.","title":"Description"},{"location":"scripts/megaignore_editor.sh/#usage","text":"The script is designed to be run in a terminal session: ~/.scripts/bin/megaignore_editor.sh Upon running, you'll be presented a list of all .megaignore files. Use the interactive fuzzy search to filter files. Preview content: Automatically shown on selecting any file. Edit file : Press Enter \u2014opens in Neovim. Delete file : Press Ctrl-D . After exiting the fzf window, confirm if you'd like to continue.","title":"Usage"},{"location":"scripts/megaignore_editor.sh/#example-session","text":"Run the script: sh ~/.scripts/bin/megaignore_editor.sh Use fzf to select and preview .megaignore files. Hit Enter to edit, or Ctrl-D to delete. Respond to the prompt to repeat or exit. [!TIP] There\u2019s no confirmation for rm , which could lead to accidental file loss; consider adding a confirmation step. The script assumes all dependencies ( fd , fzf , bat , nvim ) are installed and available in your PATH . Users not running Neovim should adjust the editor to preference. If you have many .megaignore files or filesystem access is slow, there might be a short delay while running fd . Handling file names with spaces could be improved (e.g., quoting {} parameters more carefully). Long-running in an infinite loop; user can only exit cleanly by entering n at the prompt. Optional early exit (e.g., by pressing q in fzf ) could be a nice feature.","title":"Example session"},{"location":"scripts/megasync.sh/","text":"Megasync Arch/Qtile Launcher megasync.sh : Launches MEGAsync with specific environment variables set for Qtile/Arch environments Dependencies megasync : Official MEGA desktop sync client for Linux. bash : Standard GNU Bourne Again SHell interpreter. Description This launcher script starts the megasync client, but ensures two key environment variables are set for compatibility in non-standard desktop environments (like Qtile): DO_NOT_UNSET_QT_QPA_PLATFORMTHEME=1 : Prevents MEGAsync from unsetting the QT_QPA_PLATFORMTHEME variable, which can be crucial for consistent theming and font rendering under Qtile or non-GNOME/KDE WMs. DO_NOT_SET_DESKTOP_SETTINGS_UNAWARE=1 : Tells MEGAsync not to mark itself as \"unaware\" of desktop environment settings, improving appearance and possibly notification behavior on Arch/Qtile setups. This script is especially useful if you experience MEGAsync theming glitches or settings issues with your custom window manager. The script is written for Arch Linux with the Qtile WM, but will work on any system (primarily X11) where these issues occur. Usage TL;DR ~/.scripts/dev/megasync.sh You can run this directly in your terminal, or assign it to a key binding in Qtile (see below). Qtile Keybinding Example Add to your ~/.config/qtile/config.py : Key([mod], \"m\", lazy.spawn(\"~/.scripts/dev/megasync.sh\"), desc=\"Launch MEGAsync with env fixes\") Autostart Example Add to your Qtile autostart script (e.g. in ~/.config/qtile/autostart.sh ): ~/.scripts/dev/megasync.sh & [!TIP] Critique & Suggestions: - This script is minimal and does its job, but it lacks error checking (e.g., if megasync is not installed, it will just fail silently). - Inline export of variables is clear, but if you add more variables or logic, consider using the export command for better readability and maintainability. - For logging or troubleshooting, you might want to redirect stdout/stderr to a simple log file. - Consider a shebang portability tweak ( #!/usr/bin/env bash ) for improved robustness across systems. - If you have other apps with similar needs, generalizing this script to wrap arbitrary commands with custom environment variables may be useful.","title":"Megasync Arch/Qtile Launcher"},{"location":"scripts/megasync.sh/#megasync-archqtile-launcher","text":"megasync.sh : Launches MEGAsync with specific environment variables set for Qtile/Arch environments","title":"Megasync Arch/Qtile Launcher"},{"location":"scripts/megasync.sh/#dependencies","text":"megasync : Official MEGA desktop sync client for Linux. bash : Standard GNU Bourne Again SHell interpreter.","title":"Dependencies"},{"location":"scripts/megasync.sh/#description","text":"This launcher script starts the megasync client, but ensures two key environment variables are set for compatibility in non-standard desktop environments (like Qtile): DO_NOT_UNSET_QT_QPA_PLATFORMTHEME=1 : Prevents MEGAsync from unsetting the QT_QPA_PLATFORMTHEME variable, which can be crucial for consistent theming and font rendering under Qtile or non-GNOME/KDE WMs. DO_NOT_SET_DESKTOP_SETTINGS_UNAWARE=1 : Tells MEGAsync not to mark itself as \"unaware\" of desktop environment settings, improving appearance and possibly notification behavior on Arch/Qtile setups. This script is especially useful if you experience MEGAsync theming glitches or settings issues with your custom window manager. The script is written for Arch Linux with the Qtile WM, but will work on any system (primarily X11) where these issues occur.","title":"Description"},{"location":"scripts/megasync.sh/#usage","text":"","title":"Usage"},{"location":"scripts/megasync.sh/#tldr","text":"~/.scripts/dev/megasync.sh You can run this directly in your terminal, or assign it to a key binding in Qtile (see below).","title":"TL;DR"},{"location":"scripts/megasync.sh/#qtile-keybinding-example","text":"Add to your ~/.config/qtile/config.py : Key([mod], \"m\", lazy.spawn(\"~/.scripts/dev/megasync.sh\"), desc=\"Launch MEGAsync with env fixes\")","title":"Qtile Keybinding Example"},{"location":"scripts/megasync.sh/#autostart-example","text":"Add to your Qtile autostart script (e.g. in ~/.config/qtile/autostart.sh ): ~/.scripts/dev/megasync.sh & [!TIP] Critique & Suggestions: - This script is minimal and does its job, but it lacks error checking (e.g., if megasync is not installed, it will just fail silently). - Inline export of variables is clear, but if you add more variables or logic, consider using the export command for better readability and maintainability. - For logging or troubleshooting, you might want to redirect stdout/stderr to a simple log file. - Consider a shebang portability tweak ( #!/usr/bin/env bash ) for improved robustness across systems. - If you have other apps with similar needs, generalizing this script to wrap arbitrary commands with custom environment variables may be useful.","title":"Autostart Example"},{"location":"scripts/midi2arch.xsh/","text":"MIDI Controller to Script Launcher midi2arch.xsh : Transform a MIDI controller into a script/keyboard command launcher for Arch Dependencies xonsh : Required shell to interpret the script. python-yaml : For parsing the YAML configuration file. aseqdump : MIDI event monitoring utility. xdotool (commented, not currently used) : For simulating keypress events. nanoKONTROL2 (or compatible MIDI controller): The script is designed for this device. User config file: ~/.scripts/config/midi2arch/nanoKONTROL2.yaml \u2013 Describes MIDI event to command mappings. Description This script enables mapping physical controls on a MIDI device (such as nanoKONTROL2) to arbitrary shell commands or keypresses on an Arch Linux system, specifically for use with the qtile window manager workflow. How It Works: 1. Device Detection: The script looks for attached MIDI controllers, specifically nanoKONTROL2 . If not found, it exits. 2. Configuration: Reads control mappings from a YAML config file located at ~/.scripts/config/midi2arch/nanoKONTROL2.yaml . This file defines which controller control triggers which shell command or action. 3. Listening Loop: Spawns aseqdump as a subprocess to listen for real-time MIDI events. - When a specific control-change message with value 127 is detected, the mapped command is executed via xonsh interpolation. - Receiving control cc == 39 (hardcoded) will terminate the listener. 4. Event Listing Mode: If run with the -l flag, dumps all MIDI events to stdout for mapping discovery or debugging (no commands are triggered). Usage Basic: midi2arch.xsh Connect your MIDI controller (nanoKONTROL2). Press controls as mapped in your YAML config, and the corresponding shell commands will run. Event Listing (debug/discover mode): midi2arch.xsh -l Just prints MIDI events as received. Useful for mapping controls in your YAML. Add to qtile or WM keybindings: - Can be run at login or via a specific keybinding in your qtile config. - Background usage is typical for real-time response. YAML Mapping Config Example: general: name: nanoKONTROL2 controls: play_button: [\"button_play\", 41, \"Pressed\", \"playerctl play\"] stop_button: [\"button_stop\", 42, \"Pressed\", \"playerctl stop\"] [!IMPORTANT] - Error Handling: The script currently parses MIDI messages in a brittle way (fixed CSV position, lacks robust MIDI spec parsing). It may break on unexpected event lines. - Limited Device Support: Only recognizes nanoKONTROL2 explicitly; others would require code edits and a proper extension of detection logic. - Security: Executing arbitrary commands from a YAML file can be a risk; ensure your config file is secure. - Graceful Exit: Hardcoded control (cc==39) for exit is not flexible; make this configurable for broader device support. - Enhancements: Use async subprocess and full MIDI parsing library for robustness. Add more CLI options and config validation.","title":"MIDI Controller to Script Launcher"},{"location":"scripts/midi2arch.xsh/#midi-controller-to-script-launcher","text":"midi2arch.xsh : Transform a MIDI controller into a script/keyboard command launcher for Arch","title":"MIDI Controller to Script Launcher"},{"location":"scripts/midi2arch.xsh/#dependencies","text":"xonsh : Required shell to interpret the script. python-yaml : For parsing the YAML configuration file. aseqdump : MIDI event monitoring utility. xdotool (commented, not currently used) : For simulating keypress events. nanoKONTROL2 (or compatible MIDI controller): The script is designed for this device. User config file: ~/.scripts/config/midi2arch/nanoKONTROL2.yaml \u2013 Describes MIDI event to command mappings.","title":"Dependencies"},{"location":"scripts/midi2arch.xsh/#description","text":"This script enables mapping physical controls on a MIDI device (such as nanoKONTROL2) to arbitrary shell commands or keypresses on an Arch Linux system, specifically for use with the qtile window manager workflow. How It Works: 1. Device Detection: The script looks for attached MIDI controllers, specifically nanoKONTROL2 . If not found, it exits. 2. Configuration: Reads control mappings from a YAML config file located at ~/.scripts/config/midi2arch/nanoKONTROL2.yaml . This file defines which controller control triggers which shell command or action. 3. Listening Loop: Spawns aseqdump as a subprocess to listen for real-time MIDI events. - When a specific control-change message with value 127 is detected, the mapped command is executed via xonsh interpolation. - Receiving control cc == 39 (hardcoded) will terminate the listener. 4. Event Listing Mode: If run with the -l flag, dumps all MIDI events to stdout for mapping discovery or debugging (no commands are triggered).","title":"Description"},{"location":"scripts/midi2arch.xsh/#usage","text":"Basic: midi2arch.xsh Connect your MIDI controller (nanoKONTROL2). Press controls as mapped in your YAML config, and the corresponding shell commands will run. Event Listing (debug/discover mode): midi2arch.xsh -l Just prints MIDI events as received. Useful for mapping controls in your YAML. Add to qtile or WM keybindings: - Can be run at login or via a specific keybinding in your qtile config. - Background usage is typical for real-time response. YAML Mapping Config Example: general: name: nanoKONTROL2 controls: play_button: [\"button_play\", 41, \"Pressed\", \"playerctl play\"] stop_button: [\"button_stop\", 42, \"Pressed\", \"playerctl stop\"] [!IMPORTANT] - Error Handling: The script currently parses MIDI messages in a brittle way (fixed CSV position, lacks robust MIDI spec parsing). It may break on unexpected event lines. - Limited Device Support: Only recognizes nanoKONTROL2 explicitly; others would require code edits and a proper extension of detection logic. - Security: Executing arbitrary commands from a YAML file can be a risk; ensure your config file is secure. - Graceful Exit: Hardcoded control (cc==39) for exit is not flexible; make this configurable for broader device support. - Enhancements: Use async subprocess and full MIDI parsing library for robustness. Add more CLI options and config validation.","title":"Usage"},{"location":"scripts/midi2cmd.py/","text":"MIDI2CMD Python Utility midi2cmd.py : Manage and monitor MIDI controller input and test connections from the terminal Dependencies python (tested with standard Python 3) click ( pip install click ) \u2014 CLI framework for building commands and options amidi (provided by alsa-utils on Arch Linux) \u2014 Command-line MIDI device tool shlex and subprocess \u2014 Standard Python libraries (no extra install needed) Description This script provides a convenient terminal interface to interact with MIDI controllers connected to your system, primarily designed for use on your Arch Linux system with qtile window manager. Core capabilities: - List available MIDI controllers (device names and device IDs) - Monitor MIDI messages from a selected controller, in raw or parsed/human-readable mode - Connection test to verify if a controller device is accessible Command Overview: - Uses the amidi tool for device interrogation and message monitoring - Offers a CLI via the robust click Python package - Default controller is set to nanoKONTROL2 if none specified Highlights: - Parsed monitoring mode provides simple decoding ( Control Change , Note On , Note Off ) for common MIDI messages - Helpful output on missing controllers and incorrect usage - Functions portably as a terminal tool, well-suited for integration with keybindings or scripts in your qtile setup Usage # List all connected MIDI controllers $ midi2cmd.py list # Monitor MIDI messages (raw mode, default controller nanoKONTROL2) $ midi2cmd.py monitor # Monitor a specific controller by name in parsed mode $ midi2cmd.py monitor MyController --mode parsed # Test connection to nanoKONTROL2 $ midi2cmd.py test # Test connection to another controller by name $ midi2cmd.py test MyController You can assign script invocations to qtile keybindings for advanced MIDI-triggered workflows. For persistent monitoring or scripting, run in a terminal or assign to an autostart script with desired arguments. [!TIP] The script currently only interprets a subset of MIDI messages (3-byte standard ones) in parsed mode, so System Exclusive or SysRealtime messages will appear as Unknown messages . For robust controller mapping/automation, you might extend the parsing logic or add script execution on certain MIDI events. The use of run for monitoring MIDI input means it will block until process exit and does not handle continuous streaming efficiently; for real-time usage consider a subprocess with event-driven or line-by-line output handling. Default controller name ( nanoKONTROL2 ) is hardcoded; you might want to make this configurable or load from a preferences file. Only basic error handling: If amidi is missing or ALSA MIDI isn't available, errors may not be friendly. Shebang includes -L uv which may not be universally supported; ensure your environment supports this or replace with a simple Python shebang.","title":"MIDI2CMD Python Utility"},{"location":"scripts/midi2cmd.py/#midi2cmd-python-utility","text":"midi2cmd.py : Manage and monitor MIDI controller input and test connections from the terminal","title":"MIDI2CMD Python Utility"},{"location":"scripts/midi2cmd.py/#dependencies","text":"python (tested with standard Python 3) click ( pip install click ) \u2014 CLI framework for building commands and options amidi (provided by alsa-utils on Arch Linux) \u2014 Command-line MIDI device tool shlex and subprocess \u2014 Standard Python libraries (no extra install needed)","title":"Dependencies"},{"location":"scripts/midi2cmd.py/#description","text":"This script provides a convenient terminal interface to interact with MIDI controllers connected to your system, primarily designed for use on your Arch Linux system with qtile window manager. Core capabilities: - List available MIDI controllers (device names and device IDs) - Monitor MIDI messages from a selected controller, in raw or parsed/human-readable mode - Connection test to verify if a controller device is accessible Command Overview: - Uses the amidi tool for device interrogation and message monitoring - Offers a CLI via the robust click Python package - Default controller is set to nanoKONTROL2 if none specified Highlights: - Parsed monitoring mode provides simple decoding ( Control Change , Note On , Note Off ) for common MIDI messages - Helpful output on missing controllers and incorrect usage - Functions portably as a terminal tool, well-suited for integration with keybindings or scripts in your qtile setup","title":"Description"},{"location":"scripts/midi2cmd.py/#usage","text":"# List all connected MIDI controllers $ midi2cmd.py list # Monitor MIDI messages (raw mode, default controller nanoKONTROL2) $ midi2cmd.py monitor # Monitor a specific controller by name in parsed mode $ midi2cmd.py monitor MyController --mode parsed # Test connection to nanoKONTROL2 $ midi2cmd.py test # Test connection to another controller by name $ midi2cmd.py test MyController You can assign script invocations to qtile keybindings for advanced MIDI-triggered workflows. For persistent monitoring or scripting, run in a terminal or assign to an autostart script with desired arguments. [!TIP] The script currently only interprets a subset of MIDI messages (3-byte standard ones) in parsed mode, so System Exclusive or SysRealtime messages will appear as Unknown messages . For robust controller mapping/automation, you might extend the parsing logic or add script execution on certain MIDI events. The use of run for monitoring MIDI input means it will block until process exit and does not handle continuous streaming efficiently; for real-time usage consider a subprocess with event-driven or line-by-line output handling. Default controller name ( nanoKONTROL2 ) is hardcoded; you might want to make this configurable or load from a preferences file. Only basic error handling: If amidi is missing or ALSA MIDI isn't available, errors may not be friendly. Shebang includes -L uv which may not be universally supported; ensure your environment supports this or replace with a simple Python shebang.","title":"Usage"},{"location":"scripts/minimal-browser.py/","text":"Minimal Python Qt Web Browser minimal-browser.py : Minimal local HTML viewer using PyQt6/QWebEngine, for local docs or apps Dependencies python (>=3.8): Standard Python interpreter. PyQt6 : Python bindings for the Qt6 application framework (including QtWebEngine). PyQt6-WebEngine : Provides the QWebEngineView widget for web content rendering. On Arch Linux: sudo pacman -S python-pyqt6 python-pyqt6-webengine or consider using pip in a virtual environment. Description This script launches a minimalistic web browser using the PyQt6 framework, specifically the QWebEngineView widget. The goal is to offer a lightweight alternative to full-featured browsers for use cases such as: Browsing local web documentation (e.g., Sphinx/Markdown-generated docs) Testing static HTML/JS pages locally Creating streamlined browser windows for local apps Features: - Opens a specified local file (HTML, Markdown rendered as HTML). - If no file is passed via CLI, it defaults to your local Sphinx docs ( /home/matias/git/matias-ceau/pyfiber/docs/_build/html/index.html ). - Simple GUI window, using Qt\u2019s vertical layout. Main components: - QApplication : Manages application control. - SimpleBrowser (QMainWindow): Hosts a QWebEngineView widget. - CLI file argument handling: Loads file from sys.argv[1] if present. Usage From a shell: # Open a specific local HTML file minimal-browser.py /path/to/your/file.html # Open the default page (pyfiber Sphinx docs) minimal-browser.py If you want to bind it to a qtile keybinding (example): Key([mod], \"f1\", lazy.spawn(\"minimal-browser.py ~/docs/index.html\")) You can place this script anywhere in your $PATH for easy access. Make it executable: chmod +x ~/.scripts/bin/minimal-browser.py [!NOTE] - The script currently only loads local files and assumes HTML compatibility. If you pass in a Markdown file, it will not render it correctly unless it has already been converted to HTML. - No navigation (Back/Forward/Reload) or URL bar is provided\u2014this is by design, but if needed, you could easily enhance it with Qt widgets. - There is minimal error handling. If the file path is invalid or the WebEngine components aren\u2019t properly installed, the script may crash. - The script hardcodes a default path. Consider reading a config file or using a dialog for greater flexibility. - The shebang should be #!/usr/bin/env python3 for portability, especially if your system calls python as version 2.x for some reason.","title":"Minimal Python Qt Web Browser"},{"location":"scripts/minimal-browser.py/#minimal-python-qt-web-browser","text":"minimal-browser.py : Minimal local HTML viewer using PyQt6/QWebEngine, for local docs or apps","title":"Minimal Python Qt Web Browser"},{"location":"scripts/minimal-browser.py/#dependencies","text":"python (>=3.8): Standard Python interpreter. PyQt6 : Python bindings for the Qt6 application framework (including QtWebEngine). PyQt6-WebEngine : Provides the QWebEngineView widget for web content rendering. On Arch Linux: sudo pacman -S python-pyqt6 python-pyqt6-webengine or consider using pip in a virtual environment.","title":"Dependencies"},{"location":"scripts/minimal-browser.py/#description","text":"This script launches a minimalistic web browser using the PyQt6 framework, specifically the QWebEngineView widget. The goal is to offer a lightweight alternative to full-featured browsers for use cases such as: Browsing local web documentation (e.g., Sphinx/Markdown-generated docs) Testing static HTML/JS pages locally Creating streamlined browser windows for local apps Features: - Opens a specified local file (HTML, Markdown rendered as HTML). - If no file is passed via CLI, it defaults to your local Sphinx docs ( /home/matias/git/matias-ceau/pyfiber/docs/_build/html/index.html ). - Simple GUI window, using Qt\u2019s vertical layout. Main components: - QApplication : Manages application control. - SimpleBrowser (QMainWindow): Hosts a QWebEngineView widget. - CLI file argument handling: Loads file from sys.argv[1] if present.","title":"Description"},{"location":"scripts/minimal-browser.py/#usage","text":"From a shell: # Open a specific local HTML file minimal-browser.py /path/to/your/file.html # Open the default page (pyfiber Sphinx docs) minimal-browser.py If you want to bind it to a qtile keybinding (example): Key([mod], \"f1\", lazy.spawn(\"minimal-browser.py ~/docs/index.html\")) You can place this script anywhere in your $PATH for easy access. Make it executable: chmod +x ~/.scripts/bin/minimal-browser.py [!NOTE] - The script currently only loads local files and assumes HTML compatibility. If you pass in a Markdown file, it will not render it correctly unless it has already been converted to HTML. - No navigation (Back/Forward/Reload) or URL bar is provided\u2014this is by design, but if needed, you could easily enhance it with Qt widgets. - There is minimal error handling. If the file path is invalid or the WebEngine components aren\u2019t properly installed, the script may crash. - The script hardcodes a default path. Consider reading a config file or using a dialog for greater flexibility. - The shebang should be #!/usr/bin/env python3 for portability, especially if your system calls python as version 2.x for some reason.","title":"Usage"},{"location":"scripts/minimal_gpt_call.py/","text":"Minimal GPT-4o Mini CSV Generation minimal_gpt_call.py : Simple script to interact with OpenAI GPT-4o-mini for CSV sample generation. Dependencies openai Python package to interact with the OpenAI API. Environment variable: OPENAI_API_KEY Must be set in your shell or user environment for authentication. Description This script is a minimal example of making a chat completion request to OpenAI's GPT-4o-mini model using the official openai Python library. It sends a predefined prompt to the chatbot to generate a CSV dataset for 'cow jugglers' containing about 150 rows and 8 columns. Key points: - API key management is handled via the OPENAI_API_KEY environment variable. - The prompt is hardcoded, configured for data generation training purposes. - The script prints the raw completion content, which should be a CSV generated by the model. Usage Step 1: Install dependencies pip install openai Step 2: Set your API key Make sure you have your OPENAI_API_KEY set, for example: export OPENAI_API_KEY=\"sk-...\" Consider adding this to your .profile or shell configuration for persistent use. Step 3: Run the script python /home/matias/.scripts/dev/minimal_gpt_call.py Step 4: Pipe or redirect output if desired python ~/.scripts/dev/minimal_gpt_call.py > cow_jugglers.csv You can map this script to a custom keybinding in Qtile or integrate it with other automation tools as needed. [!TIP] The prompt, model, and system/user roles are hardcoded, making the script inflexible for general use. Consider adding argument parsing (e.g., with argparse) for adjustable model, prompt, and output. Handle API errors (e.g., missing KEY, network issues) with try/except for friendlier diagnostics. Output may contain markdown code blocks or formatting. Post-process the output if you need pure CSV. For large generation jobs (150 lines \u00d7 8 cols), API cost and rate limits should be considered. Consider separating the API key acquisition logic for better security and clarity.","title":"Minimal GPT-4o Mini CSV Generation"},{"location":"scripts/minimal_gpt_call.py/#minimal-gpt-4o-mini-csv-generation","text":"minimal_gpt_call.py : Simple script to interact with OpenAI GPT-4o-mini for CSV sample generation.","title":"Minimal GPT-4o Mini CSV Generation"},{"location":"scripts/minimal_gpt_call.py/#dependencies","text":"openai Python package to interact with the OpenAI API. Environment variable: OPENAI_API_KEY Must be set in your shell or user environment for authentication.","title":"Dependencies"},{"location":"scripts/minimal_gpt_call.py/#description","text":"This script is a minimal example of making a chat completion request to OpenAI's GPT-4o-mini model using the official openai Python library. It sends a predefined prompt to the chatbot to generate a CSV dataset for 'cow jugglers' containing about 150 rows and 8 columns. Key points: - API key management is handled via the OPENAI_API_KEY environment variable. - The prompt is hardcoded, configured for data generation training purposes. - The script prints the raw completion content, which should be a CSV generated by the model.","title":"Description"},{"location":"scripts/minimal_gpt_call.py/#usage","text":"Step 1: Install dependencies pip install openai Step 2: Set your API key Make sure you have your OPENAI_API_KEY set, for example: export OPENAI_API_KEY=\"sk-...\" Consider adding this to your .profile or shell configuration for persistent use. Step 3: Run the script python /home/matias/.scripts/dev/minimal_gpt_call.py Step 4: Pipe or redirect output if desired python ~/.scripts/dev/minimal_gpt_call.py > cow_jugglers.csv You can map this script to a custom keybinding in Qtile or integrate it with other automation tools as needed. [!TIP] The prompt, model, and system/user roles are hardcoded, making the script inflexible for general use. Consider adding argument parsing (e.g., with argparse) for adjustable model, prompt, and output. Handle API errors (e.g., missing KEY, network issues) with try/except for friendlier diagnostics. Output may contain markdown code blocks or formatting. Post-process the output if you need pure CSV. For large generation jobs (150 lines \u00d7 8 cols), API cost and rate limits should be considered. Consider separating the API key acquisition logic for better security and clarity.","title":"Usage"},{"location":"scripts/new_script_creator.sh/","text":"User Script Generator new_script_creator.sh : Quickly create or adapt user scripts with templating and permissions in $SCRIPTS/bin . Dependencies bat : Command-line file viewer with syntax highlighting (also for help text here). rg (ripgrep): Used for extension matching. nvim : For opening/creating scripts with your default editor. utils_update_symlimks.sh : Your local script to update symlinks after script creation/move. wc (coreutils): To count characters for validation. Description This script is a user script \"scaffolder\" designed to simplify and standardize script creation under your personal Arch Linux setup. It's especially convenient when you work heavily with $SCRIPTS/bin and want new scripts to be ready-to-edit, executable, and conveniently symlinked for use in your environment (e.g., with qtile keybindings). Key Features: - Templating: Determines script type ( bash , python , or xonsh ) from filename extension, or prompts if ambiguous. - Safe creation: Prevents empty scripts; validates by minimal character count. - Symlinks: Automatically runs your symlink updater. - Integration: Opens scripts directly in nvim . - Existing scripts: Supports \"importing\" (making executable & moving) existing files into the user scripts directory. Functions: - templater <filename> : Outputs a shebang for supported script extensions. - ensure_extension <filename> : Appends/asks for appropriate extension if missing. - validate_script <path> <name> : Ensures script isn't trivially empty and applies permissions and symlinks. - script_creator <filename> : Orchestrates the template, editor, and validation steps. Usage General form: new_script_creator.sh [script_file_name] | [-f <path>] TLDR Examples Interactive (prompt for filename, choose language): new_script_creator.sh # Prompts: Filename? my_tool # Prompts: [S]hell/[p]ython/[x]onsh? s Direct creation (uses .sh template): new_script_creator.sh hello_world.sh Direct creation with extension prompt: new_script_creator.sh my_utility # Prompts for preferred extension/language Convert and import an existing script: new_script_creator.sh -f /tmp/old_script.sh Help: new_script_creator.sh -h Post-creation, the file is opened for editing in nvim . If saved with more than trivial content, it is automatically made executable and symlinks updated. [!TIP] - The script assumes $SCRIPTS/bin is a valid location and utils_update_symlimks.sh is globally available and properly updates all relevant symlinks. - A minor usability/protection enhancement would be to check if a file with the same name already exists and prompt before overwriting. - User prompts use read which can occasionally break under non-interactive launches (e.g., from rofi-scripts or hotkeys); consider fallback defaults or error messages in such contexts. - The minimal size check ( wc -m \"$1\" > 22 ) could be made more robust or skipped for certain scripts. - The script does not currently support more advanced templating or header generation, which could be beneficial if you desire uniform documentation/footer inserts.","title":"User Script Generator"},{"location":"scripts/new_script_creator.sh/#user-script-generator","text":"new_script_creator.sh : Quickly create or adapt user scripts with templating and permissions in $SCRIPTS/bin .","title":"User Script Generator"},{"location":"scripts/new_script_creator.sh/#dependencies","text":"bat : Command-line file viewer with syntax highlighting (also for help text here). rg (ripgrep): Used for extension matching. nvim : For opening/creating scripts with your default editor. utils_update_symlimks.sh : Your local script to update symlinks after script creation/move. wc (coreutils): To count characters for validation.","title":"Dependencies"},{"location":"scripts/new_script_creator.sh/#description","text":"This script is a user script \"scaffolder\" designed to simplify and standardize script creation under your personal Arch Linux setup. It's especially convenient when you work heavily with $SCRIPTS/bin and want new scripts to be ready-to-edit, executable, and conveniently symlinked for use in your environment (e.g., with qtile keybindings). Key Features: - Templating: Determines script type ( bash , python , or xonsh ) from filename extension, or prompts if ambiguous. - Safe creation: Prevents empty scripts; validates by minimal character count. - Symlinks: Automatically runs your symlink updater. - Integration: Opens scripts directly in nvim . - Existing scripts: Supports \"importing\" (making executable & moving) existing files into the user scripts directory. Functions: - templater <filename> : Outputs a shebang for supported script extensions. - ensure_extension <filename> : Appends/asks for appropriate extension if missing. - validate_script <path> <name> : Ensures script isn't trivially empty and applies permissions and symlinks. - script_creator <filename> : Orchestrates the template, editor, and validation steps.","title":"Description"},{"location":"scripts/new_script_creator.sh/#usage","text":"General form: new_script_creator.sh [script_file_name] | [-f <path>]","title":"Usage"},{"location":"scripts/new_script_creator.sh/#tldr-examples","text":"Interactive (prompt for filename, choose language): new_script_creator.sh # Prompts: Filename? my_tool # Prompts: [S]hell/[p]ython/[x]onsh? s Direct creation (uses .sh template): new_script_creator.sh hello_world.sh Direct creation with extension prompt: new_script_creator.sh my_utility # Prompts for preferred extension/language Convert and import an existing script: new_script_creator.sh -f /tmp/old_script.sh Help: new_script_creator.sh -h Post-creation, the file is opened for editing in nvim . If saved with more than trivial content, it is automatically made executable and symlinks updated. [!TIP] - The script assumes $SCRIPTS/bin is a valid location and utils_update_symlimks.sh is globally available and properly updates all relevant symlinks. - A minor usability/protection enhancement would be to check if a file with the same name already exists and prompt before overwriting. - User prompts use read which can occasionally break under non-interactive launches (e.g., from rofi-scripts or hotkeys); consider fallback defaults or error messages in such contexts. - The minimal size check ( wc -m \"$1\" > 22 ) could be made more robust or skipped for certain scripts. - The script does not currently support more advanced templating or header generation, which could be beneficial if you desire uniform documentation/footer inserts.","title":"TLDR Examples"},{"location":"scripts/next_album.xsh/","text":"Next Album (cmus) next_album.xsh : Skip to the next album in cmus Dependencies xonsh \u2014 runs the .xsh script (Python-powered shell) cmus \u2014 console music player cmus-remote \u2014 command-line control for cmus (bundled with cmus) coreutils \u2014 for cat used by the script qtile \u2014 optional, for keybinding integration on your WM Description This Xonsh script jumps playback to the first track of the next album in your current cmus view. It works by: 1) Switching cmus to view 4. 2) Saving the current view into /tmp/now_playing.m3u. 3) Reading that list, deriving album names from each file\u2019s parent directory. 4) Querying cmus for the currently playing file, inferring its album from its parent directory. 5) Counting how many consecutive tracks belong to the current album, then issuing cmus-remote -n that many times to land on the next album\u2019s first track. It assumes your music library is organized as .../Artist/Album/Track.ext so the parent directory name corresponds to the album. Usage Run directly from a terminal (ensure it\u2019s executable): chmod +x ~/.scripts/bin/next_album.xsh ~/.scripts/bin/next_album.xsh Put it on your PATH (e.g., ~/.scripts/bin is already on PATH) and call: next_album.xsh Qtile keybinding (Arch Linux): # in your config.py from libqtile.config import Key from libqtile.lazy import lazy keys += [ Key([], \"XF86AudioNext\", lazy.spawn(\"~/.scripts/bin/next_album.xsh\")), ] Xonsh alias: aliases['next-album'] = '~/.scripts/bin/next_album.xsh' next-album Requirements: - cmus must be running with an active view (playlist/queue/library). - The view at index 4 should correspond to the list you want to traverse. [!TIP] Potential improvements and caveats: - Assumes album equals the parent directory of the file. If your library is flat or organized differently, use tags instead (e.g., parse cmus-remote -Q for tag album or use cmus-remote -C 'format_print %l'). - cmus-remote -Q indexing relies on the second line being file. More robust: parse the line starting with file or tag album. - View 4 may not be what you expect if views are customized. Consider saving the current playlist explicitly (e.g., save -p) if that matches your workflow. - Use a unique temp file (mktemp) and clean it up. - Add error handling for when cmus isn\u2019t running or /tmp/now_playing.m3u is empty.","title":"Next Album (cmus)"},{"location":"scripts/next_album.xsh/#next-album-cmus","text":"next_album.xsh : Skip to the next album in cmus","title":"Next Album (cmus)"},{"location":"scripts/next_album.xsh/#dependencies","text":"xonsh \u2014 runs the .xsh script (Python-powered shell) cmus \u2014 console music player cmus-remote \u2014 command-line control for cmus (bundled with cmus) coreutils \u2014 for cat used by the script qtile \u2014 optional, for keybinding integration on your WM","title":"Dependencies"},{"location":"scripts/next_album.xsh/#description","text":"This Xonsh script jumps playback to the first track of the next album in your current cmus view. It works by: 1) Switching cmus to view 4. 2) Saving the current view into /tmp/now_playing.m3u. 3) Reading that list, deriving album names from each file\u2019s parent directory. 4) Querying cmus for the currently playing file, inferring its album from its parent directory. 5) Counting how many consecutive tracks belong to the current album, then issuing cmus-remote -n that many times to land on the next album\u2019s first track. It assumes your music library is organized as .../Artist/Album/Track.ext so the parent directory name corresponds to the album.","title":"Description"},{"location":"scripts/next_album.xsh/#usage","text":"Run directly from a terminal (ensure it\u2019s executable): chmod +x ~/.scripts/bin/next_album.xsh ~/.scripts/bin/next_album.xsh Put it on your PATH (e.g., ~/.scripts/bin is already on PATH) and call: next_album.xsh Qtile keybinding (Arch Linux): # in your config.py from libqtile.config import Key from libqtile.lazy import lazy keys += [ Key([], \"XF86AudioNext\", lazy.spawn(\"~/.scripts/bin/next_album.xsh\")), ] Xonsh alias: aliases['next-album'] = '~/.scripts/bin/next_album.xsh' next-album Requirements: - cmus must be running with an active view (playlist/queue/library). - The view at index 4 should correspond to the list you want to traverse. [!TIP] Potential improvements and caveats: - Assumes album equals the parent directory of the file. If your library is flat or organized differently, use tags instead (e.g., parse cmus-remote -Q for tag album or use cmus-remote -C 'format_print %l'). - cmus-remote -Q indexing relies on the second line being file. More robust: parse the line starting with file or tag album. - View 4 may not be what you expect if views are customized. Consider saving the current playlist explicitly (e.g., save -p) if that matches your workflow. - Use a unique temp file (mktemp) and clean it up. - Add error handling for when cmus isn\u2019t running or /tmp/now_playing.m3u is empty.","title":"Usage"},{"location":"scripts/nvim_in_new_terminal.sh/","text":"nvim in Floating Terminal nvim_in_new_terminal.sh : Open a file in nvim inside a floating Alacritty terminal window Dependencies alacritty : GPU-accelerated terminal emulator for X11/Wayland. nvim (Neovim): Modern Vim-based text editor, used for file editing. setsid : Run a program in a new session (standard GNU tool). A window manager (e.g., qtile ) with rules for the \"floating\" window class. \u2192 Requires custom window rules for \"floating\" to ensure desired appearance. Description This script provides a convenient way to open any file in nvim within a floating terminal window by leveraging alacritty and qtile's window management. The key components are: setsid : Guarantees the spawned terminal runs in a new session, preventing it from being tied to the parent shell or session. alacritty : Launched with the title nvim-term and a custom X11/WM class of floating . The -e flag starts nvim on the file specified by the first argument ($1). The \"floating\" class allows qtile to apply dedicated rules (e.g., always start as floating, centered), providing optimal integration. Typical uses: - Launch from a keybinding to quickly edit configuration files, scripts, etc., in a distraction-free floating terminal. - Easily adaptable for use by other scripts that need floating editing functionality. Usage The script can be executed directly from a terminal or integrated into qtile or other WM keybindings. Command-line: nvim_in_new_terminal.sh <path/to/file> Examples: nvim_in_new_terminal.sh ~/.config/qtile/config.py nvim_in_new_terminal.sh /tmp/notes.txt Qtile Keybinding Example : In your qtile config.py (after ensuring the script is executable and on your PATH): Key([mod], \"e\", lazy.spawn(\"nvim_in_new_terminal.sh ~/.local/todo.txt\")), Note: For best results, ensure qtile floating rules are set for the 'floating' class, e.g.: @hook.subscribe.client_new def set_floating(window): if window.window.get_wm_class() and 'floating' in window.window.get_wm_class(): window.floating = True [!TIP] Potential Issues & Suggestions: The script will silently do nothing if no file argument is given. Consider adding input validation to check for an argument and display a usage message if missing. It assumes both alacritty and nvim are in the PATH and available. Adding checks for dependencies could improve robustness. The \"floating\" class requires a matching window rule in qtile . If this is missing or misconfigured, the terminal may not float as expected. Does not handle the case where multiple words/spaces are present in the filename; quoting is correct but further validation could be helpful. For improvement: Allow passing additional arguments to nvim .","title":"nvim in Floating Terminal"},{"location":"scripts/nvim_in_new_terminal.sh/#nvim-in-floating-terminal","text":"nvim_in_new_terminal.sh : Open a file in nvim inside a floating Alacritty terminal window","title":"nvim in Floating Terminal"},{"location":"scripts/nvim_in_new_terminal.sh/#dependencies","text":"alacritty : GPU-accelerated terminal emulator for X11/Wayland. nvim (Neovim): Modern Vim-based text editor, used for file editing. setsid : Run a program in a new session (standard GNU tool). A window manager (e.g., qtile ) with rules for the \"floating\" window class. \u2192 Requires custom window rules for \"floating\" to ensure desired appearance.","title":"Dependencies"},{"location":"scripts/nvim_in_new_terminal.sh/#description","text":"This script provides a convenient way to open any file in nvim within a floating terminal window by leveraging alacritty and qtile's window management. The key components are: setsid : Guarantees the spawned terminal runs in a new session, preventing it from being tied to the parent shell or session. alacritty : Launched with the title nvim-term and a custom X11/WM class of floating . The -e flag starts nvim on the file specified by the first argument ($1). The \"floating\" class allows qtile to apply dedicated rules (e.g., always start as floating, centered), providing optimal integration. Typical uses: - Launch from a keybinding to quickly edit configuration files, scripts, etc., in a distraction-free floating terminal. - Easily adaptable for use by other scripts that need floating editing functionality.","title":"Description"},{"location":"scripts/nvim_in_new_terminal.sh/#usage","text":"The script can be executed directly from a terminal or integrated into qtile or other WM keybindings. Command-line: nvim_in_new_terminal.sh <path/to/file> Examples: nvim_in_new_terminal.sh ~/.config/qtile/config.py nvim_in_new_terminal.sh /tmp/notes.txt Qtile Keybinding Example : In your qtile config.py (after ensuring the script is executable and on your PATH): Key([mod], \"e\", lazy.spawn(\"nvim_in_new_terminal.sh ~/.local/todo.txt\")), Note: For best results, ensure qtile floating rules are set for the 'floating' class, e.g.: @hook.subscribe.client_new def set_floating(window): if window.window.get_wm_class() and 'floating' in window.window.get_wm_class(): window.floating = True [!TIP] Potential Issues & Suggestions: The script will silently do nothing if no file argument is given. Consider adding input validation to check for an argument and display a usage message if missing. It assumes both alacritty and nvim are in the PATH and available. Adding checks for dependencies could improve robustness. The \"floating\" class requires a matching window rule in qtile . If this is missing or misconfigured, the terminal may not float as expected. Does not handle the case where multiple words/spaces are present in the filename; quoting is correct but further validation could be helpful. For improvement: Allow passing additional arguments to nvim .","title":"Usage"},{"location":"scripts/nvpn-tui-help.sh/","text":"NordVPN TUI Helper (and Generic CLI TUI Helper) nvpn-tui-help.sh : Interactive terminal UI for navigating nordvpn (or other CLI programs) commands and help. Dependencies fzf \u2014 Fuzzy finder for command selection (core interactive interface). bat \u2014 Previewer for highlighting help texts. sed \u2014 Simple text transformations. bash \u2014 The script uses associative arrays, function definitions, and arrays. nordvpn (default), or optionally: docker , kubectl , git \u2014 The CLI your are targeting. (Optional but recommended): Make sure the CLI you target supports either --generate-bash-completion , --completion , or similar. Description This script creates a powerful TUI (Text User Interface) for interactively navigating the sub-commands and help content of CLI programs (mainly designed for nordvpn , but also supports docker , kubectl , git , or any suitably completable tool). Main Features: Command Exploration: Visual, keyboard-driven navigation through the command tree of the underlying CLI using fzf . Live Previews: See the help message for each command/sub-command in real time (right-hand pane) via bat for coloring. Get further auto-completion options for nested sub-commands (deep dives). Command History/Backtracking: Ability to walk up and down the command tree\u2014go back with \".. (back)\". Multi-Program Support: Can target any CLI with a completion script ( nordvpn , docker , kubectl , git supported out of the box). Keyboard Shortcuts: Scroll previews, toggle preview wrap, reload completions, and more (see --bind options in fzf ). How It Works The script uses specified CLI completion mechanisms to generate a list of possible sub-commands or options. It calls fzf to create an interactive menu based on those completions. Selecting an option drills down to the next level, with live help and suggested sub-commands/flags visible in the preview. The command you preview is actually constructed live ( $program $current_cmd $selection ). You can always go \"back\" to the previous command step. Usage Basic usage (for nordvpn): bash /home/matias/.scripts/bin/nvpn-tui-help.sh Target another supported program (e.g., docker): bash /home/matias/.scripts/bin/nvpn-tui-help.sh docker TL;DR summary: nvpn-tui-help.sh [program] # Start a TUI for the program (default: nordvpn) # - Use FZF keys to select commands, scroll help previews, reload completions, toggle preview wrap # - \".. (back)\" to go back up the command hierarchy # - Enter on an option drills down, showing more sub-commands/help if available. This script is ideal to assign to a keybinding in Qtile or run as a launcher to get live help/completion for your CLI tools. [!TIP] Critique: - The script assumes compatible completion flags for target CLIs\u2014adding more robust detection or documentation for new tools would improve reliability. - Dependency on bat for preview is not optional\u2014add fallback to cat if not present. - May run into issues with very deep command trees or unusual CLI tools. - State/history preservation is session-limited, and the interface could be further streamlined if using fzf 's custom preview bindings more extensively. - Consider making help previews adjustable for long outputs or allow toggling raw/manual mode. - Error handling could be more explicit if the completion/help flags fail ( $program $completion_flag might not always succeed).","title":"NordVPN TUI Helper (and Generic CLI TUI Helper)"},{"location":"scripts/nvpn-tui-help.sh/#nordvpn-tui-helper-and-generic-cli-tui-helper","text":"nvpn-tui-help.sh : Interactive terminal UI for navigating nordvpn (or other CLI programs) commands and help.","title":"NordVPN TUI Helper (and Generic CLI TUI Helper)"},{"location":"scripts/nvpn-tui-help.sh/#dependencies","text":"fzf \u2014 Fuzzy finder for command selection (core interactive interface). bat \u2014 Previewer for highlighting help texts. sed \u2014 Simple text transformations. bash \u2014 The script uses associative arrays, function definitions, and arrays. nordvpn (default), or optionally: docker , kubectl , git \u2014 The CLI your are targeting. (Optional but recommended): Make sure the CLI you target supports either --generate-bash-completion , --completion , or similar.","title":"Dependencies"},{"location":"scripts/nvpn-tui-help.sh/#description","text":"This script creates a powerful TUI (Text User Interface) for interactively navigating the sub-commands and help content of CLI programs (mainly designed for nordvpn , but also supports docker , kubectl , git , or any suitably completable tool). Main Features: Command Exploration: Visual, keyboard-driven navigation through the command tree of the underlying CLI using fzf . Live Previews: See the help message for each command/sub-command in real time (right-hand pane) via bat for coloring. Get further auto-completion options for nested sub-commands (deep dives). Command History/Backtracking: Ability to walk up and down the command tree\u2014go back with \".. (back)\". Multi-Program Support: Can target any CLI with a completion script ( nordvpn , docker , kubectl , git supported out of the box). Keyboard Shortcuts: Scroll previews, toggle preview wrap, reload completions, and more (see --bind options in fzf ).","title":"Description"},{"location":"scripts/nvpn-tui-help.sh/#how-it-works","text":"The script uses specified CLI completion mechanisms to generate a list of possible sub-commands or options. It calls fzf to create an interactive menu based on those completions. Selecting an option drills down to the next level, with live help and suggested sub-commands/flags visible in the preview. The command you preview is actually constructed live ( $program $current_cmd $selection ). You can always go \"back\" to the previous command step.","title":"How It Works"},{"location":"scripts/nvpn-tui-help.sh/#usage","text":"Basic usage (for nordvpn): bash /home/matias/.scripts/bin/nvpn-tui-help.sh Target another supported program (e.g., docker): bash /home/matias/.scripts/bin/nvpn-tui-help.sh docker TL;DR summary: nvpn-tui-help.sh [program] # Start a TUI for the program (default: nordvpn) # - Use FZF keys to select commands, scroll help previews, reload completions, toggle preview wrap # - \".. (back)\" to go back up the command hierarchy # - Enter on an option drills down, showing more sub-commands/help if available. This script is ideal to assign to a keybinding in Qtile or run as a launcher to get live help/completion for your CLI tools. [!TIP] Critique: - The script assumes compatible completion flags for target CLIs\u2014adding more robust detection or documentation for new tools would improve reliability. - Dependency on bat for preview is not optional\u2014add fallback to cat if not present. - May run into issues with very deep command trees or unusual CLI tools. - State/history preservation is session-limited, and the interface could be further streamlined if using fzf 's custom preview bindings more extensively. - Consider making help previews adjustable for long outputs or allow toggling raw/manual mode. - Error handling could be more explicit if the completion/help flags fail ( $program $completion_flag might not always succeed).","title":"Usage"},{"location":"scripts/obsidian-vault-selector.sh/","text":"Obsidian Vault Selector (fzf-driven) obsidian-vault-selector.sh : Select and open Obsidian vaults with preview and search Dependencies obsidian \u2014 desktop app CLI; handles obsidian:// links on Arch jq \u2014 parse vault paths from Obsidian config eza \u2014 colorful ls and tree previews ripgrep ( rg ) \u2014 filter preview noise bat \u2014 style the tree preview improved-fzfmenu.sh \u2014 your fzf wrapper; used for selection UI libnotify ( notify-send ) \u2014 user feedback when nothing is selected util-linux ( setsid ) \u2014 detach the launcher process bash , awk , sed \u2014 shell utilities Obsidian config: $XDG_CONFIG_HOME/obsidian/obsidian.json Description This script discovers your Obsidian vaults from Obsidian\u2019s config file, presents them in an fzf-based menu, and opens the chosen vault via Obsidian\u2019s deep-link scheme. Flow: - Fetch vault directories from $XDG_CONFIG_HOME/obsidian/obsidian.json using jq , then normalize via eza --stdin . - Show an interactive picker ( improved-fzfmenu.sh ) listing only the last path segment (vault name) while keeping the full path for operations. - Live preview blends: - eza -la for a detailed top-level listing, and - a colorized eza -T tree, filtered by rg to hide noisy binaries, then prettified with bat . - On selection, derive the vault name from the path and open it with obsidian obsidian://open?vault=<name> in a detached session ( setsid ). If nothing is selected, a notify-send message appears. Usage Run interactively: ~/.scripts/bin/obsidian-vault-selector.sh Use arrows or type to fuzzy-search; Enter opens the highlighted vault. Bind to a qtile key: # in config.py from libqtile.lazy import lazy Key([mod], \"o\", lazy.spawn(\"~/.scripts/bin/obsidian-vault-selector.sh\")), TL;DR obsidian-vault-selector.sh # pick a vault \u2192 opens in Obsidian Notes: - Ensure $XDG_CONFIG_HOME is set (commonly ~/.config on Arch). - improved-fzfmenu.sh must be in PATH and compatible with your terminal setup. [!TIP] - Deep link ambiguity: vaults are opened by name. If two vaults share the same name, the wrong one might open. Prefer obsidian://open?path=<abs_path> with proper URL encoding. - URL encoding: vault names/paths with spaces should be encoded. Consider jq -sRr @uri or python -c 'import urllib.parse,sys;print(urllib.parse.quote(sys.argv[1]))' . - Robustness: quote $XDG_CONFIG_HOME and the config path; handle missing/invalid obsidian.json . - Preview performance: large vaults may slow previews. Consider limiting tree depth ( eza -T -L 2 ). - Portability: eza --stdin behavior can vary; a safer approach is while read -r p; do echo \"$p\"; done . Add set -euo pipefail and run shellcheck for diagnostics.","title":"Obsidian Vault Selector (fzf-driven)"},{"location":"scripts/obsidian-vault-selector.sh/#obsidian-vault-selector-fzf-driven","text":"obsidian-vault-selector.sh : Select and open Obsidian vaults with preview and search","title":"Obsidian Vault Selector (fzf-driven)"},{"location":"scripts/obsidian-vault-selector.sh/#dependencies","text":"obsidian \u2014 desktop app CLI; handles obsidian:// links on Arch jq \u2014 parse vault paths from Obsidian config eza \u2014 colorful ls and tree previews ripgrep ( rg ) \u2014 filter preview noise bat \u2014 style the tree preview improved-fzfmenu.sh \u2014 your fzf wrapper; used for selection UI libnotify ( notify-send ) \u2014 user feedback when nothing is selected util-linux ( setsid ) \u2014 detach the launcher process bash , awk , sed \u2014 shell utilities Obsidian config: $XDG_CONFIG_HOME/obsidian/obsidian.json","title":"Dependencies"},{"location":"scripts/obsidian-vault-selector.sh/#description","text":"This script discovers your Obsidian vaults from Obsidian\u2019s config file, presents them in an fzf-based menu, and opens the chosen vault via Obsidian\u2019s deep-link scheme. Flow: - Fetch vault directories from $XDG_CONFIG_HOME/obsidian/obsidian.json using jq , then normalize via eza --stdin . - Show an interactive picker ( improved-fzfmenu.sh ) listing only the last path segment (vault name) while keeping the full path for operations. - Live preview blends: - eza -la for a detailed top-level listing, and - a colorized eza -T tree, filtered by rg to hide noisy binaries, then prettified with bat . - On selection, derive the vault name from the path and open it with obsidian obsidian://open?vault=<name> in a detached session ( setsid ). If nothing is selected, a notify-send message appears.","title":"Description"},{"location":"scripts/obsidian-vault-selector.sh/#usage","text":"Run interactively: ~/.scripts/bin/obsidian-vault-selector.sh Use arrows or type to fuzzy-search; Enter opens the highlighted vault. Bind to a qtile key: # in config.py from libqtile.lazy import lazy Key([mod], \"o\", lazy.spawn(\"~/.scripts/bin/obsidian-vault-selector.sh\")), TL;DR obsidian-vault-selector.sh # pick a vault \u2192 opens in Obsidian Notes: - Ensure $XDG_CONFIG_HOME is set (commonly ~/.config on Arch). - improved-fzfmenu.sh must be in PATH and compatible with your terminal setup. [!TIP] - Deep link ambiguity: vaults are opened by name. If two vaults share the same name, the wrong one might open. Prefer obsidian://open?path=<abs_path> with proper URL encoding. - URL encoding: vault names/paths with spaces should be encoded. Consider jq -sRr @uri or python -c 'import urllib.parse,sys;print(urllib.parse.quote(sys.argv[1]))' . - Robustness: quote $XDG_CONFIG_HOME and the config path; handle missing/invalid obsidian.json . - Preview performance: large vaults may slow previews. Consider limiting tree depth ( eza -T -L 2 ). - Portability: eza --stdin behavior can vary; a safer approach is while read -r p; do echo \"$p\"; done . Add set -euo pipefail and run shellcheck for diagnostics.","title":"Usage"},{"location":"scripts/obsidian.xsh/","text":"Obsidian Vault Launcher obsidian.xsh : Quickly select and open an Obsidian vault via a fuzzy menu Dependencies xonsh Required as the script runs under the xonsh shell. obsidian Assumes the obsidian protocol handler is installed and working (usually provided by the official AppImage or native package). fzfmenu.sh Script or wrapper to invoke fzf with dmenu-like options, and must be in your $PATH . eza Used for the vault preview inside fzfmenu.sh ( eza -T gives a directory tree). notify-send For desktop notifications when no vault is selected. Description This script streamlines the process of opening an Obsidian vault by: Listing all the directories under ~/PKM (your Personal Knowledge Management folder) \u2014 each directory is treated as a vault. Allowing you to interactively select a vault using an interactive fuzzy finder ( fzfmenu.sh ). For each directory, it shows a live preview using eza , so you can inspect vaults before selecting. Once a vault is chosen, it opens the vault using the Obsidian URL scheme ( obsidian://open?vault=... ). If you cancel the selection, a notification is shown. Key implementation details Xonsh-powered: takes full advantage of Python scripting and shell syntax. Directory-only filtering: Only shows directories in ~/PKM , preventing non-vault files from cluttering the menu. fzfmenu.sh : Customizes the fuzzy selection menu and shows pretty previews via eza . Usage You can run this script from your terminal, or (recommended) assign it to a keybinding in your qtile config for lightning-quick vault launching. Manual usage (from terminal): xonsh ~/.scripts/bin/obsidian.xsh Assign to qtile keybinding (example): Key([mod], \"o\", lazy.spawn(\"xonsh ~/.scripts/bin/obsidian.xsh\")) TL;DR Run the script. Fuzzy-select a vault (with directory tree preview). It automatically opens in Obsidian, or you get notified if cancelled. [!TIP] - The script is concise and well-focused, but does not currently handle names with spaces robustly (if your vault has spaces or unusual characters in the name, URL-encoding may be needed for the Obsidian protocol). - As a small improvement, consider adding error checking for missing dependencies (e.g., fzfmenu.sh , obsidian , eza , notify-send ) to provide more user-friendly diagnostics if called from outside an interactive shell. - You might want to parametrize the vaults folder instead of hardcoding $HOME/PKM for flexibility. - The commented-out dmenu section is obsolete, so it can be removed to tidy the script. Also, supporting native dmenu in addition to fzf could improve platform versatility. - For large PKM directories, previewing with eza -T could be slow; consider limiting depth or adding an option for speed.","title":"Obsidian Vault Launcher"},{"location":"scripts/obsidian.xsh/#obsidian-vault-launcher","text":"obsidian.xsh : Quickly select and open an Obsidian vault via a fuzzy menu","title":"Obsidian Vault Launcher"},{"location":"scripts/obsidian.xsh/#dependencies","text":"xonsh Required as the script runs under the xonsh shell. obsidian Assumes the obsidian protocol handler is installed and working (usually provided by the official AppImage or native package). fzfmenu.sh Script or wrapper to invoke fzf with dmenu-like options, and must be in your $PATH . eza Used for the vault preview inside fzfmenu.sh ( eza -T gives a directory tree). notify-send For desktop notifications when no vault is selected.","title":"Dependencies"},{"location":"scripts/obsidian.xsh/#description","text":"This script streamlines the process of opening an Obsidian vault by: Listing all the directories under ~/PKM (your Personal Knowledge Management folder) \u2014 each directory is treated as a vault. Allowing you to interactively select a vault using an interactive fuzzy finder ( fzfmenu.sh ). For each directory, it shows a live preview using eza , so you can inspect vaults before selecting. Once a vault is chosen, it opens the vault using the Obsidian URL scheme ( obsidian://open?vault=... ). If you cancel the selection, a notification is shown.","title":"Description"},{"location":"scripts/obsidian.xsh/#key-implementation-details","text":"Xonsh-powered: takes full advantage of Python scripting and shell syntax. Directory-only filtering: Only shows directories in ~/PKM , preventing non-vault files from cluttering the menu. fzfmenu.sh : Customizes the fuzzy selection menu and shows pretty previews via eza .","title":"Key implementation details"},{"location":"scripts/obsidian.xsh/#usage","text":"You can run this script from your terminal, or (recommended) assign it to a keybinding in your qtile config for lightning-quick vault launching.","title":"Usage"},{"location":"scripts/obsidian.xsh/#manual-usage-from-terminal","text":"xonsh ~/.scripts/bin/obsidian.xsh","title":"Manual usage (from terminal):"},{"location":"scripts/obsidian.xsh/#assign-to-qtile-keybinding-example","text":"Key([mod], \"o\", lazy.spawn(\"xonsh ~/.scripts/bin/obsidian.xsh\"))","title":"Assign to qtile keybinding (example):"},{"location":"scripts/obsidian.xsh/#tldr","text":"Run the script. Fuzzy-select a vault (with directory tree preview). It automatically opens in Obsidian, or you get notified if cancelled. [!TIP] - The script is concise and well-focused, but does not currently handle names with spaces robustly (if your vault has spaces or unusual characters in the name, URL-encoding may be needed for the Obsidian protocol). - As a small improvement, consider adding error checking for missing dependencies (e.g., fzfmenu.sh , obsidian , eza , notify-send ) to provide more user-friendly diagnostics if called from outside an interactive shell. - You might want to parametrize the vaults folder instead of hardcoding $HOME/PKM for flexibility. - The commented-out dmenu section is obsolete, so it can be removed to tidy the script. Also, supporting native dmenu in addition to fzf could improve platform versatility. - For large PKM directories, previewing with eza -T could be slow; consider limiting depth or adding an option for speed.","title":"TL;DR"},{"location":"scripts/old-ousse/","text":"Ousse Indexing Database Generator old-ousse : Generates a collection of custom mlocate databases for various areas of your filesystem Dependencies updatedb Core binary used to create the locate databases (typically from mlocate or plocate ). fd Efficient file finder used for directory selection and filtering. rg Ripgrep: used for fast pattern filtering. sed , tr , cut , dirname , realpath Standard UNIX utilities for string and file path manipulation. mega-sync Used specifically for Mega cloud folder location. Environment variable: $XDG_DATA_HOME Description This script is designed for Arch Linux (with qtile or other WMs), and builds multiple custom mlocate-compatible databases targeting specific folders and data types: home.db \u2014 Indexes the home directory, skipping /tmp . dots.db \u2014 Home directory minus most \"dot\" folders (dynamic exclusion based on folder listing). data.db \u2014 /mnt hierarchy, with complex prunenames and prunepaths for precise control (mainly excludes specific non-data directories). root.db \u2014 The entire root filesystem with many system and temp directories pruned, to reduce noise. mega.db \u2014 Index for a UnifiedLibrary in Mega, automatically determines path. devices.db \u2014 Index of 'devices' folder within Mega backups, determined dynamically. limbo.db \u2014 Custom \u201cLIMBO\u201d folder under /mnt , auto-located. hdd2.db \u2014 Indexes entire /mnt/HDD2 ; skips bind mounts. Each .db file ends up in $XDG_DATA_HOME/ousse/<name>.db . Many prunenames/prunepaths are dynamically constructed for flexibility, especially for personal folder layouts. Usage Run the script without arguments, ideally in a terminal: ~/.scripts/dev/old-ousse You may want to set up a keybinding or automated timer in qtile to run it periodically. To inspect a created database, use: locate -d $XDG_DATA_HOME/ousse/home.db somefile Schedule in cron or systemd for regular updates. [!TIP] Critique: - Script is powerful but brittle: directory/folder names are tightly coupled to your layout (e.g., $HOME/UnifiedLibrary , /mnt/HDD2 , presence of Mega/cloud folders). - Some commands (like fd , rg , and others) could fail silently if a folder is renamed, missing, or if packages are not installed. - Error handling is absent; failures may go unnoticed. Consider adding set -e , and some echo statements for progress and debugging. - Using mlocate / updatedb as a regular user for indexing system paths ( / ) could miss files with restricted permissions. - The reliance on environment variables ( $XDG_DATA_HOME ) and Mega backend assumes these are properly initialized. - Refactoring into functions would greatly improve readability and maintainability. For your use case, this is an extremely effective and highly customizable approach, but keep in mind these caveats if system structure changes.","title":"Ousse Indexing Database Generator"},{"location":"scripts/old-ousse/#ousse-indexing-database-generator","text":"old-ousse : Generates a collection of custom mlocate databases for various areas of your filesystem","title":"Ousse Indexing Database Generator"},{"location":"scripts/old-ousse/#dependencies","text":"updatedb Core binary used to create the locate databases (typically from mlocate or plocate ). fd Efficient file finder used for directory selection and filtering. rg Ripgrep: used for fast pattern filtering. sed , tr , cut , dirname , realpath Standard UNIX utilities for string and file path manipulation. mega-sync Used specifically for Mega cloud folder location. Environment variable: $XDG_DATA_HOME","title":"Dependencies"},{"location":"scripts/old-ousse/#description","text":"This script is designed for Arch Linux (with qtile or other WMs), and builds multiple custom mlocate-compatible databases targeting specific folders and data types: home.db \u2014 Indexes the home directory, skipping /tmp . dots.db \u2014 Home directory minus most \"dot\" folders (dynamic exclusion based on folder listing). data.db \u2014 /mnt hierarchy, with complex prunenames and prunepaths for precise control (mainly excludes specific non-data directories). root.db \u2014 The entire root filesystem with many system and temp directories pruned, to reduce noise. mega.db \u2014 Index for a UnifiedLibrary in Mega, automatically determines path. devices.db \u2014 Index of 'devices' folder within Mega backups, determined dynamically. limbo.db \u2014 Custom \u201cLIMBO\u201d folder under /mnt , auto-located. hdd2.db \u2014 Indexes entire /mnt/HDD2 ; skips bind mounts. Each .db file ends up in $XDG_DATA_HOME/ousse/<name>.db . Many prunenames/prunepaths are dynamically constructed for flexibility, especially for personal folder layouts.","title":"Description"},{"location":"scripts/old-ousse/#usage","text":"Run the script without arguments, ideally in a terminal: ~/.scripts/dev/old-ousse You may want to set up a keybinding or automated timer in qtile to run it periodically. To inspect a created database, use: locate -d $XDG_DATA_HOME/ousse/home.db somefile Schedule in cron or systemd for regular updates. [!TIP] Critique: - Script is powerful but brittle: directory/folder names are tightly coupled to your layout (e.g., $HOME/UnifiedLibrary , /mnt/HDD2 , presence of Mega/cloud folders). - Some commands (like fd , rg , and others) could fail silently if a folder is renamed, missing, or if packages are not installed. - Error handling is absent; failures may go unnoticed. Consider adding set -e , and some echo statements for progress and debugging. - Using mlocate / updatedb as a regular user for indexing system paths ( / ) could miss files with restricted permissions. - The reliance on environment variables ( $XDG_DATA_HOME ) and Mega backend assumes these are properly initialized. - Refactoring into functions would greatly improve readability and maintainability. For your use case, this is an extremely effective and highly customizable approach, but keep in mind these caveats if system structure changes.","title":"Usage"},{"location":"scripts/ollama-list.sh/","text":"Ollama model list (cached, LLM-formatted) ollama-list.sh : Fetches and caches a formatted list of Ollama models via LLM Dependencies bash \u2014 shell runtime curl \u2014 fetch HTML from the Ollama Library page pandoc \u2014 convert HTML to plain text before LLM processing aichat \u2014 CLI to query an LLM (configured for Groq; uses --model ) coreutils \u2014 mkdir , cat , date for caching Description This script scrapes the Ollama Library page (default: https://ollama.com/library?sort=popular), converts the HTML to plain text with pandoc , and asks an LLM (via aichat ) to return \u201ca nicely formatted list of all these models.\u201d Results are cached under: - Cache dir: ~/.cache/model_list - Files: response_cache.txt , cache_timestamp.txt - TTL: 7 days If a valid cache exists, it\u2019s printed immediately; otherwise, a fresh fetch is performed and cached. You can override the source URL and the LLM model, or bypass the cache entirely. Arch/qtile context: this works well as a terminal command or bound to a qtile key to pop up a quick, readable model list in your terminal emulator. Usage Basic (use cache if fresh): ~/.scripts/bin/ollama-list.sh Force refresh (ignore cache): ~/.scripts/bin/ollama-list.sh --no-cache Custom LLM model (Groq via aichat): ~/.scripts/bin/ollama-list.sh --model \"groq:llama-3.3-70b-versatile\" Custom source URL (e.g., different sort/filter): ~/.scripts/bin/ollama-list.sh --url \"https://ollama.com/library?sort=new\" qtile keybinding example (spawn in kitty, no cache): Key([mod], \"o\", lazy.spawn(\"kitty -e /home/matias/.scripts/bin/ollama-list.sh --no-cache\")) tldr: # fresh list now ollama-list.sh --no-cache # tweak LLM ollama-list.sh --model \"groq:llama-3.1-70b\" # inspect different page ollama-list.sh --url \"https://ollama.com/library?sort=trending\" [!TIP] - Add error handling: check exit codes for curl , pandoc , and aichat ; fail fast with helpful messages. - Consider a --max-age DAYS flag to adjust TTL without editing the script. - Provide --help output and accept -h . - Guard against concurrent writes to the cache (use a lockfile). - The LLM prompt is vague; a deterministic parser (e.g., pup , hxselect , or jq if you find an API) would be more stable. - Validate aichat stdin behavior; if not supported, pass the page text via a --input / -f option or rework the prompt.","title":"Ollama model list (cached, LLM-formatted)"},{"location":"scripts/ollama-list.sh/#ollama-model-list-cached-llm-formatted","text":"ollama-list.sh : Fetches and caches a formatted list of Ollama models via LLM","title":"Ollama model list (cached, LLM-formatted)"},{"location":"scripts/ollama-list.sh/#dependencies","text":"bash \u2014 shell runtime curl \u2014 fetch HTML from the Ollama Library page pandoc \u2014 convert HTML to plain text before LLM processing aichat \u2014 CLI to query an LLM (configured for Groq; uses --model ) coreutils \u2014 mkdir , cat , date for caching","title":"Dependencies"},{"location":"scripts/ollama-list.sh/#description","text":"This script scrapes the Ollama Library page (default: https://ollama.com/library?sort=popular), converts the HTML to plain text with pandoc , and asks an LLM (via aichat ) to return \u201ca nicely formatted list of all these models.\u201d Results are cached under: - Cache dir: ~/.cache/model_list - Files: response_cache.txt , cache_timestamp.txt - TTL: 7 days If a valid cache exists, it\u2019s printed immediately; otherwise, a fresh fetch is performed and cached. You can override the source URL and the LLM model, or bypass the cache entirely. Arch/qtile context: this works well as a terminal command or bound to a qtile key to pop up a quick, readable model list in your terminal emulator.","title":"Description"},{"location":"scripts/ollama-list.sh/#usage","text":"Basic (use cache if fresh): ~/.scripts/bin/ollama-list.sh Force refresh (ignore cache): ~/.scripts/bin/ollama-list.sh --no-cache Custom LLM model (Groq via aichat): ~/.scripts/bin/ollama-list.sh --model \"groq:llama-3.3-70b-versatile\" Custom source URL (e.g., different sort/filter): ~/.scripts/bin/ollama-list.sh --url \"https://ollama.com/library?sort=new\" qtile keybinding example (spawn in kitty, no cache): Key([mod], \"o\", lazy.spawn(\"kitty -e /home/matias/.scripts/bin/ollama-list.sh --no-cache\")) tldr: # fresh list now ollama-list.sh --no-cache # tweak LLM ollama-list.sh --model \"groq:llama-3.1-70b\" # inspect different page ollama-list.sh --url \"https://ollama.com/library?sort=trending\" [!TIP] - Add error handling: check exit codes for curl , pandoc , and aichat ; fail fast with helpful messages. - Consider a --max-age DAYS flag to adjust TTL without editing the script. - Provide --help output and accept -h . - Guard against concurrent writes to the cache (use a lockfile). - The LLM prompt is vague; a deterministic parser (e.g., pup , hxselect , or jq if you find an API) would be more stable. - Validate aichat stdin behavior; if not supported, pass the page text via a --input / -f option or rework the prompt.","title":"Usage"},{"location":"scripts/open_url_in_instance.sh/","text":"Open URL in Existing Qutebrowser Instance open_url_in_instance.sh : Open a URL in an already running qutebrowser session, or start a new one if needed Dependencies qutebrowser \u2014 Minimal browser driven by keyboard. socat \u2014 Utility for bidirectional data transfer via sockets. md5sum \u2014 Used for generating hashed socket names. sh \u2014 Compatible POSIX shell. All dependencies should be available from the standard Arch Linux repositories. Description This script is designed to send a URL (or any qutebrowser argument list) to an already running instance of qutebrowser using its IPC socket. If no session is detected, it falls back to starting a new instance of qutebrowser with the provided arguments. Key Ideas: Determines the IPC socket based on the current user's XDG_RUNTIME_DIR and a hashed username. Prepares a JSON object with URL, qutebrowser version, protocol information, and working directory. Uses socat to transmit the JSON to the qutebrowser IPC socket, following the qutebrowser's remote command protocol. If IPC connection fails (socket unavailable or qutebrowser not running), the script launches qutebrowser directly with the supplied arguments. Script Flow: Parses the first argument as the URL to open. Constructs the socket path and command using environment and qutebrowser version details. Tries sending the open command via IPC; if unsuccessful, runs qutebrowser in the background. Usage Basic example: open_url_in_instance.sh https://archlinux.org/ With other arguments: open_url_in_instance.sh --target window https://wiki.archlinux.org/ Integration: - Assign to a keybinding in qtile for \"send URL to browser\". - Use as a drop-in replacement for usual browser opener commands, ensuring URLs always open in one consistent qutebrowser session. This script can be executed from the terminal or hooked into application launchers (like rofi), scripts, or qtile keybindings. TL;DR # Always open new URL in existing qutebrowser window/session if possible open_url_in_instance.sh <your-url> [!TIP] The script relies on md5sum to generate a user-specific socket name, which is convenient and adequate, but if $USER contains unexpected/unusual characters, checks for edge cases may be warranted. Moreover, error handling is minimal: if socat fails for any reason other than \"qutebrowser not running,\" the fallback might inadvertently launch unwanted browser instances. Consider extending the script to handle more nuanced failure conditions, possibly with user-facing error messages or logging for troubleshooting. Also, the version and protocol variables are hardcoded\u2014if you update qutebrowser, compatibility may break. Reading these dynamically, or providing an explanation in the script's comments, would improve maintainability.","title":"Open URL in Existing Qutebrowser Instance"},{"location":"scripts/open_url_in_instance.sh/#open-url-in-existing-qutebrowser-instance","text":"open_url_in_instance.sh : Open a URL in an already running qutebrowser session, or start a new one if needed","title":"Open URL in Existing Qutebrowser Instance"},{"location":"scripts/open_url_in_instance.sh/#dependencies","text":"qutebrowser \u2014 Minimal browser driven by keyboard. socat \u2014 Utility for bidirectional data transfer via sockets. md5sum \u2014 Used for generating hashed socket names. sh \u2014 Compatible POSIX shell. All dependencies should be available from the standard Arch Linux repositories.","title":"Dependencies"},{"location":"scripts/open_url_in_instance.sh/#description","text":"This script is designed to send a URL (or any qutebrowser argument list) to an already running instance of qutebrowser using its IPC socket. If no session is detected, it falls back to starting a new instance of qutebrowser with the provided arguments.","title":"Description"},{"location":"scripts/open_url_in_instance.sh/#key-ideas","text":"Determines the IPC socket based on the current user's XDG_RUNTIME_DIR and a hashed username. Prepares a JSON object with URL, qutebrowser version, protocol information, and working directory. Uses socat to transmit the JSON to the qutebrowser IPC socket, following the qutebrowser's remote command protocol. If IPC connection fails (socket unavailable or qutebrowser not running), the script launches qutebrowser directly with the supplied arguments.","title":"Key Ideas:"},{"location":"scripts/open_url_in_instance.sh/#script-flow","text":"Parses the first argument as the URL to open. Constructs the socket path and command using environment and qutebrowser version details. Tries sending the open command via IPC; if unsuccessful, runs qutebrowser in the background.","title":"Script Flow:"},{"location":"scripts/open_url_in_instance.sh/#usage","text":"Basic example: open_url_in_instance.sh https://archlinux.org/ With other arguments: open_url_in_instance.sh --target window https://wiki.archlinux.org/ Integration: - Assign to a keybinding in qtile for \"send URL to browser\". - Use as a drop-in replacement for usual browser opener commands, ensuring URLs always open in one consistent qutebrowser session. This script can be executed from the terminal or hooked into application launchers (like rofi), scripts, or qtile keybindings.","title":"Usage"},{"location":"scripts/open_url_in_instance.sh/#tldr","text":"# Always open new URL in existing qutebrowser window/session if possible open_url_in_instance.sh <your-url> [!TIP] The script relies on md5sum to generate a user-specific socket name, which is convenient and adequate, but if $USER contains unexpected/unusual characters, checks for edge cases may be warranted. Moreover, error handling is minimal: if socat fails for any reason other than \"qutebrowser not running,\" the fallback might inadvertently launch unwanted browser instances. Consider extending the script to handle more nuanced failure conditions, possibly with user-facing error messages or logging for troubleshooting. Also, the version and protocol variables are hardcoded\u2014if you update qutebrowser, compatibility may break. Reading these dynamically, or providing an explanation in the script's comments, would improve maintainability.","title":"TL;DR"},{"location":"scripts/openwebui-launcher.sh/","text":"Open WebUI Launcher openwebui-launcher.sh : Bash script to launch Open WebUI and open it in a minimal browser. Dependencies uvx : A Python virtual environment tool for launching Python apps. open-webui : The actual Web UI Python application ( open-webui serve command). tmux : Used to daemonize the Open WebUI backend. notify-send : For desktop notifications. curl : To poll server readiness. rg (ripgrep): Used for efficient process search. minimal-browser.py : Custom/user-defined lightweight browser script. Must be available in $PATH . Description This script streamlines the process of starting the Open WebUI server and launching it in a minimal web browser, designed with integration into an Arch Linux + qtile environment. Core functionalities: - Server Initialization: Optionally, with init , uses uvx to provision the latest open-webui package in a Python 3.12 environment and serve it. - Host/Port Customization: Overrides default host/port with -H/--host and -p/--port flags. - Idempotent Launch: Prevents duplicate open-webui instances by scanning running processes. - Timeout-wrapped readiness checks: Waits (up to 30s) for the web UI to become responsive before launching the browser. - Desktop Notifications: Notifies status at major steps for UX clarity. - Browser Launch: Starts the minimal-browser.py pointing at the running Web UI once it is live. Usage # Launch with default localhost:8080, or customize: openwebui-launcher.sh openwebui-launcher.sh --host 0.0.0.0 --port 9000 # To initialize Open WebUI using uvx for a fresh Python env: openwebui-launcher.sh init # Full example, custom host/port, initializing: openwebui-launcher.sh init -H 127.0.0.1 -p 8181 This script can be effectively connected to a qtile keybinding, e.g.: Key([mod], \"F12\", lazy.spawn(\"openwebui-launcher.sh\")) Or, run from dmenu/rofi using the script path. [!NOTE] The script is functional but could be improved for robustness: - Error handling is minimal (e.g. no checks for missing dependencies or for invalid/not found open-webui executable). - The process check ( rg 'open-webui serve' | rg '8080' ) is brittle if running on a custom port or if rg is unavailable. - If minimal-browser.py isn't available, the script exits silently. - Notification text is basic\u2014consider including more diagnostics for failures, or use more dynamic, user-friendly notifications. - The eval on the browser line may be unnecessary and slightly risky; directly invoking the browser may be safer. - The init argument may unintentionally discard host/port overrides (since shift 2 skips the next argument). - Consider using a CLI parsing library (e.g., getopts or even Python's argparse for more maintainable options handling).","title":"Open WebUI Launcher"},{"location":"scripts/openwebui-launcher.sh/#open-webui-launcher","text":"openwebui-launcher.sh : Bash script to launch Open WebUI and open it in a minimal browser.","title":"Open WebUI Launcher"},{"location":"scripts/openwebui-launcher.sh/#dependencies","text":"uvx : A Python virtual environment tool for launching Python apps. open-webui : The actual Web UI Python application ( open-webui serve command). tmux : Used to daemonize the Open WebUI backend. notify-send : For desktop notifications. curl : To poll server readiness. rg (ripgrep): Used for efficient process search. minimal-browser.py : Custom/user-defined lightweight browser script. Must be available in $PATH .","title":"Dependencies"},{"location":"scripts/openwebui-launcher.sh/#description","text":"This script streamlines the process of starting the Open WebUI server and launching it in a minimal web browser, designed with integration into an Arch Linux + qtile environment. Core functionalities: - Server Initialization: Optionally, with init , uses uvx to provision the latest open-webui package in a Python 3.12 environment and serve it. - Host/Port Customization: Overrides default host/port with -H/--host and -p/--port flags. - Idempotent Launch: Prevents duplicate open-webui instances by scanning running processes. - Timeout-wrapped readiness checks: Waits (up to 30s) for the web UI to become responsive before launching the browser. - Desktop Notifications: Notifies status at major steps for UX clarity. - Browser Launch: Starts the minimal-browser.py pointing at the running Web UI once it is live.","title":"Description"},{"location":"scripts/openwebui-launcher.sh/#usage","text":"# Launch with default localhost:8080, or customize: openwebui-launcher.sh openwebui-launcher.sh --host 0.0.0.0 --port 9000 # To initialize Open WebUI using uvx for a fresh Python env: openwebui-launcher.sh init # Full example, custom host/port, initializing: openwebui-launcher.sh init -H 127.0.0.1 -p 8181 This script can be effectively connected to a qtile keybinding, e.g.: Key([mod], \"F12\", lazy.spawn(\"openwebui-launcher.sh\")) Or, run from dmenu/rofi using the script path. [!NOTE] The script is functional but could be improved for robustness: - Error handling is minimal (e.g. no checks for missing dependencies or for invalid/not found open-webui executable). - The process check ( rg 'open-webui serve' | rg '8080' ) is brittle if running on a custom port or if rg is unavailable. - If minimal-browser.py isn't available, the script exits silently. - Notification text is basic\u2014consider including more diagnostics for failures, or use more dynamic, user-friendly notifications. - The eval on the browser line may be unnecessary and slightly risky; directly invoking the browser may be safer. - The init argument may unintentionally discard host/port overrides (since shift 2 skips the next argument). - Consider using a CLI parsing library (e.g., getopts or even Python's argparse for more maintainable options handling).","title":"Usage"},{"location":"scripts/openwebui_serve.sh/","text":"Open WebUI Server Launcher openwebui_serve.sh : Launch Open WebUI via uvx with XDG-compliant data directory Dependencies bash \u2014 script shell. uv (provides uvx ) \u2014 runs Python apps without global installs; fetches tools on demand. python (3.12) \u2014 interpreter used by uvx --python 3.12 . open-webui \u2014 Python package providing the open-webui CLI/server. systemd (optional) \u2014 to run as a user service. XDG_DATA_HOME \u2014 used to place persistent data under an XDG-compliant path. Description This tiny launcher runs Open WebUI with uvx , always using the latest published Python package and Python 3.12 runtime. It sets a per-run environment variable so Open WebUI stores all state under: - $XDG_DATA_HOME/open-webui (typically ~/.local/share/open-webui on Arch if XDG_DATA_HOME is set) Because it uses uvx : - No global Python packages are installed; dependencies are cached by uv. - You always get the latest open-webui due to the @latest specifier. - Python 3.12 is ensured even if system Python differs. The variable assignment prefix (DATA_DIR=\"...\") only applies to this command invocation, keeping your environment clean. Usage Make sure ~/.scripts/bin is in your PATH and the script is executable: chmod +x ~/.scripts/bin/openwebui_serve.sh Start the server: openwebui_serve.sh Then open in your browser (default): http://localhost:8080 Examples: - Run in a terminal to see logs: - alacritty -e openwebui_serve.sh - Qtile keybinding: - lazy.spawn(\"alacritty -e ~/.scripts/bin/openwebui_serve.sh\") - As a systemd user service (~/.config/systemd/user/openwebui.service): - [Unit] Description=Open WebUI (uvx) - [Service] ExecStart=%h/.scripts/bin/openwebui_serve.sh Restart=on-failure - [Install] WantedBy=default.target - systemctl --user enable --now openwebui.service Environment tweaks (before launching): - Change port: PORT=3000 openwebui_serve.sh - Override data dir: DATA_DIR=/path/to/data openwebui_serve.sh [!TIP] - If XDG_DATA_HOME is unset, DATA_DIR may expand to \u201c/open-webui\u201d. Consider a fallback: DATA_DIR=\"${XDG_DATA_HOME:-$HOME/.local/share}/open-webui\". - The script does not pass through CLI arguments. To allow this, append \"$@\" after serve: \u2026 open-webui@latest serve \"$@\". - Pinning a version (e.g., open-webui==vX.Y.Z) can improve reproducibility. - You may want to add a simple healthcheck/retry or systemd sandboxing (ProtectHome, PrivateTmp) for robustness.","title":"Open WebUI Server Launcher"},{"location":"scripts/openwebui_serve.sh/#open-webui-server-launcher","text":"openwebui_serve.sh : Launch Open WebUI via uvx with XDG-compliant data directory","title":"Open WebUI Server Launcher"},{"location":"scripts/openwebui_serve.sh/#dependencies","text":"bash \u2014 script shell. uv (provides uvx ) \u2014 runs Python apps without global installs; fetches tools on demand. python (3.12) \u2014 interpreter used by uvx --python 3.12 . open-webui \u2014 Python package providing the open-webui CLI/server. systemd (optional) \u2014 to run as a user service. XDG_DATA_HOME \u2014 used to place persistent data under an XDG-compliant path.","title":"Dependencies"},{"location":"scripts/openwebui_serve.sh/#description","text":"This tiny launcher runs Open WebUI with uvx , always using the latest published Python package and Python 3.12 runtime. It sets a per-run environment variable so Open WebUI stores all state under: - $XDG_DATA_HOME/open-webui (typically ~/.local/share/open-webui on Arch if XDG_DATA_HOME is set) Because it uses uvx : - No global Python packages are installed; dependencies are cached by uv. - You always get the latest open-webui due to the @latest specifier. - Python 3.12 is ensured even if system Python differs. The variable assignment prefix (DATA_DIR=\"...\") only applies to this command invocation, keeping your environment clean.","title":"Description"},{"location":"scripts/openwebui_serve.sh/#usage","text":"Make sure ~/.scripts/bin is in your PATH and the script is executable: chmod +x ~/.scripts/bin/openwebui_serve.sh Start the server: openwebui_serve.sh Then open in your browser (default): http://localhost:8080 Examples: - Run in a terminal to see logs: - alacritty -e openwebui_serve.sh - Qtile keybinding: - lazy.spawn(\"alacritty -e ~/.scripts/bin/openwebui_serve.sh\") - As a systemd user service (~/.config/systemd/user/openwebui.service): - [Unit] Description=Open WebUI (uvx) - [Service] ExecStart=%h/.scripts/bin/openwebui_serve.sh Restart=on-failure - [Install] WantedBy=default.target - systemctl --user enable --now openwebui.service Environment tweaks (before launching): - Change port: PORT=3000 openwebui_serve.sh - Override data dir: DATA_DIR=/path/to/data openwebui_serve.sh [!TIP] - If XDG_DATA_HOME is unset, DATA_DIR may expand to \u201c/open-webui\u201d. Consider a fallback: DATA_DIR=\"${XDG_DATA_HOME:-$HOME/.local/share}/open-webui\". - The script does not pass through CLI arguments. To allow this, append \"$@\" after serve: \u2026 open-webui@latest serve \"$@\". - Pinning a version (e.g., open-webui==vX.Y.Z) can improve reproducibility. - You may want to add a simple healthcheck/retry or systemd sandboxing (ProtectHome, PrivateTmp) for robustness.","title":"Usage"},{"location":"scripts/ousse-locate.sh/","text":"ousse-locate: a database/search helper for Ousse data ousse-locate.sh : Experimental script for managing and searching local .db databases with preview support. Dependencies eza : Modern replacement for ls , used for directory listing and info. awk : Text processing. du : Disk usage estimator. cut , tr , sed , echo , date : Standard Unix text and file manipulation utilities. fzf (optional, WIP) : Fuzzy finder for interactive selection. bat (optional, WIP) : Cat clone with syntax highlighting for previews. plocate (optional, commented) : Fast file locator, used for searching patterns in database files. rg (optional, commented) : ripgrep, for regex-driven file search. Description ousse-locate.sh is a user-space helper script for inspecting and searching local databases located at .local/share/ousse/ . It's designed to assist in visualizing, assessing, and searching .db files collected within that folder. The script currently demonstrates several commands (some commented as TODOs for future integration): Computes total bytes used by all .db files in .local/share/ousse . Produces a detailed listing with sizes, modification times, and absolute paths via eza . Performs some numerical calculations (relative widths, time differences), potentially for TUI displays. Provides an example block for constructing a pipeline with dust (space analyzer), sed , bat (highlighted preview), and fzf (fuzzy selection). Includes a detailed snippet of supported plocate search options and a sample chain to preview matches or open found files in nvim via fzf . The script is experimental and full interactive capability or fuzzy selection is not yet fully implemented\u2014it mainly demonstrates various info gathering via awk , eza , and shell arithmetic. The TODOs note intentions for further development, particularly age-aware database checks and more direct fuzzy selection/search integration. Usage For now, invoke the script directly to display information on your .db files: ~/.scripts/dev/ousse-locate.sh This prints: The total size in bytes of .local/share/ousse . A line with column-wise proportional info (potential TUI progress bar). A line with time-deltas between now and each file's modification time. A re-listing of files for further inspection. Note: There is no direct argument parsing at this stage; most interactivity or filtering is left as future development per the TODO section. If you want basic interactive search, refer to the commented fzf / plocate / rg blocks as starting points: plocate -d .local/share/ousse/mydb.db 'PATTERN' # or try ripgrep/fzf manually: rg --color=always \"pattern\" | fzf --ansi --preview 'bat --color=always {1} --highlight-line {2}' [!TIP] This script is still very much a prototype, more a \"notebook\" than a finished utility: - It presently does not process arguments or perform actual database searching\u2014it only outputs info about .db files. - Several features are commented (e.g., fzf , bat , plocate usage) but not connected. - Output is difficult to interpret without further formatting; it also assumes existence of .local/share/ousse and compatible environment. - Consider modularizing feature blocks into functions as the script grows, and adding proper CLI argument handling. - You may want to add error handling for missing directories/deps, and use absolute paths for robustness. - Great starting point for a richer fuzzy-locate explorer tailored for your data!","title":"ousse-locate: a database/search helper for Ousse data"},{"location":"scripts/ousse-locate.sh/#ousse-locate-a-databasesearch-helper-for-ousse-data","text":"ousse-locate.sh : Experimental script for managing and searching local .db databases with preview support.","title":"ousse-locate: a database/search helper for Ousse data"},{"location":"scripts/ousse-locate.sh/#dependencies","text":"eza : Modern replacement for ls , used for directory listing and info. awk : Text processing. du : Disk usage estimator. cut , tr , sed , echo , date : Standard Unix text and file manipulation utilities. fzf (optional, WIP) : Fuzzy finder for interactive selection. bat (optional, WIP) : Cat clone with syntax highlighting for previews. plocate (optional, commented) : Fast file locator, used for searching patterns in database files. rg (optional, commented) : ripgrep, for regex-driven file search.","title":"Dependencies"},{"location":"scripts/ousse-locate.sh/#description","text":"ousse-locate.sh is a user-space helper script for inspecting and searching local databases located at .local/share/ousse/ . It's designed to assist in visualizing, assessing, and searching .db files collected within that folder. The script currently demonstrates several commands (some commented as TODOs for future integration): Computes total bytes used by all .db files in .local/share/ousse . Produces a detailed listing with sizes, modification times, and absolute paths via eza . Performs some numerical calculations (relative widths, time differences), potentially for TUI displays. Provides an example block for constructing a pipeline with dust (space analyzer), sed , bat (highlighted preview), and fzf (fuzzy selection). Includes a detailed snippet of supported plocate search options and a sample chain to preview matches or open found files in nvim via fzf . The script is experimental and full interactive capability or fuzzy selection is not yet fully implemented\u2014it mainly demonstrates various info gathering via awk , eza , and shell arithmetic. The TODOs note intentions for further development, particularly age-aware database checks and more direct fuzzy selection/search integration.","title":"Description"},{"location":"scripts/ousse-locate.sh/#usage","text":"For now, invoke the script directly to display information on your .db files: ~/.scripts/dev/ousse-locate.sh This prints: The total size in bytes of .local/share/ousse . A line with column-wise proportional info (potential TUI progress bar). A line with time-deltas between now and each file's modification time. A re-listing of files for further inspection. Note: There is no direct argument parsing at this stage; most interactivity or filtering is left as future development per the TODO section. If you want basic interactive search, refer to the commented fzf / plocate / rg blocks as starting points: plocate -d .local/share/ousse/mydb.db 'PATTERN' # or try ripgrep/fzf manually: rg --color=always \"pattern\" | fzf --ansi --preview 'bat --color=always {1} --highlight-line {2}' [!TIP] This script is still very much a prototype, more a \"notebook\" than a finished utility: - It presently does not process arguments or perform actual database searching\u2014it only outputs info about .db files. - Several features are commented (e.g., fzf , bat , plocate usage) but not connected. - Output is difficult to interpret without further formatting; it also assumes existence of .local/share/ousse and compatible environment. - Consider modularizing feature blocks into functions as the script grows, and adding proper CLI argument handling. - You may want to add error handling for missing directories/deps, and use absolute paths for robustness. - Great starting point for a richer fuzzy-locate explorer tailored for your data!","title":"Usage"},{"location":"scripts/ousse-update.sh/","text":"Custom Locate Database Updater ousse-update.sh : Custom script to update various mlocate databases with personal folder scopes. Dependencies updatedb From the mlocate package. Generates locate databases. Required for all update operations. fd A simple, fast and user-friendly alternative to find . Used for pruning folders dynamically. rg ripgrep, a fast line-oriented search tool, used together with fd for filtering. sed Utilized for line edits, especially directory path formatting. realpath For canonicalizing file/directory paths. Environment variable: $XDG_DATA_HOME Ensure it's set, otherwise fallback will not be handled by this script. Description This script streamlines the update of multiple mlocate database files to maintain rapid file search across your primary directories: $HOME , dotfiles, external data drives, root, MEGA sync, device folders, \"limbo\" directories, and HDD2. Each function (e.g., _home , _dots , etc.) invokes updatedb scoped to specific directories, leveraging fd and rg for dynamic prune paths and names. This ensures that: - Unwanted folders or mounts are skipped. - Each scope has minimal, tailored prune rules for optimal search usefulness. - All database files are written under $XDG_DATA_HOME/ousse/ . Example: _dots Prunes all non-dot directories in $HOME , thus ensuring dotfiles (configurations) are not skipped or flooded by regular folders. Note: The _custom_updatedb function is a stub and not currently used. Usage Typically, use this from a terminal (or assign it to a keybinding in Qtile): # Update all databases ~/.scripts/meta/ousse-update.sh all # Update only home database ~/.scripts/meta/ousse-update.sh home # Update only dots database ~/.scripts/meta/ousse-update.sh dots # Other available targets: # data, root, mega, devices, limbo, hdd2 # For example, to update only devices: ~/.scripts/meta/ousse-update.sh devices Can be run periodically (e.g., via systemd service/timer, or cron/anacron for root tasks). [!WARNING] - The function _dot in the case statement should be _dots to match the defined function name, otherwise \"dots\" command silently fails. - Error handling is minimal or absent: e.g., missing dependencies, unset $XDG_DATA_HOME , permissions issues are not surfaced. - Database paths and prunelists have some redundancy; consider factoring shared pruning logic. - _custom_updatedb is unfinished, and its usage is unclear or broken. - Usage of external commands ( fd , rg , sed , etc.) assumes all are installed and available on $PATH . - Expanding MIN_AGE (currently commented) could streamline avoiding redundant updates. - Consider documenting or adding a help message for maintainability.","title":"Custom Locate Database Updater"},{"location":"scripts/ousse-update.sh/#custom-locate-database-updater","text":"ousse-update.sh : Custom script to update various mlocate databases with personal folder scopes.","title":"Custom Locate Database Updater"},{"location":"scripts/ousse-update.sh/#dependencies","text":"updatedb From the mlocate package. Generates locate databases. Required for all update operations. fd A simple, fast and user-friendly alternative to find . Used for pruning folders dynamically. rg ripgrep, a fast line-oriented search tool, used together with fd for filtering. sed Utilized for line edits, especially directory path formatting. realpath For canonicalizing file/directory paths. Environment variable: $XDG_DATA_HOME Ensure it's set, otherwise fallback will not be handled by this script.","title":"Dependencies"},{"location":"scripts/ousse-update.sh/#description","text":"This script streamlines the update of multiple mlocate database files to maintain rapid file search across your primary directories: $HOME , dotfiles, external data drives, root, MEGA sync, device folders, \"limbo\" directories, and HDD2. Each function (e.g., _home , _dots , etc.) invokes updatedb scoped to specific directories, leveraging fd and rg for dynamic prune paths and names. This ensures that: - Unwanted folders or mounts are skipped. - Each scope has minimal, tailored prune rules for optimal search usefulness. - All database files are written under $XDG_DATA_HOME/ousse/ .","title":"Description"},{"location":"scripts/ousse-update.sh/#example-_dots","text":"Prunes all non-dot directories in $HOME , thus ensuring dotfiles (configurations) are not skipped or flooded by regular folders. Note: The _custom_updatedb function is a stub and not currently used.","title":"Example: _dots"},{"location":"scripts/ousse-update.sh/#usage","text":"Typically, use this from a terminal (or assign it to a keybinding in Qtile): # Update all databases ~/.scripts/meta/ousse-update.sh all # Update only home database ~/.scripts/meta/ousse-update.sh home # Update only dots database ~/.scripts/meta/ousse-update.sh dots # Other available targets: # data, root, mega, devices, limbo, hdd2 # For example, to update only devices: ~/.scripts/meta/ousse-update.sh devices Can be run periodically (e.g., via systemd service/timer, or cron/anacron for root tasks). [!WARNING] - The function _dot in the case statement should be _dots to match the defined function name, otherwise \"dots\" command silently fails. - Error handling is minimal or absent: e.g., missing dependencies, unset $XDG_DATA_HOME , permissions issues are not surfaced. - Database paths and prunelists have some redundancy; consider factoring shared pruning logic. - _custom_updatedb is unfinished, and its usage is unclear or broken. - Usage of external commands ( fd , rg , sed , etc.) assumes all are installed and available on $PATH . - Expanding MIN_AGE (currently commented) could streamline avoiding redundant updates. - Consider documenting or adding a help message for maintainability.","title":"Usage"},{"location":"scripts/pacman-fuzzy-search.sh/","text":"Pacman Fuzzy Search Script pacman-fuzzy-search.sh : Fuzzy search and install Arch Linux packages (repo/AUR) using paru and fzf Dependencies paru : AUR helper to query and install repo and AUR packages. fzf : Command-line fuzzy finder for interactive search. bat : Colorful cat clone with syntax highlighting (used for pretty previews). ripgrep ( rg ): Fast grep replacement, used for filtering results. notify-send : Used to send desktop notifications. sed : Stream editor for text processing (standard on most systems). Ensure all dependencies are installed, preferably via pacman/AUR. Script assumes a Unix-like environment (Arch Linux), and is suitable for usage with qtile WM and interactive keybindings. Description This script enables an advanced fuzzy search for available and installed packages (including AUR) using paru as the package interface and fzf for selection. It sets up a persistent cache directory, leverages ripgrep for filtering, and bat for syntax-highlighted previews. Key Features: - Preview Pane : Shows detailed package info ( paru -Si or paru -Qi ) in a colored panel powered by bat . - Interactive Search : Lets you type to search across packages. Results can be filtered between AUR, repo, or installed packages. - Multi-select & Install : Select multiple packages to install at once. - Dynamic Reloading : Under the hood, supports reloads and border label changes (partially implemented, see commented code). - Keybind Support : Suitable for mapping to a key in your qtile config for quick popup access. Functions: preview_cmd : Displays package details for the selected line in fzf using paru and formats them for easier reading. paruSl : Lists all available packages ( paru -Sl ) with some visual tweaks. search_cmd : Intended to filter results based on togglable \"repo\" and \"installed\" modes (partially implemented; see commented logic for future improvements). fzf_cmd : Runs fzf with several custom keybinds and options for a rich TUI search/selection experience. Usage Run Directly ~/.scripts/bin/pacman-fuzzy-search.sh Use arrow keys to browse. Type to search. Space or tab to select multiple packages. Press Enter to install selected packages (via paru -S ). Assign to qtile Keybinding Edit your ~/.config/qtile/config.py : Key([mod], \"F12\", lazy.spawn(\"~/.scripts/bin/pacman-fuzzy-search.sh\")) Example - TLDR # Launch fuzzy search for packages ~/.scripts/bin/pacman-fuzzy-search.sh [!NOTE] While the script is robust and provides a friendly package search/install workflow, the advanced mode switching (filtering to only AUR, only installed, etc.) is incomplete\u2014referenced via commented code in both functions and keybinding setups. Additionally, customization of border labels and dynamic reloading of results can be enhanced by finishing the commented-out logic. The use of bat for previewing is visually appealing but may appear cluttered for very long package descriptions. Consider adding more intuitive filtering UI or more keybinds for filtering for a future version.","title":"Pacman Fuzzy Search Script"},{"location":"scripts/pacman-fuzzy-search.sh/#pacman-fuzzy-search-script","text":"pacman-fuzzy-search.sh : Fuzzy search and install Arch Linux packages (repo/AUR) using paru and fzf","title":"Pacman Fuzzy Search Script"},{"location":"scripts/pacman-fuzzy-search.sh/#dependencies","text":"paru : AUR helper to query and install repo and AUR packages. fzf : Command-line fuzzy finder for interactive search. bat : Colorful cat clone with syntax highlighting (used for pretty previews). ripgrep ( rg ): Fast grep replacement, used for filtering results. notify-send : Used to send desktop notifications. sed : Stream editor for text processing (standard on most systems). Ensure all dependencies are installed, preferably via pacman/AUR. Script assumes a Unix-like environment (Arch Linux), and is suitable for usage with qtile WM and interactive keybindings.","title":"Dependencies"},{"location":"scripts/pacman-fuzzy-search.sh/#description","text":"This script enables an advanced fuzzy search for available and installed packages (including AUR) using paru as the package interface and fzf for selection. It sets up a persistent cache directory, leverages ripgrep for filtering, and bat for syntax-highlighted previews. Key Features: - Preview Pane : Shows detailed package info ( paru -Si or paru -Qi ) in a colored panel powered by bat . - Interactive Search : Lets you type to search across packages. Results can be filtered between AUR, repo, or installed packages. - Multi-select & Install : Select multiple packages to install at once. - Dynamic Reloading : Under the hood, supports reloads and border label changes (partially implemented, see commented code). - Keybind Support : Suitable for mapping to a key in your qtile config for quick popup access.","title":"Description"},{"location":"scripts/pacman-fuzzy-search.sh/#functions","text":"preview_cmd : Displays package details for the selected line in fzf using paru and formats them for easier reading. paruSl : Lists all available packages ( paru -Sl ) with some visual tweaks. search_cmd : Intended to filter results based on togglable \"repo\" and \"installed\" modes (partially implemented; see commented logic for future improvements). fzf_cmd : Runs fzf with several custom keybinds and options for a rich TUI search/selection experience.","title":"Functions:"},{"location":"scripts/pacman-fuzzy-search.sh/#usage","text":"","title":"Usage"},{"location":"scripts/pacman-fuzzy-search.sh/#run-directly","text":"~/.scripts/bin/pacman-fuzzy-search.sh Use arrow keys to browse. Type to search. Space or tab to select multiple packages. Press Enter to install selected packages (via paru -S ).","title":"Run Directly"},{"location":"scripts/pacman-fuzzy-search.sh/#assign-to-qtile-keybinding","text":"Edit your ~/.config/qtile/config.py : Key([mod], \"F12\", lazy.spawn(\"~/.scripts/bin/pacman-fuzzy-search.sh\"))","title":"Assign to qtile Keybinding"},{"location":"scripts/pacman-fuzzy-search.sh/#example-tldr","text":"# Launch fuzzy search for packages ~/.scripts/bin/pacman-fuzzy-search.sh [!NOTE] While the script is robust and provides a friendly package search/install workflow, the advanced mode switching (filtering to only AUR, only installed, etc.) is incomplete\u2014referenced via commented code in both functions and keybinding setups. Additionally, customization of border labels and dynamic reloading of results can be enhanced by finishing the commented-out logic. The use of bat for previewing is visually appealing but may appear cluttered for very long package descriptions. Consider adding more intuitive filtering UI or more keybinds for filtering for a future version.","title":"Example - TLDR"},{"location":"scripts/pdfopener.sh/","text":"PDF picker and opener pdfopener.sh : Fuzzy-pick a PDF in $HOME and open it with Evince, falling back to xdg-open Dependencies fd \u2014 fast file finder; used to list PDFs under $HOME improved-fzfmenu.sh \u2014 your fzf wrapper; must accept --ansi and print the selected path fzf \u2014 required by improved-fzfmenu.sh for interactive selection evince \u2014 primary PDF viewer xdg-open \u2014 fallback opener if evince fails bash as /bin/sh on Arch \u2014 script uses [[ ... ]] which is a bashism Description This script lets you quickly locate and open any PDF inside your home directory. It composes a simple pipeline: 1) fd -tf '\\.pdf$' \"$HOME\" --color=always lists all regular files ending with .pdf beneath $HOME . 2) The list is piped to improved-fzfmenu.sh --ansi for an interactive fuzzy pick. 3) If a valid file is selected, the script tries evince \"$file\" ; on failure it falls back to xdg-open \"$file\" . Colorized fd output pairs with --ansi so fuzzy matching ignores ANSI sequences while keeping colored display in the menu. Usage Run from a terminal: ~/.scripts/bin/pdfopener.sh Bind to a key in qtile (e.g., Mod+p): ``` # in ~/.config/qtile/config.py from libqtile.config import Key from libqtile.command import lazy keys.append(Key([mod], \"p\", lazy.spawn(\"~/.scripts/bin/pdfopener.sh\"))) ``` Typical flow: Invoke the script Start typing to filter PDFs Press Enter to open the highlighted file No arguments are required; the script is non-interactive beyond the fzf selector. [!TIP] - Portability: [[ ... ]] is a bashism. Either change the shebang to #!/usr/bin/env bash or switch to POSIX [ ... ] . - Path correctness: fd prints paths relative to $HOME in this usage. If your current directory is not $HOME , [[ -f \"$file\" ]] and evince \"$file\" may fail. Use fd -a ... for absolute paths, or cd \"$HOME\" before running fd . - ANSI safety: Relying on colorized input requires improved-fzfmenu.sh to strip ANSI from the selected output. For robustness, consider fd --color=never and drop --ansi . - UX idea: Add a preview (e.g., pdfinfo , exiftool , or filename context) in your fzf wrapper to show metadata while selecting.","title":"PDF picker and opener"},{"location":"scripts/pdfopener.sh/#pdf-picker-and-opener","text":"pdfopener.sh : Fuzzy-pick a PDF in $HOME and open it with Evince, falling back to xdg-open","title":"PDF picker and opener"},{"location":"scripts/pdfopener.sh/#dependencies","text":"fd \u2014 fast file finder; used to list PDFs under $HOME improved-fzfmenu.sh \u2014 your fzf wrapper; must accept --ansi and print the selected path fzf \u2014 required by improved-fzfmenu.sh for interactive selection evince \u2014 primary PDF viewer xdg-open \u2014 fallback opener if evince fails bash as /bin/sh on Arch \u2014 script uses [[ ... ]] which is a bashism","title":"Dependencies"},{"location":"scripts/pdfopener.sh/#description","text":"This script lets you quickly locate and open any PDF inside your home directory. It composes a simple pipeline: 1) fd -tf '\\.pdf$' \"$HOME\" --color=always lists all regular files ending with .pdf beneath $HOME . 2) The list is piped to improved-fzfmenu.sh --ansi for an interactive fuzzy pick. 3) If a valid file is selected, the script tries evince \"$file\" ; on failure it falls back to xdg-open \"$file\" . Colorized fd output pairs with --ansi so fuzzy matching ignores ANSI sequences while keeping colored display in the menu.","title":"Description"},{"location":"scripts/pdfopener.sh/#usage","text":"Run from a terminal: ~/.scripts/bin/pdfopener.sh Bind to a key in qtile (e.g., Mod+p): ``` # in ~/.config/qtile/config.py from libqtile.config import Key from libqtile.command import lazy keys.append(Key([mod], \"p\", lazy.spawn(\"~/.scripts/bin/pdfopener.sh\"))) ``` Typical flow: Invoke the script Start typing to filter PDFs Press Enter to open the highlighted file No arguments are required; the script is non-interactive beyond the fzf selector. [!TIP] - Portability: [[ ... ]] is a bashism. Either change the shebang to #!/usr/bin/env bash or switch to POSIX [ ... ] . - Path correctness: fd prints paths relative to $HOME in this usage. If your current directory is not $HOME , [[ -f \"$file\" ]] and evince \"$file\" may fail. Use fd -a ... for absolute paths, or cd \"$HOME\" before running fd . - ANSI safety: Relying on colorized input requires improved-fzfmenu.sh to strip ANSI from the selected output. For robustness, consider fd --color=never and drop --ansi . - UX idea: Add a preview (e.g., pdfinfo , exiftool , or filename context) in your fzf wrapper to show metadata while selecting.","title":"Usage"},{"location":"scripts/playlist_player.xsh/","text":"Playlist Player (cmus Edition) playlist_player.xsh : Select and play a saved .m3u playlist in cmus via dmenu Dependencies xonsh : Shell interpreter used to run this script (shebang: #!/usr/bin/env xonsh ) cmus-remote : Command-line remote control for cmus music player dmenu : Dynamic menu for X; used to select playlists Playlist directory: Assumes playlists are stored as .m3u files in ~/.playlists Description This script provides an interactive way to select and play a playlist in cmus on your Arch Linux system. Here's a breakdown of its functionality: Playlist Discovery: The script looks for .m3u files in your ~/.playlists directory, collecting each filename (without extension). dmenu Interface: All discovered playlists are presented in a dmenu prompt, allowing you to select the one you wish to play. cmus Control: Switches to cmus library view #4 (presumably playlist view). Clears the current cmus queue. Adds the selected playlist to the cmus queue. Skips to the next track (to trigger the playlist load properly). Starts playback in cmus. The workflow is linear and interacts with the user only via dmenu , making it a fast and distraction-free playlist launcher suitable for keybindings or scripting within your qtile Window Manager environment. Usage You can run this script from your terminal or bind it to a key combination (recommended for qtile users): playlist_player.xsh Example workflow: Script runs and opens dmenu listing all .m3u playlists in ~/.playlists : +----------------------------+ | my_rock_playlist | | relaxing_sounds | | synthwave_collection | +----------------------------+ Select one (e.g., synthwave_collection ), press Enter. That playlist is instantly loaded and playback starts in cmus. For qtile users: Bind the script to a convenient key combination in your qtile config for seamless use. [!TIP] - The script assumes all .m3u files are directly under ~/.playlists . It does not handle nested directories or non- .m3u playlist formats. - There is no error checking for the existence of cmus, dmenu, or the playlist directory; running it without these in place will fail without clear error messages. - If two playlists have the same prefix before .m3u (e.g., foo.m3u , foo.bak.m3u ), both will appear as foo and may cause confusion. - You might want to add logic to detect and report when no playlists are found, or when the user cancels dmenu (currently tries to add a .m3u with an empty name if nothing is selected).","title":"Playlist Player (cmus Edition)"},{"location":"scripts/playlist_player.xsh/#playlist-player-cmus-edition","text":"playlist_player.xsh : Select and play a saved .m3u playlist in cmus via dmenu","title":"Playlist Player (cmus Edition)"},{"location":"scripts/playlist_player.xsh/#dependencies","text":"xonsh : Shell interpreter used to run this script (shebang: #!/usr/bin/env xonsh ) cmus-remote : Command-line remote control for cmus music player dmenu : Dynamic menu for X; used to select playlists Playlist directory: Assumes playlists are stored as .m3u files in ~/.playlists","title":"Dependencies"},{"location":"scripts/playlist_player.xsh/#description","text":"This script provides an interactive way to select and play a playlist in cmus on your Arch Linux system. Here's a breakdown of its functionality: Playlist Discovery: The script looks for .m3u files in your ~/.playlists directory, collecting each filename (without extension). dmenu Interface: All discovered playlists are presented in a dmenu prompt, allowing you to select the one you wish to play. cmus Control: Switches to cmus library view #4 (presumably playlist view). Clears the current cmus queue. Adds the selected playlist to the cmus queue. Skips to the next track (to trigger the playlist load properly). Starts playback in cmus. The workflow is linear and interacts with the user only via dmenu , making it a fast and distraction-free playlist launcher suitable for keybindings or scripting within your qtile Window Manager environment.","title":"Description"},{"location":"scripts/playlist_player.xsh/#usage","text":"You can run this script from your terminal or bind it to a key combination (recommended for qtile users): playlist_player.xsh","title":"Usage"},{"location":"scripts/playlist_player.xsh/#example-workflow","text":"Script runs and opens dmenu listing all .m3u playlists in ~/.playlists : +----------------------------+ | my_rock_playlist | | relaxing_sounds | | synthwave_collection | +----------------------------+ Select one (e.g., synthwave_collection ), press Enter. That playlist is instantly loaded and playback starts in cmus. For qtile users: Bind the script to a convenient key combination in your qtile config for seamless use. [!TIP] - The script assumes all .m3u files are directly under ~/.playlists . It does not handle nested directories or non- .m3u playlist formats. - There is no error checking for the existence of cmus, dmenu, or the playlist directory; running it without these in place will fail without clear error messages. - If two playlists have the same prefix before .m3u (e.g., foo.m3u , foo.bak.m3u ), both will appear as foo and may cause confusion. - You might want to add logic to detect and report when no playlists are found, or when the user cancels dmenu (currently tries to add a .m3u with an empty name if nothing is selected).","title":"Example workflow:"},{"location":"scripts/playlist_randomizer.xsh/","text":"cmus Playlist Album Randomizer (xonsh) playlist_randomizer.xsh : Pick an m3u playlist, shuffle album order, play via cmus Dependencies xonsh \u2014 shell interpreter used by the script. python \u2014 required by xonsh; system Python on Arch. python-pandas \u2014 builds a DataFrame to group/shuffle albums. dmenu \u2014 interactive playlist picker. cmus and cmus-remote \u2014 music player and control CLI. coreutils ( ls , cat ) \u2014 used via xonsh subprocess calls. Description This script lets you choose an .m3u playlist via dmenu , then plays it in cmus with albums randomized but tracks within each album kept in sorted order. It: 1) Lists .m3u names in ~/.playlists , presents them with dmenu -i -l 30 , and captures your selection. 2) Reads the selected playlist\u2019s entries (one path per line), filters out blanks, and derives two columns: album directory (parent folder) and song filename. 3) Randomizes album order, sorts songs within each album alphabetically, and writes the result to /tmp/randomized.m3u . 4) Controls cmus: switches to playlist view ( view 4 ), clears the queue, adds the randomized playlist, then starts playback ( -n , -p ). This is ideal on Arch + qtile for a quick, keyboard-driven shuffle by album while preserving album cohesion. Usage Run interactively from a terminal: ~/.scripts/bin/playlist_randomizer.xsh Bind in qtile (example): add a key calling lazy.spawn('xonsh ~/.scripts/bin/playlist_randomizer.xsh') . Ensure cmus is running: e.g., start cmus first; cmus-remote requires a running instance. Expected locations: Playlists listed from: ~/.playlists (names shown in dmenu). Playlist file read from: /home/matias/notes/playlists/<selected>.m3u (see critique). Output: /tmp/randomized.m3u . tldr: - Prepare .m3u files with absolute paths to tracks. - Hit your binding or run the script. - Pick a playlist in dmenu. - cmus queue is replaced with a randomized-by-album order and starts playing. [!TIP] - The script lists playlists from ~/.playlists but reads from /home/matias/notes/playlists . Unify to a single PLAYLIST_PATH to avoid mismatches. - i.split('.')[0] will truncate names containing multiple dots; prefer strict extension checks (e.g., endswith .m3u ) and Path.stem . - Add early exits for empty selection, missing files, or a non-running cmus; handle #EXTM3U and comments. - Sorting tracks alphabetically may break track order; parse track numbers or use natural sorting. - Consider dropping pandas for a lightweight approach if performance or dependency size matters.","title":"cmus Playlist Album Randomizer (xonsh)"},{"location":"scripts/playlist_randomizer.xsh/#cmus-playlist-album-randomizer-xonsh","text":"playlist_randomizer.xsh : Pick an m3u playlist, shuffle album order, play via cmus","title":"cmus Playlist Album Randomizer (xonsh)"},{"location":"scripts/playlist_randomizer.xsh/#dependencies","text":"xonsh \u2014 shell interpreter used by the script. python \u2014 required by xonsh; system Python on Arch. python-pandas \u2014 builds a DataFrame to group/shuffle albums. dmenu \u2014 interactive playlist picker. cmus and cmus-remote \u2014 music player and control CLI. coreutils ( ls , cat ) \u2014 used via xonsh subprocess calls.","title":"Dependencies"},{"location":"scripts/playlist_randomizer.xsh/#description","text":"This script lets you choose an .m3u playlist via dmenu , then plays it in cmus with albums randomized but tracks within each album kept in sorted order. It: 1) Lists .m3u names in ~/.playlists , presents them with dmenu -i -l 30 , and captures your selection. 2) Reads the selected playlist\u2019s entries (one path per line), filters out blanks, and derives two columns: album directory (parent folder) and song filename. 3) Randomizes album order, sorts songs within each album alphabetically, and writes the result to /tmp/randomized.m3u . 4) Controls cmus: switches to playlist view ( view 4 ), clears the queue, adds the randomized playlist, then starts playback ( -n , -p ). This is ideal on Arch + qtile for a quick, keyboard-driven shuffle by album while preserving album cohesion.","title":"Description"},{"location":"scripts/playlist_randomizer.xsh/#usage","text":"Run interactively from a terminal: ~/.scripts/bin/playlist_randomizer.xsh Bind in qtile (example): add a key calling lazy.spawn('xonsh ~/.scripts/bin/playlist_randomizer.xsh') . Ensure cmus is running: e.g., start cmus first; cmus-remote requires a running instance. Expected locations: Playlists listed from: ~/.playlists (names shown in dmenu). Playlist file read from: /home/matias/notes/playlists/<selected>.m3u (see critique). Output: /tmp/randomized.m3u . tldr: - Prepare .m3u files with absolute paths to tracks. - Hit your binding or run the script. - Pick a playlist in dmenu. - cmus queue is replaced with a randomized-by-album order and starts playing. [!TIP] - The script lists playlists from ~/.playlists but reads from /home/matias/notes/playlists . Unify to a single PLAYLIST_PATH to avoid mismatches. - i.split('.')[0] will truncate names containing multiple dots; prefer strict extension checks (e.g., endswith .m3u ) and Path.stem . - Add early exits for empty selection, missing files, or a non-running cmus; handle #EXTM3U and comments. - Sorting tracks alphabetically may break track order; parse track numbers or use natural sorting. - Consider dropping pandas for a lightweight approach if performance or dependency size matters.","title":"Usage"},{"location":"scripts/ppm-color-reducer/","text":"No information could be generated for this binary file.","title":"Ppm color reducer"},{"location":"scripts/pyman.sh/","text":"PyMan: Interactive Python Manual Navigator pyman.sh : Interactive fuzzy finder for Python topics, keywords, builtins, and installed modules/packages. Dependencies python (with pydoc utility) : For module info, builtins, keywords, topics extraction fzf (fuzzy-finder) : UI for interactive searching and navigation bat (cat clone with syntax highlighting) : For previewing python/manual text nicely fd (find alternative) : For fast filesystem searching within site-packages rg (ripgrep) : For filtering/searching, used extensively in subcommands ranger (file manager, optional) : Opens directories inside site-packages notify-send : For quick-notification popups (feedback when navigating to source) $XDG_CACHE_HOME (recommended set) You may want to install these via your package manager if they're missing: sh sudo pacman -S python fzf bat fd ripgrep ranger libnotify Description This script is designed to serve as a \"manual browser\" for Python within your terminal, leveraging fzf for live, interactive exploration of: Installed site-packages and their modules Module submodules (recursively) Python builtins, keywords, help topics Functionality Highlights: - Custom functions ( get_topics , get_keywords , get_builtins , get_site_packages , get_submodules ) dynamically query and format results from your system's Python install. - bat provides syntax-highlighted previews of module source or documentation. - fzf is extensively customized with keybinds (see Usage) for switching between \"libraries, builtins, keywords, topics\", entering submodules, and showing previews. - When you choose a file, you get a preview, and can open source with bat , or enter directories with ranger . Custom Keybinds (fzf): - Alt+l : List all installed site-packages (\"Libs\") - Alt+b : Python builtins list - Alt+k : Python keywords - Alt+t : Python help topics - Alt+m : Drill into submodules (contextual to selection in \"Libs\") - Enter : Show source file with bat or open directory in ranger - Alt+p : Toggle preview pane Python version is auto-detected; everything runs in your shell context (Qtile/Arch-friendly: no X dependencies except notify-send ). Usage To launch the browser: ~/.scripts/bin/pyman.sh It will automatically display installed site-packages in an interactive fzf prompt: Navigate with arrow keys, fuzzy-search by typing Preview docs/source in the right pane (auto-wrap to terminal width) Switch modes (libs, builtins, topics, keywords) using Alt+key as described above Enter on an item to view source (or open directory in ranger if it's a package) Submodules can be browsed with Alt+m while on a package Notifications will indicate file/dir opened tldr: Launch in terminal and start exploring Python from all angles\u2014docs, source, and more\u2014using only your keyboard. [!NOTE] Strengths: - Highly interactive and leverages your terminal environment. - Great use of shell/Python tools and colors for readability. Potential Issues & Improvements: - Assumes python points to the desired interpreter and uses nonstandard regex for python -V ; might not work for Python 3.10+. - Some tools ( bat / fd / ranger ) are optional, yet script will fail if missing\u2014should ideally check for these and degrade gracefully. - The recursive submodule exploration (Alt+m) could confuse users with large or nested modules; might benefit from limiting depth or adding indicators. - Some functions produce lots of subshells. Could refactor heavy pipelines for efficiency and reproducibility. - $XDG_CACHE_HOME must be set or script will fail to create cache directories. Overall: Superb utility for Python power users! Robust and highly hackable; just needs a bit more polish and portability if you want to share it outside your own setup.","title":"PyMan: Interactive Python Manual Navigator"},{"location":"scripts/pyman.sh/#pyman-interactive-python-manual-navigator","text":"pyman.sh : Interactive fuzzy finder for Python topics, keywords, builtins, and installed modules/packages.","title":"PyMan: Interactive Python Manual Navigator"},{"location":"scripts/pyman.sh/#dependencies","text":"python (with pydoc utility) : For module info, builtins, keywords, topics extraction fzf (fuzzy-finder) : UI for interactive searching and navigation bat (cat clone with syntax highlighting) : For previewing python/manual text nicely fd (find alternative) : For fast filesystem searching within site-packages rg (ripgrep) : For filtering/searching, used extensively in subcommands ranger (file manager, optional) : Opens directories inside site-packages notify-send : For quick-notification popups (feedback when navigating to source) $XDG_CACHE_HOME (recommended set) You may want to install these via your package manager if they're missing: sh sudo pacman -S python fzf bat fd ripgrep ranger libnotify","title":"Dependencies"},{"location":"scripts/pyman.sh/#description","text":"This script is designed to serve as a \"manual browser\" for Python within your terminal, leveraging fzf for live, interactive exploration of: Installed site-packages and their modules Module submodules (recursively) Python builtins, keywords, help topics Functionality Highlights: - Custom functions ( get_topics , get_keywords , get_builtins , get_site_packages , get_submodules ) dynamically query and format results from your system's Python install. - bat provides syntax-highlighted previews of module source or documentation. - fzf is extensively customized with keybinds (see Usage) for switching between \"libraries, builtins, keywords, topics\", entering submodules, and showing previews. - When you choose a file, you get a preview, and can open source with bat , or enter directories with ranger . Custom Keybinds (fzf): - Alt+l : List all installed site-packages (\"Libs\") - Alt+b : Python builtins list - Alt+k : Python keywords - Alt+t : Python help topics - Alt+m : Drill into submodules (contextual to selection in \"Libs\") - Enter : Show source file with bat or open directory in ranger - Alt+p : Toggle preview pane Python version is auto-detected; everything runs in your shell context (Qtile/Arch-friendly: no X dependencies except notify-send ).","title":"Description"},{"location":"scripts/pyman.sh/#usage","text":"To launch the browser: ~/.scripts/bin/pyman.sh It will automatically display installed site-packages in an interactive fzf prompt: Navigate with arrow keys, fuzzy-search by typing Preview docs/source in the right pane (auto-wrap to terminal width) Switch modes (libs, builtins, topics, keywords) using Alt+key as described above Enter on an item to view source (or open directory in ranger if it's a package) Submodules can be browsed with Alt+m while on a package Notifications will indicate file/dir opened tldr: Launch in terminal and start exploring Python from all angles\u2014docs, source, and more\u2014using only your keyboard. [!NOTE] Strengths: - Highly interactive and leverages your terminal environment. - Great use of shell/Python tools and colors for readability. Potential Issues & Improvements: - Assumes python points to the desired interpreter and uses nonstandard regex for python -V ; might not work for Python 3.10+. - Some tools ( bat / fd / ranger ) are optional, yet script will fail if missing\u2014should ideally check for these and degrade gracefully. - The recursive submodule exploration (Alt+m) could confuse users with large or nested modules; might benefit from limiting depth or adding indicators. - Some functions produce lots of subshells. Could refactor heavy pipelines for efficiency and reproducibility. - $XDG_CACHE_HOME must be set or script will fail to create cache directories. Overall: Superb utility for Python power users! Robust and highly hackable; just needs a bit more polish and portability if you want to share it outside your own setup.","title":"Usage"},{"location":"scripts/qtile_dice_group.py/","text":"qtile_dice_group: Quick Switch to Complementary Qtile Group qtile_dice_group.py : Instantly switches to the workspace (\"group\") with a number summing to 7 with the current one. Dependencies python Standard Python 3 interpreter. libqtile.command.client.InteractiveCommandClient Qtile's IPC client for issuing commands to the running window manager instance. Qtile must be running as your window manager. Description This script provides a unique and fast way of jumping between two \"complementary\" numbered workspaces (Qtile calls them \"groups\") whose labels are integers. The complement is defined by the equation: complement = 7 - current_group_number For example, if you are currently on group 1 , running this script will take you to group 6 (because 1 + 6 = 7). Works best if you use six number-labeled groups (e.g. 1-6). How it Works Gets the current active group's name (assumes it's an integer in string form). Computes the complementary group number as 7 - <current group number> . Switches to the complementary group using Qtile's command interface, with no need for restarting Qtile or logging out. This setup is particularly useful for quickly toggling between pairs of workspaces, for example, focusing on two related tasks and switching context instantly. Usage Usually, you will want to bind this script to a key in Qtile's configuration or execute it in your terminal: $ python /home/matias/.scripts/bin/qtile_dice_group.py Keybinding Example ( ~/.config/qtile/config.py ): Key([mod], \"F12\", lazy.spawn(\"python /home/matias/.scripts/bin/qtile_dice_group.py\")), You can trigger this key to hop to the paired workspace instantly. No arguments or further configuration required, as long as your group names are numerically labeled. [!TIP] - Assumptions & Limitations : The script strictly assumes that the group names are digits ( 1 through 6 or more). If you're on a group whose name isn't an integer, it will crash with a ValueError . - It does not check whether the computed complementary group exists, so if you don't consistently maintain your group numbering/names, nothing will happen or you may get an error. - Consider wrapping the group lookup and switching in a try-except block for robustness. - You might want to parameterize the 7 to allow flexibility if you use a different number of groups. - No feedback or logging is provided on failure/success \u2014 adding some notification might improve UX.","title":"qtile_dice_group: Quick Switch to Complementary Qtile Group"},{"location":"scripts/qtile_dice_group.py/#qtile_dice_group-quick-switch-to-complementary-qtile-group","text":"qtile_dice_group.py : Instantly switches to the workspace (\"group\") with a number summing to 7 with the current one.","title":"qtile_dice_group: Quick Switch to Complementary Qtile Group"},{"location":"scripts/qtile_dice_group.py/#dependencies","text":"python Standard Python 3 interpreter. libqtile.command.client.InteractiveCommandClient Qtile's IPC client for issuing commands to the running window manager instance. Qtile must be running as your window manager.","title":"Dependencies"},{"location":"scripts/qtile_dice_group.py/#description","text":"This script provides a unique and fast way of jumping between two \"complementary\" numbered workspaces (Qtile calls them \"groups\") whose labels are integers. The complement is defined by the equation: complement = 7 - current_group_number For example, if you are currently on group 1 , running this script will take you to group 6 (because 1 + 6 = 7). Works best if you use six number-labeled groups (e.g. 1-6).","title":"Description"},{"location":"scripts/qtile_dice_group.py/#how-it-works","text":"Gets the current active group's name (assumes it's an integer in string form). Computes the complementary group number as 7 - <current group number> . Switches to the complementary group using Qtile's command interface, with no need for restarting Qtile or logging out. This setup is particularly useful for quickly toggling between pairs of workspaces, for example, focusing on two related tasks and switching context instantly.","title":"How it Works"},{"location":"scripts/qtile_dice_group.py/#usage","text":"Usually, you will want to bind this script to a key in Qtile's configuration or execute it in your terminal: $ python /home/matias/.scripts/bin/qtile_dice_group.py","title":"Usage"},{"location":"scripts/qtile_dice_group.py/#keybinding-example-configqtileconfigpy","text":"Key([mod], \"F12\", lazy.spawn(\"python /home/matias/.scripts/bin/qtile_dice_group.py\")), You can trigger this key to hop to the paired workspace instantly. No arguments or further configuration required, as long as your group names are numerically labeled. [!TIP] - Assumptions & Limitations : The script strictly assumes that the group names are digits ( 1 through 6 or more). If you're on a group whose name isn't an integer, it will crash with a ValueError . - It does not check whether the computed complementary group exists, so if you don't consistently maintain your group numbering/names, nothing will happen or you may get an error. - Consider wrapping the group lookup and switching in a try-except block for robustness. - You might want to parameterize the 7 to allow flexibility if you use a different number of groups. - No feedback or logging is provided on failure/success \u2014 adding some notification might improve UX.","title":"Keybinding Example (~/.config/qtile/config.py):"},{"location":"scripts/qtile_window_to_group_and_switch.py/","text":"Move Focused Window to Next/Previous Group and Switch \u2014 qtile_window_to_group_and_switch.py qtile_window_to_group_and_switch.py : Moves the current focused window to the next or previous qtile group and switches focus to that group Dependencies python (any version with qtile support) libqtile.command.client.InteractiveCommandClient Used for communicating with the running qtile instance to manipulate windows and groups. notify-send For graphical feedback in case of command misuse. Description This script is designed to be used with the qtile window manager on your Arch Linux system. It allows quick reassignment of the currently-focused window to another group, either the next ( -n ) or previous ( -p ), with an automatic switch to that group. The script uses InteractiveCommandClient to interface with the active qtile instance. Logic summary: Checks command-line argument ( -n for next, -p for previous). Determines current group index from qtile. Calculates the target group, cycling through 6 groups (uses modular arithmetic). Moves the window to the target group and switches to it. On wrong arguments, sends a critical notification using notify-send . Groups are numbered 1 through 6. The script wraps around: moving forward from group 6 brings you to group 1, and moving backward from group 1 brings you to group 6. Usage Run directly from your terminal, or (more likely) bind to key combinations in your qtile config as an efficient window management shortcut. Terminal invocation examples: ~/.scripts/bin/qtile_window_to_group_and_switch.py -n # Move to next group ~/.scripts/bin/qtile_window_to_group_and_switch.py -p # Move to previous group Typical qtile keybinding: Key([mod, \"shift\"], \"period\", lazy.spawn(\"~/.scripts/bin/qtile_window_to_group_and_switch.py -n\")), Key([mod, \"shift\"], \"comma\", lazy.spawn(\"~/.scripts/bin/qtile_window_to_group_and_switch.py -p\")), Error handling: If called with incorrect arguments, you'll get a critical urgency notification via notify-send , e.g.: Problem running /home/matias/.scripts/bin/qtile_window_to_group_and_switch.py [!TIP] - The \"6\" in current % 6 + 1 is hardcoded, so if you ever change the number of groups, this must be updated manually in the script. - No argument validation for missing or extra arguments: running without arguments or with invalid ones will cause an unhandled index error. - Consider adding a try/except block to gracefully handle missing argument cases (e.g., via argparse or manual checks). - If you use group names not strictly numbered \"1\" to \"6\", this will break. Either generalize the logic to get all groups from qtile dynamically, or maintain group numbers. - For larger configs, extracting group count directly from qtile's state would make this more robust.","title":"Move Focused Window to Next/Previous Group and Switch \u2014 qtile_window_to_group_and_switch.py"},{"location":"scripts/qtile_window_to_group_and_switch.py/#move-focused-window-to-nextprevious-group-and-switch-qtile_window_to_group_and_switchpy","text":"qtile_window_to_group_and_switch.py : Moves the current focused window to the next or previous qtile group and switches focus to that group","title":"Move Focused Window to Next/Previous Group and Switch \u2014 qtile_window_to_group_and_switch.py"},{"location":"scripts/qtile_window_to_group_and_switch.py/#dependencies","text":"python (any version with qtile support) libqtile.command.client.InteractiveCommandClient Used for communicating with the running qtile instance to manipulate windows and groups. notify-send For graphical feedback in case of command misuse.","title":"Dependencies"},{"location":"scripts/qtile_window_to_group_and_switch.py/#description","text":"This script is designed to be used with the qtile window manager on your Arch Linux system. It allows quick reassignment of the currently-focused window to another group, either the next ( -n ) or previous ( -p ), with an automatic switch to that group. The script uses InteractiveCommandClient to interface with the active qtile instance. Logic summary: Checks command-line argument ( -n for next, -p for previous). Determines current group index from qtile. Calculates the target group, cycling through 6 groups (uses modular arithmetic). Moves the window to the target group and switches to it. On wrong arguments, sends a critical notification using notify-send . Groups are numbered 1 through 6. The script wraps around: moving forward from group 6 brings you to group 1, and moving backward from group 1 brings you to group 6.","title":"Description"},{"location":"scripts/qtile_window_to_group_and_switch.py/#usage","text":"Run directly from your terminal, or (more likely) bind to key combinations in your qtile config as an efficient window management shortcut. Terminal invocation examples: ~/.scripts/bin/qtile_window_to_group_and_switch.py -n # Move to next group ~/.scripts/bin/qtile_window_to_group_and_switch.py -p # Move to previous group Typical qtile keybinding: Key([mod, \"shift\"], \"period\", lazy.spawn(\"~/.scripts/bin/qtile_window_to_group_and_switch.py -n\")), Key([mod, \"shift\"], \"comma\", lazy.spawn(\"~/.scripts/bin/qtile_window_to_group_and_switch.py -p\")), Error handling: If called with incorrect arguments, you'll get a critical urgency notification via notify-send , e.g.: Problem running /home/matias/.scripts/bin/qtile_window_to_group_and_switch.py [!TIP] - The \"6\" in current % 6 + 1 is hardcoded, so if you ever change the number of groups, this must be updated manually in the script. - No argument validation for missing or extra arguments: running without arguments or with invalid ones will cause an unhandled index error. - Consider adding a try/except block to gracefully handle missing argument cases (e.g., via argparse or manual checks). - If you use group names not strictly numbered \"1\" to \"6\", this will break. Either generalize the logic to get all groups from qtile dynamically, or maintain group numbers. - For larger configs, extracting group count directly from qtile's state would make this more robust.","title":"Usage"},{"location":"scripts/quick-pass.sh/","text":"QuickPass: Interactive Password Selection & Autofill quick-pass.sh : Fuzzy-find and copy your pass(1) passwords using fzf with one-click paste/edit support. Dependencies fd : Fast, user-friendly alternative to find (used here for searching GPG files). fzf : Command-line fuzzy finder for interactive selection. pass : Standard Unix password manager ( pass(1) ). xdotool : Simulates keyboard input (used for autofill via ctrl-x ). sort , sed , xargs : Standard Unix core utilities. Arch Linux packages: fd , fzf , pass , xdotool Note : PASSWORD_STORE_DIR environment variable should be set (defaults to ~/.password-store for pass ). Description This script provides a terminal-based interactive interface to your pass password store: File Discovery: Uses fd to quickly locate all .gpg files in your password-store directory. Pretty Formatting: Formats output with fd using nerd font icons and color codes for better readability in the selector. Fuzzy Search: Pipelined to fzf , allowing for fuzzy interactive selection of entries. Actions: CTRL-E : Edit the selected entry with pass edit . CTRL-X : Typing the password into the active window via xdotool type . Enter : Copies the selected password to your clipboard with pass (as per normal pass behavior). The selected entry is always extracted cleanly (stripping paths/extensions) and fed to pass . Usage You can run the script from your terminal or bind it to a key in Qtile for faster access: TL;DR quick-pass.sh Example Integration (Qtile keybinding) # In your Qtile config.py Key([mod], \"p\", lazy.spawn(\"~/.scripts/bin/quick-pass.sh\")), Keyboard Shortcuts Inside fzf Navigate with arrow keys, filter with fuzzy search. Enter : Reveal/password to clipboard. Ctrl-E : Edit password entry. Ctrl-X : Autofill password in the currently focused window with simulated keystrokes. [!TIP] There is a partial TODO for writing passwords directly to qutebrowser via FIFO; consider implementing this to expand browser integration. The color formatting ( fd_fmt ) assumes your terminal supports true color and nerdfont (for Unicode icons). As currently written, the script just outputs the password to stdout rather than copying it directly to the clipboard; consider using pass -c or piping output to xclip / wl-copy if you prefer that workflow. Ensure that xdotool -based paste with ctrl-x is only used in trusted contexts, as it types out your password. For portability, some hardcoded color codes and prompt formatting could be extracted into variables or config files. Handle edge cases like spaces in paths with care (wrap in quotes inside the script).","title":"QuickPass: Interactive Password Selection &amp; Autofill"},{"location":"scripts/quick-pass.sh/#quickpass-interactive-password-selection-autofill","text":"quick-pass.sh : Fuzzy-find and copy your pass(1) passwords using fzf with one-click paste/edit support.","title":"QuickPass: Interactive Password Selection &amp; Autofill"},{"location":"scripts/quick-pass.sh/#dependencies","text":"fd : Fast, user-friendly alternative to find (used here for searching GPG files). fzf : Command-line fuzzy finder for interactive selection. pass : Standard Unix password manager ( pass(1) ). xdotool : Simulates keyboard input (used for autofill via ctrl-x ). sort , sed , xargs : Standard Unix core utilities. Arch Linux packages: fd , fzf , pass , xdotool Note : PASSWORD_STORE_DIR environment variable should be set (defaults to ~/.password-store for pass ).","title":"Dependencies"},{"location":"scripts/quick-pass.sh/#description","text":"This script provides a terminal-based interactive interface to your pass password store: File Discovery: Uses fd to quickly locate all .gpg files in your password-store directory. Pretty Formatting: Formats output with fd using nerd font icons and color codes for better readability in the selector. Fuzzy Search: Pipelined to fzf , allowing for fuzzy interactive selection of entries. Actions: CTRL-E : Edit the selected entry with pass edit . CTRL-X : Typing the password into the active window via xdotool type . Enter : Copies the selected password to your clipboard with pass (as per normal pass behavior). The selected entry is always extracted cleanly (stripping paths/extensions) and fed to pass .","title":"Description"},{"location":"scripts/quick-pass.sh/#usage","text":"You can run the script from your terminal or bind it to a key in Qtile for faster access:","title":"Usage"},{"location":"scripts/quick-pass.sh/#tldr","text":"quick-pass.sh","title":"TL;DR"},{"location":"scripts/quick-pass.sh/#example-integration-qtile-keybinding","text":"# In your Qtile config.py Key([mod], \"p\", lazy.spawn(\"~/.scripts/bin/quick-pass.sh\")),","title":"Example Integration (Qtile keybinding)"},{"location":"scripts/quick-pass.sh/#keyboard-shortcuts-inside-fzf","text":"Navigate with arrow keys, filter with fuzzy search. Enter : Reveal/password to clipboard. Ctrl-E : Edit password entry. Ctrl-X : Autofill password in the currently focused window with simulated keystrokes. [!TIP] There is a partial TODO for writing passwords directly to qutebrowser via FIFO; consider implementing this to expand browser integration. The color formatting ( fd_fmt ) assumes your terminal supports true color and nerdfont (for Unicode icons). As currently written, the script just outputs the password to stdout rather than copying it directly to the clipboard; consider using pass -c or piping output to xclip / wl-copy if you prefer that workflow. Ensure that xdotool -based paste with ctrl-x is only used in trusted contexts, as it types out your password. For portability, some hardcoded color codes and prompt formatting could be extracted into variables or config files. Handle edge cases like spaces in paths with care (wrap in quotes inside the script).","title":"Keyboard Shortcuts Inside fzf"},{"location":"scripts/qutebrowser-modify-source-bookmarks.sh/","text":"qutebrowser Bookmark & Session Sync Script qutebrowser-modify-source-bookmarks.sh : Synchronizes qutebrowser bookmarks, quickmarks, and sessions with chezmoi dotfiles. Dependencies qutebrowser Web browser\u2014must have bookmarks and quickmarks functionality enabled. chezmoi A dotfiles manager, used here to track changes and source control your config files. fd Simple, fast file search utility used for finding .yml session files. git (commented out in script) For version control of synced files within chezmoi repository. Environment variables required: $XDG_CONFIG_HOME $XDG_DATA_HOME $CHEZMOI $LOCALDATA Description This script is intended to be used on an Arch Linux system, specifically by users managing qutebrowser bookmarks, quickmarks, and session files with chezmoi . It synchronizes your current browser data (from local qutebrowser config locations) to your chezmoi-managed dotfiles directory. Key actions: Waits 20 seconds to ensure new quickmarks are written (e.g., after adding via qutebrowser). Copies local bookmarks and quickmarks files to your chezmoi repository. Finds all .yml session files and ensures they're tracked in chezmoi. If not already under chezmoi control, adds them with chezmoi add . Copies updated session files to a parallel session storage directory ( $LOCALDATA/qutebrowser/sessions ). Contains optional (commented out) steps for automatically committing and pushing changes to a git repository within the chezmoi directory. Usage Basic usage: ~/.scripts/bin/qutebrowser-modify-source-bookmarks.sh Practical integration: Run this script after making changes to your bookmarks or quickmarks in qutebrowser. For smoother workflow, consider binding it to a qtile key or running it via a custom menu, e.g.: python # in your qtile config Key([mod], \"F8\", lazy.spawn(\"~/.scripts/bin/qutebrowser-modify-source-bookmarks.sh\")) Example cronjob (if you want periodic syncs): */30 * * * * /home/matias/.scripts/bin/qutebrowser-modify-source-bookmarks.sh [!TIP] - The script assumes all relevant environment variables are set and directories exist. If not, it will fail silently or produce confusing errors. - The 20 second sleep before copying quickmarks could be optimized (e.g., watching file change instead of a fixed sleep). - Consider uncommenting and robustifying the git commit/push section for automatic version control. - You might want to add error handling for missing files or unset variables for robustness. - For performance, using rsync instead of cat /file copying could be considered, especially when large session files are involved.","title":"qutebrowser Bookmark &amp; Session Sync Script"},{"location":"scripts/qutebrowser-modify-source-bookmarks.sh/#qutebrowser-bookmark-session-sync-script","text":"qutebrowser-modify-source-bookmarks.sh : Synchronizes qutebrowser bookmarks, quickmarks, and sessions with chezmoi dotfiles.","title":"qutebrowser Bookmark &amp; Session Sync Script"},{"location":"scripts/qutebrowser-modify-source-bookmarks.sh/#dependencies","text":"qutebrowser Web browser\u2014must have bookmarks and quickmarks functionality enabled. chezmoi A dotfiles manager, used here to track changes and source control your config files. fd Simple, fast file search utility used for finding .yml session files. git (commented out in script) For version control of synced files within chezmoi repository. Environment variables required: $XDG_CONFIG_HOME $XDG_DATA_HOME $CHEZMOI $LOCALDATA","title":"Dependencies"},{"location":"scripts/qutebrowser-modify-source-bookmarks.sh/#description","text":"This script is intended to be used on an Arch Linux system, specifically by users managing qutebrowser bookmarks, quickmarks, and session files with chezmoi . It synchronizes your current browser data (from local qutebrowser config locations) to your chezmoi-managed dotfiles directory. Key actions: Waits 20 seconds to ensure new quickmarks are written (e.g., after adding via qutebrowser). Copies local bookmarks and quickmarks files to your chezmoi repository. Finds all .yml session files and ensures they're tracked in chezmoi. If not already under chezmoi control, adds them with chezmoi add . Copies updated session files to a parallel session storage directory ( $LOCALDATA/qutebrowser/sessions ). Contains optional (commented out) steps for automatically committing and pushing changes to a git repository within the chezmoi directory.","title":"Description"},{"location":"scripts/qutebrowser-modify-source-bookmarks.sh/#usage","text":"Basic usage: ~/.scripts/bin/qutebrowser-modify-source-bookmarks.sh Practical integration: Run this script after making changes to your bookmarks or quickmarks in qutebrowser. For smoother workflow, consider binding it to a qtile key or running it via a custom menu, e.g.: python # in your qtile config Key([mod], \"F8\", lazy.spawn(\"~/.scripts/bin/qutebrowser-modify-source-bookmarks.sh\")) Example cronjob (if you want periodic syncs): */30 * * * * /home/matias/.scripts/bin/qutebrowser-modify-source-bookmarks.sh [!TIP] - The script assumes all relevant environment variables are set and directories exist. If not, it will fail silently or produce confusing errors. - The 20 second sleep before copying quickmarks could be optimized (e.g., watching file change instead of a fixed sleep). - Consider uncommenting and robustifying the git commit/push section for automatic version control. - You might want to add error handling for missing files or unset variables for robustness. - For performance, using rsync instead of cat /file copying could be considered, especially when large session files are involved.","title":"Usage"},{"location":"scripts/random_album.xsh/","text":"Random CMUS Album Shuffle random_album.xsh : Select 10 random albums from cmus and start playback Dependencies xonsh \u2014 shell interpreter used to run the script cmus \u2014 console music player cmus-remote \u2014 remote control CLI for cmus ~/.config/cmus/lib.pl \u2014 cmus library index used to list all tracks Description This Xonsh script builds a temporary M3U playlist from 10 randomly selected albums in your cmus library and starts playback. How it works: - Clears the current cmus playlist and switches to the playlist view. - Reads track paths from your cmus library file ( ~/.config/cmus/lib.pl ). - Extracts album identifiers as \u201cArtist/Album\u201d from each track path. - Shuffles the album list, picks the first 10, then gathers all tracks belonging to those albums. - Writes the resulting track list to /tmp/tmp.m3u , queues it in cmus, and starts playing. It uses Xonsh\u2019s command capture $(...) to read the library file and Python\u2019s random to shuffle. Paths are matched by checking if \u201cArtist/Album/\u201d appears in the full track path, which is a lightweight way to group tracks by album when the library is path-structured. Usage Run directly from a terminal: ~/.scripts/bin/random_album.xsh Bind to a Qtile key (Arch Linux): # in ~/.config/qtile/config.py from libqtile.config import Key from libqtile.lazy import lazy keys += [ Key([mod], \"F9\", lazy.spawn(\"xonsh ~/.scripts/bin/random_album.xsh\")), ] Run periodically (systemd user timer example snippet): systemctl --user start random-album.service Then implement ExecStart in the service as: ExecStart=/usr/bin/xonsh /home/matias/.scripts/bin/random_album.xsh tldr: - Refill cmus with 10 random albums and play: run the script. - Rerun anytime to reshuffle. [!TIP] - Path bug: $(cat .config/cmus/lib.pl) is relative; use ~/.config/cmus/lib.pl via os.path.expanduser to avoid failures outside $HOME. - Fragile count: range(10) will crash if less than 10 albums exist; prefer random.sample(albums, k=min(10, len(albums))) . - Temp file clobbering: /tmp/tmp.m3u may collide; use a unique file ( tempfile.NamedTemporaryFile ) and remove after use. - Matching robustness: string \u201cin\u201d matching can misfire on similar names; consider grouping by parsed path components for exact artist/album directories. - Performance: avoid external cat ; read the file with Python for speed and fewer dependencies. - Behavior: cmus-remote -n skips the first track; remove if you want to start from track 1.","title":"Random CMUS Album Shuffle"},{"location":"scripts/random_album.xsh/#random-cmus-album-shuffle","text":"random_album.xsh : Select 10 random albums from cmus and start playback","title":"Random CMUS Album Shuffle"},{"location":"scripts/random_album.xsh/#dependencies","text":"xonsh \u2014 shell interpreter used to run the script cmus \u2014 console music player cmus-remote \u2014 remote control CLI for cmus ~/.config/cmus/lib.pl \u2014 cmus library index used to list all tracks","title":"Dependencies"},{"location":"scripts/random_album.xsh/#description","text":"This Xonsh script builds a temporary M3U playlist from 10 randomly selected albums in your cmus library and starts playback. How it works: - Clears the current cmus playlist and switches to the playlist view. - Reads track paths from your cmus library file ( ~/.config/cmus/lib.pl ). - Extracts album identifiers as \u201cArtist/Album\u201d from each track path. - Shuffles the album list, picks the first 10, then gathers all tracks belonging to those albums. - Writes the resulting track list to /tmp/tmp.m3u , queues it in cmus, and starts playing. It uses Xonsh\u2019s command capture $(...) to read the library file and Python\u2019s random to shuffle. Paths are matched by checking if \u201cArtist/Album/\u201d appears in the full track path, which is a lightweight way to group tracks by album when the library is path-structured.","title":"Description"},{"location":"scripts/random_album.xsh/#usage","text":"Run directly from a terminal: ~/.scripts/bin/random_album.xsh Bind to a Qtile key (Arch Linux): # in ~/.config/qtile/config.py from libqtile.config import Key from libqtile.lazy import lazy keys += [ Key([mod], \"F9\", lazy.spawn(\"xonsh ~/.scripts/bin/random_album.xsh\")), ] Run periodically (systemd user timer example snippet): systemctl --user start random-album.service Then implement ExecStart in the service as: ExecStart=/usr/bin/xonsh /home/matias/.scripts/bin/random_album.xsh tldr: - Refill cmus with 10 random albums and play: run the script. - Rerun anytime to reshuffle. [!TIP] - Path bug: $(cat .config/cmus/lib.pl) is relative; use ~/.config/cmus/lib.pl via os.path.expanduser to avoid failures outside $HOME. - Fragile count: range(10) will crash if less than 10 albums exist; prefer random.sample(albums, k=min(10, len(albums))) . - Temp file clobbering: /tmp/tmp.m3u may collide; use a unique file ( tempfile.NamedTemporaryFile ) and remove after use. - Matching robustness: string \u201cin\u201d matching can misfire on similar names; consider grouping by parsed path components for exact artist/album directories. - Performance: avoid external cat ; read the file with Python for speed and fewer dependencies. - Behavior: cmus-remote -n skips the first track; remove if you want to start from track 1.","title":"Usage"},{"location":"scripts/random_wallpapers.xsh/","text":"Random Wallpaper Chooser random_wallpapers.xsh : Script to set a random wallpaper from the ~/.wallpapers directory. Dependencies xonsh : Python-powered shell language; required to interpret this script. feh : Lightweight image viewer and wallpaper setter. dmenu (commented-out): Fast, dynamic menu for X, useful for selecting wallpapers interactively ([currently not used in the script]). Description This Xonsh script, intended for use on Arch Linux (with qtile as the Window Manager), selects a random PNG or JPG image from your ~/.wallpapers directory and sets it as the desktop wallpaper using feh with the --bg-scale option. How it works: - Lists all files in your wallpaper folder. - Filters for files with .png or .jpg extensions. - Randomly picks one. - Sets it as your wallpaper. - Includes a commented-out section for using dmenu to interactively pick a wallpaper, but this code path is currently disabled. Usage Default usage is to run from your preferred shell or keybinding\u2014no arguments required. xonsh /home/matias/.scripts/bin/random_wallpapers.xsh As a qtile keybinding Example (in your config.py ): Key([mod], \"w\", lazy.spawn(\"xonsh /home/matias/.scripts/bin/random_wallpapers.xsh\"), desc=\"Set random wallpaper\"), TL;DR Place images ( .png , .jpg ) in ~/.wallpapers . Run the script: xonsh /home/matias/.scripts/bin/random_wallpapers.xsh Enjoy a new random desktop background! [!NOTE] Critique & Suggestions: - If ~/.wallpapers contains files with uppercase extensions ( .JPG , .PNG ), they will not be recognized. You could use .lower() to handle case-insensitive matches. - No check for empty wallpaper directory; consider adding a condition to handle this gracefully. - For a larger or more dynamic collection of wallpapers (nested folders), a recursive approach using os.walk() might be useful. - The commented-out dmenu functionality could be toggled via a command-line flag for interactive vs. random selecting. - Using feh --bg-scale ... works well for most cases but may stretch or compress wallpapers; consider --bg-fill or others depending on your preference.","title":"Random Wallpaper Chooser"},{"location":"scripts/random_wallpapers.xsh/#random-wallpaper-chooser","text":"random_wallpapers.xsh : Script to set a random wallpaper from the ~/.wallpapers directory.","title":"Random Wallpaper Chooser"},{"location":"scripts/random_wallpapers.xsh/#dependencies","text":"xonsh : Python-powered shell language; required to interpret this script. feh : Lightweight image viewer and wallpaper setter. dmenu (commented-out): Fast, dynamic menu for X, useful for selecting wallpapers interactively ([currently not used in the script]).","title":"Dependencies"},{"location":"scripts/random_wallpapers.xsh/#description","text":"This Xonsh script, intended for use on Arch Linux (with qtile as the Window Manager), selects a random PNG or JPG image from your ~/.wallpapers directory and sets it as the desktop wallpaper using feh with the --bg-scale option. How it works: - Lists all files in your wallpaper folder. - Filters for files with .png or .jpg extensions. - Randomly picks one. - Sets it as your wallpaper. - Includes a commented-out section for using dmenu to interactively pick a wallpaper, but this code path is currently disabled.","title":"Description"},{"location":"scripts/random_wallpapers.xsh/#usage","text":"Default usage is to run from your preferred shell or keybinding\u2014no arguments required. xonsh /home/matias/.scripts/bin/random_wallpapers.xsh","title":"Usage"},{"location":"scripts/random_wallpapers.xsh/#as-a-qtile-keybinding","text":"Example (in your config.py ): Key([mod], \"w\", lazy.spawn(\"xonsh /home/matias/.scripts/bin/random_wallpapers.xsh\"), desc=\"Set random wallpaper\"),","title":"As a qtile keybinding"},{"location":"scripts/random_wallpapers.xsh/#tldr","text":"Place images ( .png , .jpg ) in ~/.wallpapers . Run the script: xonsh /home/matias/.scripts/bin/random_wallpapers.xsh Enjoy a new random desktop background! [!NOTE] Critique & Suggestions: - If ~/.wallpapers contains files with uppercase extensions ( .JPG , .PNG ), they will not be recognized. You could use .lower() to handle case-insensitive matches. - No check for empty wallpaper directory; consider adding a condition to handle this gracefully. - For a larger or more dynamic collection of wallpapers (nested folders), a recursive approach using os.walk() might be useful. - The commented-out dmenu functionality could be toggled via a command-line flag for interactive vs. random selecting. - Using feh --bg-scale ... works well for most cases but may stretch or compress wallpapers; consider --bg-fill or others depending on your preference.","title":"TL;DR"},{"location":"scripts/read_the_fucking_manual.sh/","text":"RTMF: Read The Fucking Manual History Query Tool read_the_fucking_manual.sh : Query and analyze your man / batman usage history for most searched entries. Dependencies bat \u2014 Enhanced cat clone, used here to pretty print help. ripgrep ( rg ) \u2014 Fast, recursive search tool for filtering and searching entries. sed , awk , cut , sort , uniq \u2014 Standard Unix command-line tools for parsing and analyzing your shell history. Your shell ( bash and/or zsh ) must store history files at $XDG_STATE_HOME/bash/history and $XDG_STATE_HOME/zsh/history . Optional: batman ( bat + man ), if you also use that for reading manuals. Description This script aggregates and analyzes your usage of man and batman , helping you identify which manuals you check the most. It parses your history files (both Bash and Zsh), extracts invocations of man and batman , and summarizes how often each manual page is looked up. Key features: - Top searches : Displays your most frequently referenced manual pages. - Threshold filtering : Show only entries above a certain number of searches. - Flexible search : Pass any arguments, and they are sent to ripgrep for powerful filtering. - Customizable count : Show as many (or as few) results as you want. How it works Combines history from Bash and Zsh. Pulls out all manual lookups ( man or batman commands), ignoring options and only capturing the main entry/page. Counts and sorts entries, so you immediately see which tools you reference the most. Usage $ read_the_fucking_manual.sh # Show the 10 most searched manual entries $ read_the_fucking_manual.sh -n 20 # Show the top 20 most searched $ read_the_fucking_manual.sh --all # Show all searched manual pages sorted by frequency $ read_the_fucking_manual.sh --more-than 2 # Show all entries searched more than twice $ read_the_fucking_manual.sh ls # Search for entries matching \"ls\" pattern (uses ripgrep) $ read_the_fucking_manual.sh -h # Show help text in a pretty way (via bat) You can run this script interactively in a terminal or bind it to a key in Qtile for quick access. [!TIP] The script assumes your Bash and Zsh history files are located at $XDG_STATE_HOME/bash/history and $XDG_STATE_HOME/zsh/history , which may not match your current setup (default is usually $HOME/.bash_history / .zsh_history ). Consider making this configurable or more autodetecting. Filtering out arguments after man/batman may sometimes drop intended multi-word lookups (like man git log ), so the counting is on the first word after man . No colored output except for the help section; you might want to add color to the frequency column for clarity. Edge case: If $2 isn't set for some options, the script might misbehave. Add input validation for safer argument parsing. Consider supporting other shells or making the history path override via env variable or script argument.","title":"RTMF: Read The Fucking Manual History Query Tool"},{"location":"scripts/read_the_fucking_manual.sh/#rtmf-read-the-fucking-manual-history-query-tool","text":"read_the_fucking_manual.sh : Query and analyze your man / batman usage history for most searched entries.","title":"RTMF: Read The Fucking Manual History Query Tool"},{"location":"scripts/read_the_fucking_manual.sh/#dependencies","text":"bat \u2014 Enhanced cat clone, used here to pretty print help. ripgrep ( rg ) \u2014 Fast, recursive search tool for filtering and searching entries. sed , awk , cut , sort , uniq \u2014 Standard Unix command-line tools for parsing and analyzing your shell history. Your shell ( bash and/or zsh ) must store history files at $XDG_STATE_HOME/bash/history and $XDG_STATE_HOME/zsh/history . Optional: batman ( bat + man ), if you also use that for reading manuals.","title":"Dependencies"},{"location":"scripts/read_the_fucking_manual.sh/#description","text":"This script aggregates and analyzes your usage of man and batman , helping you identify which manuals you check the most. It parses your history files (both Bash and Zsh), extracts invocations of man and batman , and summarizes how often each manual page is looked up. Key features: - Top searches : Displays your most frequently referenced manual pages. - Threshold filtering : Show only entries above a certain number of searches. - Flexible search : Pass any arguments, and they are sent to ripgrep for powerful filtering. - Customizable count : Show as many (or as few) results as you want.","title":"Description"},{"location":"scripts/read_the_fucking_manual.sh/#how-it-works","text":"Combines history from Bash and Zsh. Pulls out all manual lookups ( man or batman commands), ignoring options and only capturing the main entry/page. Counts and sorts entries, so you immediately see which tools you reference the most.","title":"How it works"},{"location":"scripts/read_the_fucking_manual.sh/#usage","text":"$ read_the_fucking_manual.sh # Show the 10 most searched manual entries $ read_the_fucking_manual.sh -n 20 # Show the top 20 most searched $ read_the_fucking_manual.sh --all # Show all searched manual pages sorted by frequency $ read_the_fucking_manual.sh --more-than 2 # Show all entries searched more than twice $ read_the_fucking_manual.sh ls # Search for entries matching \"ls\" pattern (uses ripgrep) $ read_the_fucking_manual.sh -h # Show help text in a pretty way (via bat) You can run this script interactively in a terminal or bind it to a key in Qtile for quick access. [!TIP] The script assumes your Bash and Zsh history files are located at $XDG_STATE_HOME/bash/history and $XDG_STATE_HOME/zsh/history , which may not match your current setup (default is usually $HOME/.bash_history / .zsh_history ). Consider making this configurable or more autodetecting. Filtering out arguments after man/batman may sometimes drop intended multi-word lookups (like man git log ), so the counting is on the first word after man . No colored output except for the help section; you might want to add color to the frequency column for clarity. Edge case: If $2 isn't set for some options, the script might misbehave. Add input validation for safer argument parsing. Consider supporting other shells or making the history path override via env variable or script argument.","title":"Usage"},{"location":"scripts/rgfzf.sh/","text":"rgfzf.sh \u2014 Fuzzy Ripgrep/Vim file opener rgfzf.sh : Search for text using ripgrep + fuzzy finder, preview with bat, open in neovim. Dependencies rg Ripgrep for fast file and text searching. fzf Fuzzy finder, provides interactive UI for selecting results. bat For previewing file content with syntax highlighting. nvim Opens the selected file and line (swap for another editor if needed). bash Required for the script and fzf interactions. Description This script allows you to: Search files for some text using ripgrep ( rg ). Pipe the results to fzf for interactive, incremental narrowing. Use bat to preview search matches in context and with syntax highlighting. Open the selected file at the given line with nvim (great for code navigation). The command pipeline works like this: - Results from rg are fed to fzf ( fzf --ansi for color compat). - fzf parses results using : as the delimiter ( filename:line:text ). - On selection, a floating preview window pops up ( bat , colored), highlighting the relevant line. - Pressing enter launches nvim at the selected file and line. Example run: Suppose you search for a string: rgfzf.sh 'def main' You\u2019ll get a live-updating list of ripgrep hits, fuzzy filter it, preview with bat, and Enter to jump to code in neovim. Usage # Search for a string in the current directory and subdirectories rgfzf.sh <search_terms> # Example: Find all \"TODO\" comments rgfzf.sh TODO # For interactivity via keybinding (Qtile / sxhkd) # In your config: bind a key to run this script (ensure terminal popup) You can run rgfzf.sh <pattern> from any directory. If assigned to a keybinding, it works best if your terminal will pop up (such as with a scratchpad in Qtile). [!TIP] - nvim is hardcoded; consider passing your preferred editor as an argument or environment variable. - The preview window is set at 60% height; this could be adjusted for smaller/larger terminals. - If bat or fzf are missing, the script will fail silently. Defensive checks could improve the UX. - The script doesn\u2019t work in directories with no ripgrep hits; some user feedback here could help. - If you use kitty , alacritty or similar GPU terminals, preview/ansi-rendering will look best.","title":"rgfzf.sh \u2014 Fuzzy Ripgrep/Vim file opener"},{"location":"scripts/rgfzf.sh/#rgfzfsh-fuzzy-ripgrepvim-file-opener","text":"rgfzf.sh : Search for text using ripgrep + fuzzy finder, preview with bat, open in neovim.","title":"rgfzf.sh \u2014 Fuzzy Ripgrep/Vim file opener"},{"location":"scripts/rgfzf.sh/#dependencies","text":"rg Ripgrep for fast file and text searching. fzf Fuzzy finder, provides interactive UI for selecting results. bat For previewing file content with syntax highlighting. nvim Opens the selected file and line (swap for another editor if needed). bash Required for the script and fzf interactions.","title":"Dependencies"},{"location":"scripts/rgfzf.sh/#description","text":"This script allows you to: Search files for some text using ripgrep ( rg ). Pipe the results to fzf for interactive, incremental narrowing. Use bat to preview search matches in context and with syntax highlighting. Open the selected file at the given line with nvim (great for code navigation). The command pipeline works like this: - Results from rg are fed to fzf ( fzf --ansi for color compat). - fzf parses results using : as the delimiter ( filename:line:text ). - On selection, a floating preview window pops up ( bat , colored), highlighting the relevant line. - Pressing enter launches nvim at the selected file and line.","title":"Description"},{"location":"scripts/rgfzf.sh/#example-run","text":"Suppose you search for a string: rgfzf.sh 'def main' You\u2019ll get a live-updating list of ripgrep hits, fuzzy filter it, preview with bat, and Enter to jump to code in neovim.","title":"Example run:"},{"location":"scripts/rgfzf.sh/#usage","text":"# Search for a string in the current directory and subdirectories rgfzf.sh <search_terms> # Example: Find all \"TODO\" comments rgfzf.sh TODO # For interactivity via keybinding (Qtile / sxhkd) # In your config: bind a key to run this script (ensure terminal popup) You can run rgfzf.sh <pattern> from any directory. If assigned to a keybinding, it works best if your terminal will pop up (such as with a scratchpad in Qtile). [!TIP] - nvim is hardcoded; consider passing your preferred editor as an argument or environment variable. - The preview window is set at 60% height; this could be adjusted for smaller/larger terminals. - If bat or fzf are missing, the script will fail silently. Defensive checks could improve the UX. - The script doesn\u2019t work in directories with no ripgrep hits; some user feedback here could help. - If you use kitty , alacritty or similar GPU terminals, preview/ansi-rendering will look best.","title":"Usage"},{"location":"scripts/sandisk_music_transfert.py/","text":"Sandisk Music Transfer Tool sandisk_music_transfert.py : Transfers unplayed albums from your music library to your Sandisk media player, automatically fitting them to available space. Dependencies python >= 3 pandas : For DataFrame operations. os , subprocess , random : Python standard libraries. rsync (system command) : Efficient file transfer. beets ( beet command): Music library manager, used here to query album statuses. du , rm , mkdir , sudo : Shell utilities for disk usage checking and file operations. Optionally : - getpass (commented; for password requests during sudo operations). Description This script automates the process of syncing not-yet-listened music albums from your local beets music library to a Sandisk media player's mounted storage (presumed automounted at /run/media/matias/EC95-4FBB/Music ). It performs the following actions: Queries your beets library for albums marked as unplayed ( status:0 ). Calculates their disk usage. Randomly drops artists from the transfer list until the sum of albums fits within your defined device space limit ( MAX_SPACE ). Removes old albums from the device that are no longer in the transfer list. Cleans up empty folders on the device. Creates any necessary folder structure for new albums. Uses rsync to efficiently sync albums over to the device, ensuring that only new/updated files are transferred. It is primarily useful for workflow automation (such as from a terminal or invoked in a qtile keybinding), targeting creative control over your portable music collection while not exceeding device capacity. Usage Ensure the device is mounted at the path configured in player_path . Ensure your beets library is up to date, and that beet CLI works. Run the script directly: python ~/.scripts/bin/sandisk_music_transfert.py For regular usage, consider a keybinding in your qtile config: Key([], \"F10\", lazy.spawn(\"python ~/.scripts/bin/sandisk_music_transfert.py\")) Note: If you uncomment getpass , you may be prompted for your sudo password when deleting old files on the device. [!WARNING] Critique: - The script references password in proc.communicate(password.encode()) but this variable is commented out, so the script will crash if deletions are necessary\u2014uncomment and assign password before use. - The construction of DataFrames using pd.DataFrame has a faulty syntax ( 'path' : album_paths dict keys must be in curly braces, not lambda form). This will cause runtime errors. - Usage of os.path.isdir(i) in the context i in os.listdir(player_path) is incorrect; i should be an absolute path. - Error handling is minimal; if rsync or mkdir fails mid-process, script does not recover gracefully. - The script assumes all music folders strictly follow a consistent naming pattern and directory structure. - Some string interpolations/f-strings use a wrong syntax ( f\"len(album_paths)}...\" ). - Filtering out the 'cover.jpg' file in 'format' list comprehension is done incorrectly. - Hardcoding file paths and device ID reduces portability. Consider moving configurations to the script\u2019s header or to a config file for easier edits. - Consider running dry-runs first when developing automation that deletes data. Recommended: Refactor, add argument parsing for flexibility, robust error handling, and test with smaller directories first.","title":"Sandisk Music Transfer Tool"},{"location":"scripts/sandisk_music_transfert.py/#sandisk-music-transfer-tool","text":"sandisk_music_transfert.py : Transfers unplayed albums from your music library to your Sandisk media player, automatically fitting them to available space.","title":"Sandisk Music Transfer Tool"},{"location":"scripts/sandisk_music_transfert.py/#dependencies","text":"python >= 3 pandas : For DataFrame operations. os , subprocess , random : Python standard libraries. rsync (system command) : Efficient file transfer. beets ( beet command): Music library manager, used here to query album statuses. du , rm , mkdir , sudo : Shell utilities for disk usage checking and file operations. Optionally : - getpass (commented; for password requests during sudo operations).","title":"Dependencies"},{"location":"scripts/sandisk_music_transfert.py/#description","text":"This script automates the process of syncing not-yet-listened music albums from your local beets music library to a Sandisk media player's mounted storage (presumed automounted at /run/media/matias/EC95-4FBB/Music ). It performs the following actions: Queries your beets library for albums marked as unplayed ( status:0 ). Calculates their disk usage. Randomly drops artists from the transfer list until the sum of albums fits within your defined device space limit ( MAX_SPACE ). Removes old albums from the device that are no longer in the transfer list. Cleans up empty folders on the device. Creates any necessary folder structure for new albums. Uses rsync to efficiently sync albums over to the device, ensuring that only new/updated files are transferred. It is primarily useful for workflow automation (such as from a terminal or invoked in a qtile keybinding), targeting creative control over your portable music collection while not exceeding device capacity.","title":"Description"},{"location":"scripts/sandisk_music_transfert.py/#usage","text":"Ensure the device is mounted at the path configured in player_path . Ensure your beets library is up to date, and that beet CLI works. Run the script directly: python ~/.scripts/bin/sandisk_music_transfert.py For regular usage, consider a keybinding in your qtile config: Key([], \"F10\", lazy.spawn(\"python ~/.scripts/bin/sandisk_music_transfert.py\")) Note: If you uncomment getpass , you may be prompted for your sudo password when deleting old files on the device. [!WARNING] Critique: - The script references password in proc.communicate(password.encode()) but this variable is commented out, so the script will crash if deletions are necessary\u2014uncomment and assign password before use. - The construction of DataFrames using pd.DataFrame has a faulty syntax ( 'path' : album_paths dict keys must be in curly braces, not lambda form). This will cause runtime errors. - Usage of os.path.isdir(i) in the context i in os.listdir(player_path) is incorrect; i should be an absolute path. - Error handling is minimal; if rsync or mkdir fails mid-process, script does not recover gracefully. - The script assumes all music folders strictly follow a consistent naming pattern and directory structure. - Some string interpolations/f-strings use a wrong syntax ( f\"len(album_paths)}...\" ). - Filtering out the 'cover.jpg' file in 'format' list comprehension is done incorrectly. - Hardcoding file paths and device ID reduces portability. Consider moving configurations to the script\u2019s header or to a config file for easier edits. - Consider running dry-runs first when developing automation that deletes data. Recommended: Refactor, add argument parsing for flexibility, robust error handling, and test with smaller directories first.","title":"Usage"},{"location":"scripts/screenshot.sh/","text":"screenshot.sh \u2013 Screenshot Utility Script screenshot.sh : Simple utility for taking fullscreen or user-selected screenshots using grim . Dependencies grim Wayland screenshot utility used to capture the screen or region. slurp Region selector for Wayland; used to draw a selection box. notify-send Desktop notification tool to show messages after saving screenshots. Description This script streamlines taking screenshots under a Wayland environment (such as Sway or river). Screenshots are saved in your $HOME/Pictures folder with a timestamped filename for easy organization. Functionality: - Fullscreen screenshot: By default ( no arguments ), the entire display is captured. - Area selection screenshot: When called with --select , allows interactive selection of a screen region. Uses slurp to let you define a region with the mouse, then captures it via grim . Notifications: Every time a screenshot is taken, the script sends a desktop notification showing the saved filename using notify-send . Usage The script can be run directly in the terminal, bound to a keybinding in qtile , or called from a script/shortcut. Examples: # Fullscreen screenshot ~/.scripts/bin/screenshot.sh # Interactive area selection ~/.scripts/bin/screenshot.sh --select You can set this up as a keybinding in your qtile config. Example: Key([mod], \"Print\", lazy.spawn(\"~/.scripts/bin/screenshot.sh\")), Key([mod, \"shift\"], \"Print\", lazy.spawn(\"~/.scripts/bin/screenshot.sh --select\")), Output: - All screenshots are saved to ~/Pictures with a format like 2024-06-30-screenshot-1719758632.png . [!TIP] If $HOME/Pictures does not exist, the script will fail to save the screenshot. Consider adding a check to create the directory if missing ( mkdir -p \"$_OUTPUT_DIR\" ). There\u2019s no error handling: if grim , slurp , or notify-send are missing or fail, you won\u2019t get any warning. The notification message is always \"Selection saved as ...\" even for fullscreen shots\u2014consider customizing the message for clarity. Minor: Script could use local for variables to restrict scope, though in this context it's not critical. For further flexibility, you might want to allow custom output directory or filename prefix via command-line arguments.","title":"screenshot.sh \u2013 Screenshot Utility Script"},{"location":"scripts/screenshot.sh/#screenshotsh-screenshot-utility-script","text":"screenshot.sh : Simple utility for taking fullscreen or user-selected screenshots using grim .","title":"screenshot.sh \u2013 Screenshot Utility Script"},{"location":"scripts/screenshot.sh/#dependencies","text":"grim Wayland screenshot utility used to capture the screen or region. slurp Region selector for Wayland; used to draw a selection box. notify-send Desktop notification tool to show messages after saving screenshots.","title":"Dependencies"},{"location":"scripts/screenshot.sh/#description","text":"This script streamlines taking screenshots under a Wayland environment (such as Sway or river). Screenshots are saved in your $HOME/Pictures folder with a timestamped filename for easy organization. Functionality: - Fullscreen screenshot: By default ( no arguments ), the entire display is captured. - Area selection screenshot: When called with --select , allows interactive selection of a screen region. Uses slurp to let you define a region with the mouse, then captures it via grim . Notifications: Every time a screenshot is taken, the script sends a desktop notification showing the saved filename using notify-send .","title":"Description"},{"location":"scripts/screenshot.sh/#usage","text":"The script can be run directly in the terminal, bound to a keybinding in qtile , or called from a script/shortcut. Examples: # Fullscreen screenshot ~/.scripts/bin/screenshot.sh # Interactive area selection ~/.scripts/bin/screenshot.sh --select You can set this up as a keybinding in your qtile config. Example: Key([mod], \"Print\", lazy.spawn(\"~/.scripts/bin/screenshot.sh\")), Key([mod, \"shift\"], \"Print\", lazy.spawn(\"~/.scripts/bin/screenshot.sh --select\")), Output: - All screenshots are saved to ~/Pictures with a format like 2024-06-30-screenshot-1719758632.png . [!TIP] If $HOME/Pictures does not exist, the script will fail to save the screenshot. Consider adding a check to create the directory if missing ( mkdir -p \"$_OUTPUT_DIR\" ). There\u2019s no error handling: if grim , slurp , or notify-send are missing or fail, you won\u2019t get any warning. The notification message is always \"Selection saved as ...\" even for fullscreen shots\u2014consider customizing the message for clarity. Minor: Script could use local for variables to restrict scope, though in this context it's not critical. For further flexibility, you might want to allow custom output directory or filename prefix via command-line arguments.","title":"Usage"},{"location":"scripts/script.sh/","text":"Fuzzy Typed Command Launcher script.sh : Launches fzf in an xterm window and types the selected entry using xdotool . Dependencies fzf \u2013 powerful command-line fuzzy finder xterm \u2013 terminal emulator used for displaying the fzf menu xdotool \u2013 simulates keyboard input to type the selected entry xargs \u2013 used to pass the selected entry as arguments bash \u2013 required shell interpreter Description This script facilitates launching a fuzzy finder menu ( fzf ) within an xterm popup, allowing the user to filter/select from a list provided via command line arguments (or standard input). Once an item is selected, the entry is automatically \"typed\" at the current cursor position in your active window, via xdotool type . Script logic in detail: - All arguments provided to this script are escaped for safety and concatenated. - These arguments are passed to fzf , which will display them for selection. - The process runs within a dedicated xterm window with the title 'fzfmenu' . - Standard input and output file descriptors are used to bridge between the menu and the script. - The resulting selection is picked up and passed to xdotool type using xargs , simulating keyboard input of the selection into the currently-focused application. Usage Run this script with a list of options or arguments, for example: ~/.scripts/dev/script.sh one two three four Interact with the fzf menu (filter by typing), select with Enter \u2013 the chosen text will then be auto-typed wherever your cursor is active. You can also pass extra options to fzf : ~/.scripts/dev/script.sh --preview 'echo {}' apple banana cherry Example: Keybinding in qtile: Assign this script to a keybinding in your qtile config to quickly invoke your custom fuzzy finder and auto-type the result. [!TIP] - The script is robust in argument escaping, but currently expects all menu items as arguments rather than through stdin, which can limit usage with dynamically-generated input. - The use of xterm is hardcoded; for better integration on tiling WMs like qtile, consider making the terminal configurable. - Comments at the top suggest intended support for launching the menu at mouse coordinates and pre-selecting text, but those features are currently commented out. Implementing or removing these could improve clarity. - Consider handling empty selections more gracefully to avoid running xdotool type with empty input.","title":"Fuzzy Typed Command Launcher"},{"location":"scripts/script.sh/#fuzzy-typed-command-launcher","text":"script.sh : Launches fzf in an xterm window and types the selected entry using xdotool .","title":"Fuzzy Typed Command Launcher"},{"location":"scripts/script.sh/#dependencies","text":"fzf \u2013 powerful command-line fuzzy finder xterm \u2013 terminal emulator used for displaying the fzf menu xdotool \u2013 simulates keyboard input to type the selected entry xargs \u2013 used to pass the selected entry as arguments bash \u2013 required shell interpreter","title":"Dependencies"},{"location":"scripts/script.sh/#description","text":"This script facilitates launching a fuzzy finder menu ( fzf ) within an xterm popup, allowing the user to filter/select from a list provided via command line arguments (or standard input). Once an item is selected, the entry is automatically \"typed\" at the current cursor position in your active window, via xdotool type . Script logic in detail: - All arguments provided to this script are escaped for safety and concatenated. - These arguments are passed to fzf , which will display them for selection. - The process runs within a dedicated xterm window with the title 'fzfmenu' . - Standard input and output file descriptors are used to bridge between the menu and the script. - The resulting selection is picked up and passed to xdotool type using xargs , simulating keyboard input of the selection into the currently-focused application.","title":"Description"},{"location":"scripts/script.sh/#usage","text":"Run this script with a list of options or arguments, for example: ~/.scripts/dev/script.sh one two three four Interact with the fzf menu (filter by typing), select with Enter \u2013 the chosen text will then be auto-typed wherever your cursor is active. You can also pass extra options to fzf : ~/.scripts/dev/script.sh --preview 'echo {}' apple banana cherry Example: Keybinding in qtile: Assign this script to a keybinding in your qtile config to quickly invoke your custom fuzzy finder and auto-type the result. [!TIP] - The script is robust in argument escaping, but currently expects all menu items as arguments rather than through stdin, which can limit usage with dynamically-generated input. - The use of xterm is hardcoded; for better integration on tiling WMs like qtile, consider making the terminal configurable. - Comments at the top suggest intended support for launching the menu at mouse coordinates and pre-selecting text, but those features are currently commented out. Implementing or removing these could improve clarity. - Consider handling empty selections more gracefully to avoid running xdotool type with empty input.","title":"Usage"},{"location":"scripts/script_launcher.sh/","text":"","title":"Script launcher.sh"},{"location":"scripts/select_script/","text":"Script Selector Utility select_script : Interactively select and execute a script from cached metadata using Rofi Dependencies rofi : Pop-up menu for selection; must support -markup-rows . ~/.cache/script_info.csv : CSV file containing script metadata (must exist and be regularly updated). Scripts located in ~/.scripts/ : The script target directory; selected scripts must be executable and present here. Standard C library ( stdio , stdlib , string , unistd ). Description This select_script C application provides an interactive graphical menu for quickly selecting and executing scripts stored under ~/.scripts/ , relying on cached metadata for speed and context. How it works: - Reads ~/.cache/script_info.csv which should have rows describing script files and their metadata. The exact CSV format expects at least a filename in the first column and a quoted description in the seventh. - Presents the list of scripts using rofi , displaying each filename in green alongside its description. - Captures the user\u2019s selection and parses out the script name. - Launches the selected script by calling it with execl() . Main Utilities and Functions: - load_cache() : Loads script info from CSV, filling an array of ScriptInfo (file + description). - display_rofi() : Sends all scripts as menu entries to a rofi process for user selection. - extract_choice() : Runs another rofi as a dmenu, and parses out the chosen filename from the user's selection. - execute_choice() : Runs the chosen script directly by absolute path. Usage You can run this utility from a terminal, keybinding, or dmenu/rofi runner: $ ~/.scripts/bin/select_script tldr; Quick setup: 1. Ensure scripts you wish to select are executable and exist under ~/.scripts/ . 2. Ensure ~/.cache/script_info.csv exists and is up-to-date. 3. Make sure rofi is installed. 4. Run the script as above. A rofi menu will appear with all scripts and their descriptions. 5. Select an entry; the corresponding script will immediately execute. [!TIP] Critique: The current implementation launches two separate rofi processes: one to display options, and one to extract user choice. This is inefficient\u2014ideally, all should be handled in a single rofi session by writing and reading through the same pipe. The CSV sscanf parsing is fragile and dependent on the exact input format; more robust CSV parsing is advised if the schema changes. There is no error checking for script existence/executability before attempting to run. Adding those would prevent silent failures. The script does not handle the possibility of no selection (user-escape or enter on empty). The executable environment is not preserved; scripts relying on parent env vars might fail. Consider providing a brief usage/help display if executed with -h or --help , and improving the rofi integration for speed and user experience.","title":"Script Selector Utility"},{"location":"scripts/select_script/#script-selector-utility","text":"select_script : Interactively select and execute a script from cached metadata using Rofi","title":"Script Selector Utility"},{"location":"scripts/select_script/#dependencies","text":"rofi : Pop-up menu for selection; must support -markup-rows . ~/.cache/script_info.csv : CSV file containing script metadata (must exist and be regularly updated). Scripts located in ~/.scripts/ : The script target directory; selected scripts must be executable and present here. Standard C library ( stdio , stdlib , string , unistd ).","title":"Dependencies"},{"location":"scripts/select_script/#description","text":"This select_script C application provides an interactive graphical menu for quickly selecting and executing scripts stored under ~/.scripts/ , relying on cached metadata for speed and context. How it works: - Reads ~/.cache/script_info.csv which should have rows describing script files and their metadata. The exact CSV format expects at least a filename in the first column and a quoted description in the seventh. - Presents the list of scripts using rofi , displaying each filename in green alongside its description. - Captures the user\u2019s selection and parses out the script name. - Launches the selected script by calling it with execl() . Main Utilities and Functions: - load_cache() : Loads script info from CSV, filling an array of ScriptInfo (file + description). - display_rofi() : Sends all scripts as menu entries to a rofi process for user selection. - extract_choice() : Runs another rofi as a dmenu, and parses out the chosen filename from the user's selection. - execute_choice() : Runs the chosen script directly by absolute path.","title":"Description"},{"location":"scripts/select_script/#usage","text":"You can run this utility from a terminal, keybinding, or dmenu/rofi runner: $ ~/.scripts/bin/select_script tldr; Quick setup: 1. Ensure scripts you wish to select are executable and exist under ~/.scripts/ . 2. Ensure ~/.cache/script_info.csv exists and is up-to-date. 3. Make sure rofi is installed. 4. Run the script as above. A rofi menu will appear with all scripts and their descriptions. 5. Select an entry; the corresponding script will immediately execute. [!TIP] Critique: The current implementation launches two separate rofi processes: one to display options, and one to extract user choice. This is inefficient\u2014ideally, all should be handled in a single rofi session by writing and reading through the same pipe. The CSV sscanf parsing is fragile and dependent on the exact input format; more robust CSV parsing is advised if the schema changes. There is no error checking for script existence/executability before attempting to run. Adding those would prevent silent failures. The script does not handle the possibility of no selection (user-escape or enter on empty). The executable environment is not preserved; scripts relying on parent env vars might fail. Consider providing a brief usage/help display if executed with -h or --help , and improving the rofi integration for speed and user experience.","title":"Usage"},{"location":"scripts/send_email.py/","text":"Send Email Script send_email.py : Script to send an email from the command line with argparse and smtplib Dependencies python (>=3.6) \u2014 The script is written in Python. argparse (builtin) \u2014 For parsing command-line arguments. smtplib (builtin) \u2014 To send mail via SMTP. ssl (builtin) \u2014 For secure SMTP connection. subprocess (builtin) \u2014 To securely fetch passwords. email (builtin) \u2014 Constructs MIME email messages. pass \u2014 Password manager; retrieves email account passwords securely from your password store. Description This script provides a CLI utility for quickly sending emails from your terminal, leveraging your existing password store for authentication: It uses argparse to accept sender, receiver, subject, display name, and content as flags/arguments. Emails are structured using the EmailMessage class for clean formatting. The get_password() function fetches your email account password from the pass password manager, assuming you keep the plain password on the second line of the pass file for the sender's email. It uses smtplib.SMTP_SSL to securely connect to Gmail's SMTP server on port 465 and send your message. Usage You can run this script directly from the terminal or bind it to a launcher/shortcut in qtile. Basic example: $ ~/.scripts/bin/send_email.py \\ --email-sender matiasylinenceau@gmail.com \\ --email-receiver someone@example.com \\ -s \"Subject Line\" \\ -c \"Body of the email\" With minimal arguments (uses script defaults): $ ~/.scripts/bin/send_email.py Arguments: Flag Default Description --email-sender matiasylinenceau@gmail.com Gmail address to send from --email-receiver matias@ceau.net Address to send mail to -s, --subject automatic Email subject --display-name self Name shown as sender -c, --content Testing Email body Ensure that your password is correctly stored in pass under the label that matches your sender's email address, with the password on the second line. [!CAUTION] - The script directly fetches the second line from your pass entry for the sender's email, assuming your password is configured on that line. This could fail if your password is located elsewhere or your pass entry structure differs. - Password retrieval isn't very flexible. If you use GPG comments or extra metadata in your password store, you might need to adjust the line indexing. - \"From\" header uses the display name only, which may cause the message to appear malformed in some email clients that expect \"Display Name email@address \" format. - SMTP server details are hardcoded for Gmail; this won't work with other providers as-is. - No error handling for failed authentication, mail delivery errors, or password retrieval. - Sending HTML or attachments is not supported\u2014content is plain text only. - Consider switching to environment variables (or a secrets manager) for more portable authentication if you ever migrate from pass .","title":"Send Email Script"},{"location":"scripts/send_email.py/#send-email-script","text":"send_email.py : Script to send an email from the command line with argparse and smtplib","title":"Send Email Script"},{"location":"scripts/send_email.py/#dependencies","text":"python (>=3.6) \u2014 The script is written in Python. argparse (builtin) \u2014 For parsing command-line arguments. smtplib (builtin) \u2014 To send mail via SMTP. ssl (builtin) \u2014 For secure SMTP connection. subprocess (builtin) \u2014 To securely fetch passwords. email (builtin) \u2014 Constructs MIME email messages. pass \u2014 Password manager; retrieves email account passwords securely from your password store.","title":"Dependencies"},{"location":"scripts/send_email.py/#description","text":"This script provides a CLI utility for quickly sending emails from your terminal, leveraging your existing password store for authentication: It uses argparse to accept sender, receiver, subject, display name, and content as flags/arguments. Emails are structured using the EmailMessage class for clean formatting. The get_password() function fetches your email account password from the pass password manager, assuming you keep the plain password on the second line of the pass file for the sender's email. It uses smtplib.SMTP_SSL to securely connect to Gmail's SMTP server on port 465 and send your message.","title":"Description"},{"location":"scripts/send_email.py/#usage","text":"You can run this script directly from the terminal or bind it to a launcher/shortcut in qtile. Basic example: $ ~/.scripts/bin/send_email.py \\ --email-sender matiasylinenceau@gmail.com \\ --email-receiver someone@example.com \\ -s \"Subject Line\" \\ -c \"Body of the email\" With minimal arguments (uses script defaults): $ ~/.scripts/bin/send_email.py Arguments: Flag Default Description --email-sender matiasylinenceau@gmail.com Gmail address to send from --email-receiver matias@ceau.net Address to send mail to -s, --subject automatic Email subject --display-name self Name shown as sender -c, --content Testing Email body Ensure that your password is correctly stored in pass under the label that matches your sender's email address, with the password on the second line. [!CAUTION] - The script directly fetches the second line from your pass entry for the sender's email, assuming your password is configured on that line. This could fail if your password is located elsewhere or your pass entry structure differs. - Password retrieval isn't very flexible. If you use GPG comments or extra metadata in your password store, you might need to adjust the line indexing. - \"From\" header uses the display name only, which may cause the message to appear malformed in some email clients that expect \"Display Name email@address \" format. - SMTP server details are hardcoded for Gmail; this won't work with other providers as-is. - No error handling for failed authentication, mail delivery errors, or password retrieval. - Sending HTML or attachments is not supported\u2014content is plain text only. - Consider switching to environment variables (or a secrets manager) for more portable authentication if you ever migrate from pass .","title":"Usage"},{"location":"scripts/setting-up-syncs.sh/","text":"Sync Setup Helper with Mega setting-up-syncs.sh : Automates MEGA cloud syncs for key folders and differentiates setup by host. Dependencies mega-sync : Command-line tool or personal script for synchronizing folders with MEGA (ensure it's available in PATH ). hostnamectl : Required for retrieving the system hostname. Standard bash environment (tested on Arch Linux). Description This script configures and initiates folder synchronizations between your local system and MEGA cloud storage. It uses your host's name to determine which directories to sync, allowing for machine-specific configurations. The script: - Syncs default XDG user directories ( Desktop , Downloads , etc.) and a personal knowledge management directory ( PKM ) to equivalent paths in your MEGA storage. - Checks the hostname (using hostnamectl hostname ) to apply extra syncs uniquely for karhu or karjala hosts (for example, additional media or backup folders). - The specific MEGA destinations are organized to keep backups and user data grouped per device. It's designed for use in personal computing environments where you have multiple machines with shared or device-specific cloud storage needs (e.g., your Arch Linux setup running qtile ). Usage You typically run the script manually or trigger it on login/boot per host. Terminal (one-off run): bash ~/.scripts/bin/setting-up-syncs.sh Add to a qtile/autostart script: import subprocess subprocess.Popen([\"/home/matias/.scripts/bin/setting-up-syncs.sh\"]) With keybinding in qtile (example): Key([mod], \"F12\", lazy.spawn(\"~/.scripts/bin/setting-up-syncs.sh\")), Requirements: Make sure mega-sync is accessible and pre-configured for your account. Ensure required mount points are available before running (e.g., /mnt/mega or /mnt/HDD2 ). [!TIP] The script is straightforward but can be improved for flexibility, safety, and clarity: - Host Check : It would be safer to quote hostnames in the conditionals ( \"$HOST\" ). - Error Handling : Currently, it does not report or exit on failed syncs or missing mount points. Adding checks and logging would make troubleshooting easier. - Configurability : Paths and folder lists are hardcoded. Consider externalizing to a config file for greater portability. - Parallelization : Long-running syncs could potentially block; running them in the background (with & ) or in parallel could improve speed. - Documentation : Inline comments are clear, but brief explanations of why certain directories are chosen (especially for the TODOs) would help future maintenance.","title":"Sync Setup Helper with Mega"},{"location":"scripts/setting-up-syncs.sh/#sync-setup-helper-with-mega","text":"setting-up-syncs.sh : Automates MEGA cloud syncs for key folders and differentiates setup by host.","title":"Sync Setup Helper with Mega"},{"location":"scripts/setting-up-syncs.sh/#dependencies","text":"mega-sync : Command-line tool or personal script for synchronizing folders with MEGA (ensure it's available in PATH ). hostnamectl : Required for retrieving the system hostname. Standard bash environment (tested on Arch Linux).","title":"Dependencies"},{"location":"scripts/setting-up-syncs.sh/#description","text":"This script configures and initiates folder synchronizations between your local system and MEGA cloud storage. It uses your host's name to determine which directories to sync, allowing for machine-specific configurations. The script: - Syncs default XDG user directories ( Desktop , Downloads , etc.) and a personal knowledge management directory ( PKM ) to equivalent paths in your MEGA storage. - Checks the hostname (using hostnamectl hostname ) to apply extra syncs uniquely for karhu or karjala hosts (for example, additional media or backup folders). - The specific MEGA destinations are organized to keep backups and user data grouped per device. It's designed for use in personal computing environments where you have multiple machines with shared or device-specific cloud storage needs (e.g., your Arch Linux setup running qtile ).","title":"Description"},{"location":"scripts/setting-up-syncs.sh/#usage","text":"You typically run the script manually or trigger it on login/boot per host.","title":"Usage"},{"location":"scripts/setting-up-syncs.sh/#terminal-one-off-run","text":"bash ~/.scripts/bin/setting-up-syncs.sh","title":"Terminal (one-off run):"},{"location":"scripts/setting-up-syncs.sh/#add-to-a-qtileautostart-script","text":"import subprocess subprocess.Popen([\"/home/matias/.scripts/bin/setting-up-syncs.sh\"])","title":"Add to a qtile/autostart script:"},{"location":"scripts/setting-up-syncs.sh/#with-keybinding-in-qtile-example","text":"Key([mod], \"F12\", lazy.spawn(\"~/.scripts/bin/setting-up-syncs.sh\")),","title":"With keybinding in qtile (example):"},{"location":"scripts/setting-up-syncs.sh/#requirements","text":"Make sure mega-sync is accessible and pre-configured for your account. Ensure required mount points are available before running (e.g., /mnt/mega or /mnt/HDD2 ). [!TIP] The script is straightforward but can be improved for flexibility, safety, and clarity: - Host Check : It would be safer to quote hostnames in the conditionals ( \"$HOST\" ). - Error Handling : Currently, it does not report or exit on failed syncs or missing mount points. Adding checks and logging would make troubleshooting easier. - Configurability : Paths and folder lists are hardcoded. Consider externalizing to a config file for greater portability. - Parallelization : Long-running syncs could potentially block; running them in the background (with & ) or in parallel could improve speed. - Documentation : Inline comments are clear, but brief explanations of why certain directories are chosen (especially for the TODOs) would help future maintenance.","title":"Requirements:"},{"location":"scripts/shell_history_info.sh/","text":"Shell History Analyzer shell_history_info.sh : Analyze and summarize the most frequent lines, words, or characters in your shell command history files. Dependencies rg (ripgrep): For fast text filtering and searching. bat : Enhanced cat clone with syntax highlighting (only used for displaying usage/help). sed , uniq , sort , tr , cat : Core Unix utilities for text processing. Uses the environment variable $XDG_STATE_HOME to locate zsh and bash history files. Description This script provides a quick way to inspect and quantify command history usage patterns across both bash and zsh on your Arch Linux system. By removing shell-specific metadata (especially from zsh history), it presents cleanly sorted frequency reports for: Full command lines ( -l , --lines ) Individual words in commands ( -w , --words ) Single character occurrences ( -c , --character ) Command-line options/flags (beginning with - ) ( -o , --option ) The script defines modular helper functions for fetching history, splitting words, cleaning up whitespace, and sorting/displaying by usage count. Lines with occurrences fewer than 6 are filtered out, providing a focused look at your habitual command patterns. Usage The script is primarily designed to be run from the terminal. Typical invocations: # Most frequently used full command lines shell_history_info.sh --lines # Most common words in commands shell_history_info.sh --words # Most common single characters shell_history_info.sh --character # Frequently used command options (flags) shell_history_info.sh --option tldr: shell_history_info.sh -l # lines shell_history_info.sh -w # words shell_history_info.sh -c # characters shell_history_info.sh -o # options starting with '-' If given an incorrect or missing argument, the script will print out inline usage information with syntax highlighting via bat . To integrate with qtile keybindings, simply map the script invocation with the desired arguments to an appropriate Key definition. [!NOTE] Critique: - The explicit use of $XDG_STATE_HOME assumes it is set, which may not always be the case. Consider providing a fallback (such as ~/.local/state ) or checking ~/.bash_history and ~/.zsh_history if the standard variables aren't found. - Grepping for command-line options by only looking for words starting with - may capture non-option strings if user commands contain such patterns. - The dependency on bat is only for pretty-printing the help section and could be optional or replaced by less / cat for broader compatibility. - Command filtering (occurrences < 6 are removed) is hardcoded, which could be improved with a user argument to set the threshold. - The script ignores multi-line history entries and may produce duplicate matches if history files are large and messy; consider deduplication or smarter parsing if needed.","title":"Shell History Analyzer"},{"location":"scripts/shell_history_info.sh/#shell-history-analyzer","text":"shell_history_info.sh : Analyze and summarize the most frequent lines, words, or characters in your shell command history files.","title":"Shell History Analyzer"},{"location":"scripts/shell_history_info.sh/#dependencies","text":"rg (ripgrep): For fast text filtering and searching. bat : Enhanced cat clone with syntax highlighting (only used for displaying usage/help). sed , uniq , sort , tr , cat : Core Unix utilities for text processing. Uses the environment variable $XDG_STATE_HOME to locate zsh and bash history files.","title":"Dependencies"},{"location":"scripts/shell_history_info.sh/#description","text":"This script provides a quick way to inspect and quantify command history usage patterns across both bash and zsh on your Arch Linux system. By removing shell-specific metadata (especially from zsh history), it presents cleanly sorted frequency reports for: Full command lines ( -l , --lines ) Individual words in commands ( -w , --words ) Single character occurrences ( -c , --character ) Command-line options/flags (beginning with - ) ( -o , --option ) The script defines modular helper functions for fetching history, splitting words, cleaning up whitespace, and sorting/displaying by usage count. Lines with occurrences fewer than 6 are filtered out, providing a focused look at your habitual command patterns.","title":"Description"},{"location":"scripts/shell_history_info.sh/#usage","text":"The script is primarily designed to be run from the terminal. Typical invocations: # Most frequently used full command lines shell_history_info.sh --lines # Most common words in commands shell_history_info.sh --words # Most common single characters shell_history_info.sh --character # Frequently used command options (flags) shell_history_info.sh --option tldr: shell_history_info.sh -l # lines shell_history_info.sh -w # words shell_history_info.sh -c # characters shell_history_info.sh -o # options starting with '-' If given an incorrect or missing argument, the script will print out inline usage information with syntax highlighting via bat . To integrate with qtile keybindings, simply map the script invocation with the desired arguments to an appropriate Key definition. [!NOTE] Critique: - The explicit use of $XDG_STATE_HOME assumes it is set, which may not always be the case. Consider providing a fallback (such as ~/.local/state ) or checking ~/.bash_history and ~/.zsh_history if the standard variables aren't found. - Grepping for command-line options by only looking for words starting with - may capture non-option strings if user commands contain such patterns. - The dependency on bat is only for pretty-printing the help section and could be optional or replaced by less / cat for broader compatibility. - Command filtering (occurrences < 6 are removed) is hardcoded, which could be improved with a user argument to set the threshold. - The script ignores multi-line history entries and may produce duplicate matches if history files are large and messy; consider deduplication or smarter parsing if needed.","title":"Usage"},{"location":"scripts/show-all-qutebrowser-scripts.sh/","text":"Show All Qutebrowser Scripts show-all-qutebrowser-scripts.sh : Display the content of Qutebrowser's bundled scripts using bat for preview Dependencies qutebrowser : The package from which scripts are listed. pacman : Used for querying files installed by qutebrowser (Arch Linux package manager). ripgrep ( rg ): Filters out directories from the listing. sed : For text substitution, to format paths. xargs : Executes bat on each listed file. bat : Syntax-highlighting cat clone, used to preview file content. Description This script lists and displays all non-directory files provided by the qutebrowser package (likely helper scripts or utilities shipped in its /usr/bin or /usr/share directories). Core steps: pacman -Ql qutebrowser lists all files installed by the package. tail -n 37 takes the last 37 lines, assuming these correspond to the actual scripts (might need tweaking if upstream packaging changes). rg -v '/$' filters out directories, only keeping files. sed 's/^.*qutebrowser //' strips the leading package/file info, resulting in just paths relative to the root. xargs bat sequentially displays the content of these files using bat for pretty-printing. This process produces a quick audit/glance at all Qutebrowser-related scripts, helpful for quickly reviewing helpers, wrappers, or plugin code. Usage You can run this script in a terminal: ~/.scripts/bin/show-all-qutebrowser-scripts.sh Or assign it to a custom keybinding in Qtile, for example in your ~/.config/qtile/config.py : Key([mod], \"F12\", lazy.spawn(\"~/.scripts/bin/show-all-qutebrowser-scripts.sh\")) Example TLDR Show the scripts in the terminal: $ ~/.scripts/bin/show-all-qutebrowser-scripts.sh Send output to a file for later viewing: $ ~/.scripts/bin/show-all-qutebrowser-scripts.sh > qtb_scripts.txt [!NOTE] - The use of tail -n 37 is brittle. If Qutebrowser's packaging changes, this might omit some scripts or include non-scripts. Consider using awk or filtering directly for .sh or relevant script paths instead. - This script only works on Arch (or Arch-like) systems where pacman is available. - bat will error on binary or un-readable files. Adding safeguards for file type could improve robustness. - For distribution or portability, checking whether all dependencies are present would be helpful.","title":"Show All Qutebrowser Scripts"},{"location":"scripts/show-all-qutebrowser-scripts.sh/#show-all-qutebrowser-scripts","text":"show-all-qutebrowser-scripts.sh : Display the content of Qutebrowser's bundled scripts using bat for preview","title":"Show All Qutebrowser Scripts"},{"location":"scripts/show-all-qutebrowser-scripts.sh/#dependencies","text":"qutebrowser : The package from which scripts are listed. pacman : Used for querying files installed by qutebrowser (Arch Linux package manager). ripgrep ( rg ): Filters out directories from the listing. sed : For text substitution, to format paths. xargs : Executes bat on each listed file. bat : Syntax-highlighting cat clone, used to preview file content.","title":"Dependencies"},{"location":"scripts/show-all-qutebrowser-scripts.sh/#description","text":"This script lists and displays all non-directory files provided by the qutebrowser package (likely helper scripts or utilities shipped in its /usr/bin or /usr/share directories). Core steps: pacman -Ql qutebrowser lists all files installed by the package. tail -n 37 takes the last 37 lines, assuming these correspond to the actual scripts (might need tweaking if upstream packaging changes). rg -v '/$' filters out directories, only keeping files. sed 's/^.*qutebrowser //' strips the leading package/file info, resulting in just paths relative to the root. xargs bat sequentially displays the content of these files using bat for pretty-printing. This process produces a quick audit/glance at all Qutebrowser-related scripts, helpful for quickly reviewing helpers, wrappers, or plugin code.","title":"Description"},{"location":"scripts/show-all-qutebrowser-scripts.sh/#usage","text":"You can run this script in a terminal: ~/.scripts/bin/show-all-qutebrowser-scripts.sh Or assign it to a custom keybinding in Qtile, for example in your ~/.config/qtile/config.py : Key([mod], \"F12\", lazy.spawn(\"~/.scripts/bin/show-all-qutebrowser-scripts.sh\"))","title":"Usage"},{"location":"scripts/show-all-qutebrowser-scripts.sh/#example-tldr","text":"Show the scripts in the terminal: $ ~/.scripts/bin/show-all-qutebrowser-scripts.sh Send output to a file for later viewing: $ ~/.scripts/bin/show-all-qutebrowser-scripts.sh > qtb_scripts.txt [!NOTE] - The use of tail -n 37 is brittle. If Qutebrowser's packaging changes, this might omit some scripts or include non-scripts. Consider using awk or filtering directly for .sh or relevant script paths instead. - This script only works on Arch (or Arch-like) systems where pacman is available. - bat will error on binary or un-readable files. Adding safeguards for file type could improve robustness. - For distribution or portability, checking whether all dependencies are present would be helpful.","title":"Example TLDR"},{"location":"scripts/show_keyboard_layout.py/","text":"Show Custom Keyboard Layout show_keyboard_layout.py : Prints a custom visual keyboard layout to the terminal for reference. Dependencies python (Standard Arch package; script uses standard library only) Description This script displays an ASCII art representation of a custom keyboard layout. It's designed to offer a quick, clear reference for special or nonstandard keys, such as accented letters or alternative symbols, which are useful in multilingual or custom XKB setups. The layout is stored as a raw string ( keyboard_layout ) containing a stylized keyboard grid, with rows for each section (digits, QWERTY, modifiers, etc.). The printout includes: - Primary and alternate character layers per key (such as Shift/AltGr positions) - Modifier keys clearly labeled ( Shift , Alt , Ctrl , Super ) - Extra characters for specific international input: \u00e4 , \u00df , \u00f1 , \u00f6 , \u0153 , and more. - Unicode and other extended symbols for rapid reference while typing. This is especially helpful for users running tiling window managers like qtile under Arch Linux, where you may want to avoid GUI utilities for layout checking. Usage You can run this script directly in your terminal. It's ideal to bind this script to a key combination in qtile, so you can pop up your keyboard reference at any time. TL;DR : python ~/.scripts/bin/show_keyboard_layout.py Or make it executable and call directly: chmod +x ~/.scripts/bin/show_keyboard_layout.py ~/.scripts/bin/show_keyboard_layout.py Tip for qtile : To open this in a terminal from a qtile keybinding, you might use a keybinding like: Key([mod], \"F11\", lazy.spawn(\"alacritty -e ~/.scripts/bin/show_keyboard_layout.py\")) (Adjust terminal as needed.) [!TIP] The script offers a static, hardcoded ASCII art keyboard, so it won't automatically adapt if your physical or xkb layout changes. Consider integrating a dynamic layout query using tools like setxkbmap -print or xkbcli for adaptability. For now, this is a quick-reference tool\u2014if you change layouts, you need to update the script manually. Also, the formatting might be best suited for monospaced fonts\u2014ensure your terminal uses one for the best results.","title":"Show Custom Keyboard Layout"},{"location":"scripts/show_keyboard_layout.py/#show-custom-keyboard-layout","text":"show_keyboard_layout.py : Prints a custom visual keyboard layout to the terminal for reference.","title":"Show Custom Keyboard Layout"},{"location":"scripts/show_keyboard_layout.py/#dependencies","text":"python (Standard Arch package; script uses standard library only)","title":"Dependencies"},{"location":"scripts/show_keyboard_layout.py/#description","text":"This script displays an ASCII art representation of a custom keyboard layout. It's designed to offer a quick, clear reference for special or nonstandard keys, such as accented letters or alternative symbols, which are useful in multilingual or custom XKB setups. The layout is stored as a raw string ( keyboard_layout ) containing a stylized keyboard grid, with rows for each section (digits, QWERTY, modifiers, etc.). The printout includes: - Primary and alternate character layers per key (such as Shift/AltGr positions) - Modifier keys clearly labeled ( Shift , Alt , Ctrl , Super ) - Extra characters for specific international input: \u00e4 , \u00df , \u00f1 , \u00f6 , \u0153 , and more. - Unicode and other extended symbols for rapid reference while typing. This is especially helpful for users running tiling window managers like qtile under Arch Linux, where you may want to avoid GUI utilities for layout checking.","title":"Description"},{"location":"scripts/show_keyboard_layout.py/#usage","text":"You can run this script directly in your terminal. It's ideal to bind this script to a key combination in qtile, so you can pop up your keyboard reference at any time. TL;DR : python ~/.scripts/bin/show_keyboard_layout.py Or make it executable and call directly: chmod +x ~/.scripts/bin/show_keyboard_layout.py ~/.scripts/bin/show_keyboard_layout.py Tip for qtile : To open this in a terminal from a qtile keybinding, you might use a keybinding like: Key([mod], \"F11\", lazy.spawn(\"alacritty -e ~/.scripts/bin/show_keyboard_layout.py\")) (Adjust terminal as needed.) [!TIP] The script offers a static, hardcoded ASCII art keyboard, so it won't automatically adapt if your physical or xkb layout changes. Consider integrating a dynamic layout query using tools like setxkbmap -print or xkbcli for adaptability. For now, this is a quick-reference tool\u2014if you change layouts, you need to update the script manually. Also, the formatting might be best suited for monospaced fonts\u2014ensure your terminal uses one for the best results.","title":"Usage"},{"location":"scripts/snekai.sh/","text":"snekai: Jupyter and IPython Environment Launcher snekai.sh : Utility for launching Jupyter Lab, Jupyter Notebook, or IPython from a dedicated Python virtual environment Dependencies bash \u2014 Required to run the script. jupyter-lab \u2014 Must be installed in the SNEKVENV ( ~/.local/venv/snekai ). jupyter-notebook \u2014 Should be present in the SNEKVENV for notebook support. ipython \u2014 Needs to be available in the same virtual environment. Python virtual environment at ~/.local/venv/snekai ( python -m venv ~/.local/venv/snekai ) Optional : Your own /home/matias/.scripts/lib/snekai/ path organization Description This script provides a simplified CLI wrapper for launching: - Jupyter Lab - Jupyter Notebook - IPython shell All tools are run from a Python virtual environment located at ~/.local/venv/snekai , ensuring clean separation from your system Python or other environments. Functions: - lab() : Activates the venv and runs Jupyter Lab. - notebook() : Activates the venv and runs Jupyter Notebook. - ipython() : Activates the venv and launches an IPython shell. Each function ensures the environment is sourced so that dependencies and kernels are correct. The command-line argument determines which tool is launched. Usage You can call the script directly from your terminal or bind it to a key in your qtile configuration. Examples # Launch Jupyter Lab ~/.scripts/lib/snekai/snekai.sh lab # Launch Jupyter Notebook ~/.scripts/lib/snekai/snekai.sh notebook # Launch IPython shell ~/.scripts/lib/snekai/snekai.sh ipython You may also want to symlink or add the script directory to your PATH for convenience: ln -s ~/.scripts/lib/snekai/snekai.sh ~/bin/snekai snekai lab [!TIP] - The script expects the venv at ~/.local/venv/snekai . If it\u2019s missing or unpopulated, commands will fail. Consider adding checks to ensure the venv and tools exist. - Error handling is minimal: typing an unrecognized argument just prints \"Unknown command\". More helpful usage info could be provided. - Currently, the environment is activated via source , but commands are then run explicitly via full path ( $SNEKVENV/bin/\u2026 ). If you always source, you may just call jupyter-lab directly. - No support for passing additional arguments (e.g., opening specific notebooks or labs); consider forwarding $@ to the commands for increased flexibility.","title":"snekai: Jupyter and IPython Environment Launcher"},{"location":"scripts/snekai.sh/#snekai-jupyter-and-ipython-environment-launcher","text":"snekai.sh : Utility for launching Jupyter Lab, Jupyter Notebook, or IPython from a dedicated Python virtual environment","title":"snekai: Jupyter and IPython Environment Launcher"},{"location":"scripts/snekai.sh/#dependencies","text":"bash \u2014 Required to run the script. jupyter-lab \u2014 Must be installed in the SNEKVENV ( ~/.local/venv/snekai ). jupyter-notebook \u2014 Should be present in the SNEKVENV for notebook support. ipython \u2014 Needs to be available in the same virtual environment. Python virtual environment at ~/.local/venv/snekai ( python -m venv ~/.local/venv/snekai ) Optional : Your own /home/matias/.scripts/lib/snekai/ path organization","title":"Dependencies"},{"location":"scripts/snekai.sh/#description","text":"This script provides a simplified CLI wrapper for launching: - Jupyter Lab - Jupyter Notebook - IPython shell All tools are run from a Python virtual environment located at ~/.local/venv/snekai , ensuring clean separation from your system Python or other environments. Functions: - lab() : Activates the venv and runs Jupyter Lab. - notebook() : Activates the venv and runs Jupyter Notebook. - ipython() : Activates the venv and launches an IPython shell. Each function ensures the environment is sourced so that dependencies and kernels are correct. The command-line argument determines which tool is launched.","title":"Description"},{"location":"scripts/snekai.sh/#usage","text":"You can call the script directly from your terminal or bind it to a key in your qtile configuration.","title":"Usage"},{"location":"scripts/snekai.sh/#examples","text":"# Launch Jupyter Lab ~/.scripts/lib/snekai/snekai.sh lab # Launch Jupyter Notebook ~/.scripts/lib/snekai/snekai.sh notebook # Launch IPython shell ~/.scripts/lib/snekai/snekai.sh ipython You may also want to symlink or add the script directory to your PATH for convenience: ln -s ~/.scripts/lib/snekai/snekai.sh ~/bin/snekai snekai lab [!TIP] - The script expects the venv at ~/.local/venv/snekai . If it\u2019s missing or unpopulated, commands will fail. Consider adding checks to ensure the venv and tools exist. - Error handling is minimal: typing an unrecognized argument just prints \"Unknown command\". More helpful usage info could be provided. - Currently, the environment is activated via source , but commands are then run explicitly via full path ( $SNEKVENV/bin/\u2026 ). If you always source, you may just call jupyter-lab directly. - No support for passing additional arguments (e.g., opening specific notebooks or labs); consider forwarding $@ to the commands for increased flexibility.","title":"Examples"},{"location":"scripts/songlauncher.sh/","text":"Song Launcher \u2013 Play Songs in cmus via dmenu songlauncher.sh : Quickly search and play music files via dmenu and cmus Dependencies cmus-remote Command-line client for the cmus music player, allows remote control of cmus (must be running). find Standard Unix utility for recursively searching directories. dmenu Dynamic menu utility; displays a list of items and outputs the user's choice. Your music directory Assumes you have a folder named music in your working directory containing music files. Description This script enables rapid fuzzy searching and playback of songs with your Arch Linux and qtile setup. It leverages the find command to recursively list all files in (or beneath) the music directory, then pipes this list to dmenu -i -l 30 . The -i flag makes dmenu case-insensitive, and -l 30 displays up to 30 choices. Once you select a file in dmenu, it is fed as an argument to cmus-remote -f , which tells cmus to load and play the selected song file immediately. Assumes cmus is running in the background (or in another terminal). Designed to be lightning-fast and minimal; perfect for integration as a keybinding or launcher in qtile. The music path is relative; best used from your home directory or adjust as needed. Usage To use the script: Ensure you have cmus running. Launch the script from your shell, a launcher, or assign to a qtile keybinding. Basic invocation example: $ ~/scripts/bin/songlauncher.sh Typical keybinding integration: In your qtile config: Key([mod], 's', lazy.spawn('~/.scripts/bin/songlauncher.sh')) Running the script will present a searchable (case-insensitive) list of all files in your music directory. Select one, press Enter, and playback will start in cmus. [!IMPORTANT] - The script assumes the current working directory contains the music folder. Consider using an absolute path (e.g., ~/music ) to avoid confusion or breakage if run from elsewhere. - No file-type filtering is in place; if you have non-audio files in music , they will also appear. - To improve, you might: - Add filtering for audio file extensions (like .mp3 , .flac , etc.). - Check if cmus is running, and optionally launch it if not. - Support for configurable music directories via an environment variable or command-line argument.","title":"Song Launcher \u2013 Play Songs in cmus via dmenu"},{"location":"scripts/songlauncher.sh/#song-launcher-play-songs-in-cmus-via-dmenu","text":"songlauncher.sh : Quickly search and play music files via dmenu and cmus","title":"Song Launcher \u2013 Play Songs in cmus via dmenu"},{"location":"scripts/songlauncher.sh/#dependencies","text":"cmus-remote Command-line client for the cmus music player, allows remote control of cmus (must be running). find Standard Unix utility for recursively searching directories. dmenu Dynamic menu utility; displays a list of items and outputs the user's choice. Your music directory Assumes you have a folder named music in your working directory containing music files.","title":"Dependencies"},{"location":"scripts/songlauncher.sh/#description","text":"This script enables rapid fuzzy searching and playback of songs with your Arch Linux and qtile setup. It leverages the find command to recursively list all files in (or beneath) the music directory, then pipes this list to dmenu -i -l 30 . The -i flag makes dmenu case-insensitive, and -l 30 displays up to 30 choices. Once you select a file in dmenu, it is fed as an argument to cmus-remote -f , which tells cmus to load and play the selected song file immediately. Assumes cmus is running in the background (or in another terminal). Designed to be lightning-fast and minimal; perfect for integration as a keybinding or launcher in qtile. The music path is relative; best used from your home directory or adjust as needed.","title":"Description"},{"location":"scripts/songlauncher.sh/#usage","text":"To use the script: Ensure you have cmus running. Launch the script from your shell, a launcher, or assign to a qtile keybinding. Basic invocation example: $ ~/scripts/bin/songlauncher.sh Typical keybinding integration: In your qtile config: Key([mod], 's', lazy.spawn('~/.scripts/bin/songlauncher.sh')) Running the script will present a searchable (case-insensitive) list of all files in your music directory. Select one, press Enter, and playback will start in cmus. [!IMPORTANT] - The script assumes the current working directory contains the music folder. Consider using an absolute path (e.g., ~/music ) to avoid confusion or breakage if run from elsewhere. - No file-type filtering is in place; if you have non-audio files in music , they will also appear. - To improve, you might: - Add filtering for audio file extensions (like .mp3 , .flac , etc.). - Check if cmus is running, and optionally launch it if not. - Support for configurable music directories via an environment variable or command-line argument.","title":"Usage"},{"location":"scripts/speach-to-text.py/","text":"Speech to Text Audio Transcriber speach-to-text.py : Python script for recording audio via a selected device and transcribing it to text using OpenAI Whisper. Dependencies openai Python package to access the OpenAI API (used for sending audio to Whisper). scipy For writing WAV files to disk. sounddevice For capturing audio from microphone/audio input. uv Used as the fast Python package runner (see shebang). Python >= 3.13 Description This script offers a minimal, interactive solution to record your speech (or any audio) through a selected audio device, and get it transcribed using the OpenAI Whisper API. Main Features: Defaults to the device \"UMC202HD 192k: USB\", or prompts you to choose an input device. Records up to 30 seconds of mono audio, sample rate at 48 kHz. Recording stops when you press Enter ( <CR> ). Audio is saved temporarily as temp.wav . Uses the OpenAI Python SDK to transcribe the wav file with the whisper-1 model and prints the result to stdout. Functions: record_or_abort() : Handles live, interactive recording and writes to disk. transcribe() : Uploads the file and outputs the transcription. Usage tldr: # You probably want to run this interactively from your default terminal: ~/.scripts/bin/speach-to-text.py # Or bind it in your qtile config to a keypress, using: lazy.spawn(\"~/.scripts/bin/speach-to-text.py\") Steps: If your audio device is not \"UMC202HD 192k: USB\", you'll be prompted to select a device by index. Speak/record after the prompt. Press Enter to stop before 30s. Wait for transcription to print (network connection required for OpenAI API). Check the prompt for your recognized speech. Requires your OpenAI API key to be configured in your environment (see OpenAI Python SDK docs). [!NOTE] - Typo in script name ( speach-to-text.py \u2192 speech-to-text.py recommended). - Device selection logic could be improved for robustness (e.g., safe integer parsing and device validation). - No automatic deletion of temp.wav , so temp files may accumulate. - No error handling if OpenAI API fails, or if network is absent. - Consider making duration/config parameters customizable by CLI arguments. - Prompt is minimal ( <CR> to stop ), but could be more user-friendly. - Would benefit from a notification about where to set the OpenAI API key. - For qtile integration, check that the script does not require terminal input if assigning to a keybinding.","title":"Speech to Text Audio Transcriber"},{"location":"scripts/speach-to-text.py/#speech-to-text-audio-transcriber","text":"speach-to-text.py : Python script for recording audio via a selected device and transcribing it to text using OpenAI Whisper.","title":"Speech to Text Audio Transcriber"},{"location":"scripts/speach-to-text.py/#dependencies","text":"openai Python package to access the OpenAI API (used for sending audio to Whisper). scipy For writing WAV files to disk. sounddevice For capturing audio from microphone/audio input. uv Used as the fast Python package runner (see shebang). Python >= 3.13","title":"Dependencies"},{"location":"scripts/speach-to-text.py/#description","text":"This script offers a minimal, interactive solution to record your speech (or any audio) through a selected audio device, and get it transcribed using the OpenAI Whisper API.","title":"Description"},{"location":"scripts/speach-to-text.py/#main-features","text":"Defaults to the device \"UMC202HD 192k: USB\", or prompts you to choose an input device. Records up to 30 seconds of mono audio, sample rate at 48 kHz. Recording stops when you press Enter ( <CR> ). Audio is saved temporarily as temp.wav . Uses the OpenAI Python SDK to transcribe the wav file with the whisper-1 model and prints the result to stdout.","title":"Main Features:"},{"location":"scripts/speach-to-text.py/#functions","text":"record_or_abort() : Handles live, interactive recording and writes to disk. transcribe() : Uploads the file and outputs the transcription.","title":"Functions:"},{"location":"scripts/speach-to-text.py/#usage","text":"tldr: # You probably want to run this interactively from your default terminal: ~/.scripts/bin/speach-to-text.py # Or bind it in your qtile config to a keypress, using: lazy.spawn(\"~/.scripts/bin/speach-to-text.py\")","title":"Usage"},{"location":"scripts/speach-to-text.py/#steps","text":"If your audio device is not \"UMC202HD 192k: USB\", you'll be prompted to select a device by index. Speak/record after the prompt. Press Enter to stop before 30s. Wait for transcription to print (network connection required for OpenAI API). Check the prompt for your recognized speech. Requires your OpenAI API key to be configured in your environment (see OpenAI Python SDK docs). [!NOTE] - Typo in script name ( speach-to-text.py \u2192 speech-to-text.py recommended). - Device selection logic could be improved for robustness (e.g., safe integer parsing and device validation). - No automatic deletion of temp.wav , so temp files may accumulate. - No error handling if OpenAI API fails, or if network is absent. - Consider making duration/config parameters customizable by CLI arguments. - Prompt is minimal ( <CR> to stop ), but could be more user-friendly. - Would benefit from a notification about where to set the OpenAI API key. - For qtile integration, check that the script does not require terminal input if assigning to a keybinding.","title":"Steps:"},{"location":"scripts/ssh-fzf.sh/","text":"ssh-fzf \u2014 Fuzzy SSH Command Launcher ssh-fzf.sh : Fuzzy-find and execute ssh commands from pass using fzf . Dependencies pass : Secure password manager storing and retrieving passwords, ssh commands here. fzf : Command-line fuzzy finder for interactive selection. bash : Ensures commands are run in a login shell. Entry in pass (by convention: ssh_cmds ): Should store a newline-separated list of SSH commands. Description This script is designed to quickly launch SSH connections using commands securely stored and organized in your pass password store. The SSH commands must be saved as entries under ssh_cmds within pass \u2014each command on a separate line. What it does: Retrieves SSH command entries using pass ssh_cmds . Presents them in fzf so you can fuzzy search and pick one interactively. If a choice is made, it runs it in a login shell to ensure shell config is sourced. This integration is useful for users who manage multiple SSH hosts and want an ergonomic CLI workflow leveraging security and efficiency. Designed for minimal user interaction and intended as a quick-launch tool\u2014ideal for workflow integration in qtile keybindings or simply from a terminal prompt. Usage Interactive Terminal Just run: ~/.scripts/bin/ssh-fzf.sh From qtile Keybinding Add a keybinding in your qtile config, for example: Key([mod], \"s\", lazy.spawn(\"~/.scripts/bin/ssh-fzf.sh\")) How to populate your pass entry Store your SSH commands under ssh_cmds (newline-separated): pass insert ssh_cmds For example (paste one per line): ssh matias@server1 ssh otheruser@backup-host ssh -p 2222 me@myspecialbox Tldr: # Populate ssh_cmds in pass pass insert ssh_cmds # Invoke the script (choose host interactively) ~/.scripts/bin/ssh-fzf.sh [!TIP] - If the ssh_cmds entry is missing in pass , the script will fail silently\u2014consider adding error handling for missing or empty entries. - The script assumes each line in ssh_cmds is a safe, valid SSH command. There's a potential risk if any line is not an SSH command or contains malicious shell code. - You may want to refresh your pass store or fzf index if changes aren't being picked up immediately. - For more complex workflows, consider also copying other connection information (like passwords/keys) or extending the script to manage multiple categories of remote hosts.","title":"ssh-fzf \u2014 Fuzzy SSH Command Launcher"},{"location":"scripts/ssh-fzf.sh/#ssh-fzf-fuzzy-ssh-command-launcher","text":"ssh-fzf.sh : Fuzzy-find and execute ssh commands from pass using fzf .","title":"ssh-fzf \u2014 Fuzzy SSH Command Launcher"},{"location":"scripts/ssh-fzf.sh/#dependencies","text":"pass : Secure password manager storing and retrieving passwords, ssh commands here. fzf : Command-line fuzzy finder for interactive selection. bash : Ensures commands are run in a login shell. Entry in pass (by convention: ssh_cmds ): Should store a newline-separated list of SSH commands.","title":"Dependencies"},{"location":"scripts/ssh-fzf.sh/#description","text":"This script is designed to quickly launch SSH connections using commands securely stored and organized in your pass password store. The SSH commands must be saved as entries under ssh_cmds within pass \u2014each command on a separate line. What it does: Retrieves SSH command entries using pass ssh_cmds . Presents them in fzf so you can fuzzy search and pick one interactively. If a choice is made, it runs it in a login shell to ensure shell config is sourced. This integration is useful for users who manage multiple SSH hosts and want an ergonomic CLI workflow leveraging security and efficiency. Designed for minimal user interaction and intended as a quick-launch tool\u2014ideal for workflow integration in qtile keybindings or simply from a terminal prompt.","title":"Description"},{"location":"scripts/ssh-fzf.sh/#usage","text":"","title":"Usage"},{"location":"scripts/ssh-fzf.sh/#interactive-terminal","text":"Just run: ~/.scripts/bin/ssh-fzf.sh","title":"Interactive Terminal"},{"location":"scripts/ssh-fzf.sh/#from-qtile-keybinding","text":"Add a keybinding in your qtile config, for example: Key([mod], \"s\", lazy.spawn(\"~/.scripts/bin/ssh-fzf.sh\"))","title":"From qtile Keybinding"},{"location":"scripts/ssh-fzf.sh/#how-to-populate-your-pass-entry","text":"Store your SSH commands under ssh_cmds (newline-separated): pass insert ssh_cmds For example (paste one per line): ssh matias@server1 ssh otheruser@backup-host ssh -p 2222 me@myspecialbox Tldr: # Populate ssh_cmds in pass pass insert ssh_cmds # Invoke the script (choose host interactively) ~/.scripts/bin/ssh-fzf.sh [!TIP] - If the ssh_cmds entry is missing in pass , the script will fail silently\u2014consider adding error handling for missing or empty entries. - The script assumes each line in ssh_cmds is a safe, valid SSH command. There's a potential risk if any line is not an SSH command or contains malicious shell code. - You may want to refresh your pass store or fzf index if changes aren't being picked up immediately. - For more complex workflows, consider also copying other connection information (like passwords/keys) or extending the script to manage multiple categories of remote hosts.","title":"How to populate your pass entry"},{"location":"scripts/sync-repo-simple.py/","text":"Simple Git Repo Sync Script sync-repo-simple.py : Automates syncing a git repository, handling conflicts, stashing, and summary output. Dependencies python3 - The script runs as a Python 3 interpreter. git - All operations use Git CLI commands. awk , sed , grep - Used in parsing remote URLs (ensure these standard POSIX tools are available, typically present on Arch Linux). ENV variables: EDITOR or falls back to vim / nvim for manual conflict resolution. Description This script efficiently automates the process of synchronizing a git repository. It is specifically geared for day-to-day command-line workflow, such as on an Arch Linux system managed by qtile. The core functionality includes: Fetching and pulling (with rebase fallback): Detects local/remote divergence; if a fast-forward is not possible, a rebase is attempted. Conflict Handling: Handles both merge and stash conflicts, prompting for user intervention when required. It leverages your $EDITOR (default vim or nvim ) to resolve merge or stash conflicts interactively. Stashing: If local changes are present before pulling, they're automatically stashed and re-applied after remote updates, with dedicated handling for conflicted files. Automatic Commit and Push: If changes are detected in the repository, the script adds, commits (with an auto-generated message describing user and host), and pushes them. Summary Output: At the end of the sync, prints a contextual summary showing commit times and a diffstat of the recent change. The script is designed to be robust, stopping on errors for manual intervention, and aiming for minimal interaction except in cases of conflicts. Usage You can run this script directly from the terminal or integrate it into a keybinding or shortcut within qtile or your shell. Example usage: sync-repo-simple.py /path/to/your/repo Arguments: - repo_dir ( required ): Path to the git repository you wish to sync. Example: sync-repo-simple.py ~/projects/mydotfiles The script prints diagnostic and status information throughout the process. On conflicts, you'll be prompted interactively in the terminal to resolve them. Editor for Conflicts: Set your preferred editor in your environment: export EDITOR=nvim or let it default to vim / nvim . [!TIP] Critique: - The script assumes only one remote; in multi-remote setups, its behavior may not be as intended. - Command-line parsing is minimal; no verbosity flags or dry-run mode. - Using shell=True with user data in commands introduces potential security issues; safer subprocess argument handling is recommended. - Uses repeated subprocess calls ( git status -s is run several times), which could be minimized for performance. - Error messages are printed to stderr, but exit codes are inconsistent (for example, unsuccessful pushes try again but don't alert if the retry fails). - The script\u2019s remote URL parsing is a bit brittle, relying on shell command composition; using pure python (e.g., gitpython ) would be more robust. - Good scripting discipline overall; could benefit from modularization or adapting a library like GitPython for advanced setups.","title":"Simple Git Repo Sync Script"},{"location":"scripts/sync-repo-simple.py/#simple-git-repo-sync-script","text":"sync-repo-simple.py : Automates syncing a git repository, handling conflicts, stashing, and summary output.","title":"Simple Git Repo Sync Script"},{"location":"scripts/sync-repo-simple.py/#dependencies","text":"python3 - The script runs as a Python 3 interpreter. git - All operations use Git CLI commands. awk , sed , grep - Used in parsing remote URLs (ensure these standard POSIX tools are available, typically present on Arch Linux). ENV variables: EDITOR or falls back to vim / nvim for manual conflict resolution.","title":"Dependencies"},{"location":"scripts/sync-repo-simple.py/#description","text":"This script efficiently automates the process of synchronizing a git repository. It is specifically geared for day-to-day command-line workflow, such as on an Arch Linux system managed by qtile. The core functionality includes: Fetching and pulling (with rebase fallback): Detects local/remote divergence; if a fast-forward is not possible, a rebase is attempted. Conflict Handling: Handles both merge and stash conflicts, prompting for user intervention when required. It leverages your $EDITOR (default vim or nvim ) to resolve merge or stash conflicts interactively. Stashing: If local changes are present before pulling, they're automatically stashed and re-applied after remote updates, with dedicated handling for conflicted files. Automatic Commit and Push: If changes are detected in the repository, the script adds, commits (with an auto-generated message describing user and host), and pushes them. Summary Output: At the end of the sync, prints a contextual summary showing commit times and a diffstat of the recent change. The script is designed to be robust, stopping on errors for manual intervention, and aiming for minimal interaction except in cases of conflicts.","title":"Description"},{"location":"scripts/sync-repo-simple.py/#usage","text":"You can run this script directly from the terminal or integrate it into a keybinding or shortcut within qtile or your shell. Example usage: sync-repo-simple.py /path/to/your/repo Arguments: - repo_dir ( required ): Path to the git repository you wish to sync. Example: sync-repo-simple.py ~/projects/mydotfiles The script prints diagnostic and status information throughout the process. On conflicts, you'll be prompted interactively in the terminal to resolve them. Editor for Conflicts: Set your preferred editor in your environment: export EDITOR=nvim or let it default to vim / nvim . [!TIP] Critique: - The script assumes only one remote; in multi-remote setups, its behavior may not be as intended. - Command-line parsing is minimal; no verbosity flags or dry-run mode. - Using shell=True with user data in commands introduces potential security issues; safer subprocess argument handling is recommended. - Uses repeated subprocess calls ( git status -s is run several times), which could be minimized for performance. - Error messages are printed to stderr, but exit codes are inconsistent (for example, unsuccessful pushes try again but don't alert if the retry fails). - The script\u2019s remote URL parsing is a bit brittle, relying on shell command composition; using pure python (e.g., gitpython ) would be more robust. - Good scripting discipline overall; could benefit from modularization or adapting a library like GitPython for advanced setups.","title":"Usage"},{"location":"scripts/sync-repo-simple.sh/","text":"Simple Git Repo Synchronization Script sync-repo-simple.sh : Automates the process of syncing a local git repository with its remote, including smart error handling and conflict resolution. Dependencies git : Required for all version control operations. bash : The script is written in Bash and uses Bashisms. realpath : Resolves absolute file paths. ${EDITOR} (environment variable, e.g. vim , nvim ): For editing conflicted files during manual merge resolution. awk , sed , grep , wc : Used for minor command-line parsing and info extraction. Description This script simplifies the process of keeping a local git repository (or dotfiles repository) in sync with its remote counterpart. It combines fetching, merging/pulling, conflict management, auto-committing, and pushing into a single, streamlined command. Highlights: Automatic Stashing: If uncommitted changes are present, they're safely stashed before pulling new changes. Merge/Pull Conflict Handling: Interactive prompts help resolve merge and rebase conflicts, opening your editor for manual resolution when necessary. Stash Conflict Options: Select whether to keep the remote, local, or manually edited version of conflicted files after stashing. Commit Automation: Generates a succinct commit message and commits any modified files. Error Handling: Exits on errors, displaying an informative message. Summarized Sync: Prints a summary of changes at the end of the run. Functions: run_command : Prints and executes commands in real-time. handle_error : Graceful exits on terminal errors. generate_commit_message : Auto-generates a concise commit message. handle_merge_pull_conflicts / handle_stash_conflict : User-friendly prompts to guide through conflict resolution. display_summary : Presents a mini changelog summary after a successful sync. Usage You can run this script from a terminal. Optionally, you can bind it to a key in your qtile config for rapid one-key syncs. Command Syntax: sync-repo-simple.sh <path/to/git/repository> Examples: sync-repo-simple.sh ~/dotfiles sync-repo-simple.sh ~/Projects/my-coolapp Help Option: sync-repo-simple.sh -h Workflow: 1. Accepts a single directory argument (the local repo). 2. Checks that argument is a directory and a git repo. 3. Fetches, stashes if necessary, rebases/merges/pulls remote changes. 4. Guides you through any conflicts. 5. Commits and pushes any new local changes. 6. Prints a summary, then returns you to your starting directory. [!TIP] - While generally robust, the script would benefit from improved detection of \"no stashed changes\" (current logic may always attempt stash pop even if no stashes exist). - The commit message could be made more descriptive or customizable (maybe even integrating actual diff summaries or invoking an external LLM/text generator). - Error messages and help text are sparse (\"help\" placeholder); consider expanding for less ambiguity. - Handles only one remote and branch\u2014multi-remote/branch environments may need manual tweaking. - If used frequently, consider more granular logging or a dry-run mode for extra safety in destructive operations (such as reset --hard ).","title":"Simple Git Repo Synchronization Script"},{"location":"scripts/sync-repo-simple.sh/#simple-git-repo-synchronization-script","text":"sync-repo-simple.sh : Automates the process of syncing a local git repository with its remote, including smart error handling and conflict resolution.","title":"Simple Git Repo Synchronization Script"},{"location":"scripts/sync-repo-simple.sh/#dependencies","text":"git : Required for all version control operations. bash : The script is written in Bash and uses Bashisms. realpath : Resolves absolute file paths. ${EDITOR} (environment variable, e.g. vim , nvim ): For editing conflicted files during manual merge resolution. awk , sed , grep , wc : Used for minor command-line parsing and info extraction.","title":"Dependencies"},{"location":"scripts/sync-repo-simple.sh/#description","text":"This script simplifies the process of keeping a local git repository (or dotfiles repository) in sync with its remote counterpart. It combines fetching, merging/pulling, conflict management, auto-committing, and pushing into a single, streamlined command.","title":"Description"},{"location":"scripts/sync-repo-simple.sh/#highlights","text":"Automatic Stashing: If uncommitted changes are present, they're safely stashed before pulling new changes. Merge/Pull Conflict Handling: Interactive prompts help resolve merge and rebase conflicts, opening your editor for manual resolution when necessary. Stash Conflict Options: Select whether to keep the remote, local, or manually edited version of conflicted files after stashing. Commit Automation: Generates a succinct commit message and commits any modified files. Error Handling: Exits on errors, displaying an informative message. Summarized Sync: Prints a summary of changes at the end of the run.","title":"Highlights:"},{"location":"scripts/sync-repo-simple.sh/#functions","text":"run_command : Prints and executes commands in real-time. handle_error : Graceful exits on terminal errors. generate_commit_message : Auto-generates a concise commit message. handle_merge_pull_conflicts / handle_stash_conflict : User-friendly prompts to guide through conflict resolution. display_summary : Presents a mini changelog summary after a successful sync.","title":"Functions:"},{"location":"scripts/sync-repo-simple.sh/#usage","text":"You can run this script from a terminal. Optionally, you can bind it to a key in your qtile config for rapid one-key syncs. Command Syntax: sync-repo-simple.sh <path/to/git/repository> Examples: sync-repo-simple.sh ~/dotfiles sync-repo-simple.sh ~/Projects/my-coolapp Help Option: sync-repo-simple.sh -h Workflow: 1. Accepts a single directory argument (the local repo). 2. Checks that argument is a directory and a git repo. 3. Fetches, stashes if necessary, rebases/merges/pulls remote changes. 4. Guides you through any conflicts. 5. Commits and pushes any new local changes. 6. Prints a summary, then returns you to your starting directory. [!TIP] - While generally robust, the script would benefit from improved detection of \"no stashed changes\" (current logic may always attempt stash pop even if no stashes exist). - The commit message could be made more descriptive or customizable (maybe even integrating actual diff summaries or invoking an external LLM/text generator). - Error messages and help text are sparse (\"help\" placeholder); consider expanding for less ambiguity. - Handles only one remote and branch\u2014multi-remote/branch environments may need manual tweaking. - If used frequently, consider more granular logging or a dry-run mode for extra safety in destructive operations (such as reset --hard ).","title":"Usage"},{"location":"scripts/sync-repo.py/","text":"Python Git Repository Synchronizer sync-repo.py : Python utility for automating git repository synchronization with rich terminal UI, local/remote conflict handling, and progress feedback. Dependencies python (>=3.7): Required for script execution. rich : For terminal UI components (progress bars, tables, syntax highlighting, etc.). Install via: pip install rich git : Used for command-line git operations. User Environment: Editor: Uses $EDITOR (defaults to vim / nvim in some flows). Runs best in an interactive terminal. Other tools: (used via subprocess in subshells, typically already installed) awk , grep , sed (for repo name extraction) Description This script provides a streamlined workflow for synchronizing a git repository with its remote, automating fetch, pull, stash, add, commit, push, and handling both merge and stash conflicts interactively with concise feedback in a colorful Rich-style interface. Core features: Automatic Syncing: Runs git fetch , handles fast-forwards, and rebases automatically. Attempts to keep the workflow non-blocking unless manual intervention is strictly required. Stash/Conflict Handling: If you have uncommitted local changes, they're stashed and later re-applied. Any conflicts are detected, and the script offers clear options for manual resolution, keeping local/remote, or opening your $EDITOR for both merge or stash conflict resolution. Status and Summaries: Summarizes repository state before and after sync, includes commit, time, and diff statistics in a tabular view. Commit Automation: Automatically creates messages indicating the number of changes and basic user/host info. Functions breakdown: run_command : Prints, runs, and syntax-highlights git commands. handle_merge_pull_conflicts & handle_stash_conflict : User-friendly handling for git conflicts (merge or stash). display_summary : Shows key commit/diff info in a table. The script expects a git repo path, checks its validity, and runs in the selected folder. Usage Simple usage example (Arch, qtile, terminal): python /home/matias/.scripts/bin/sync-repo.py ~/dev/my_project Or for use as a keybinding (with qtile or similar WM): Assign the script to a key shortcut, optionally with a dmenu prompt to select the repo path. Behavior summary: - If everything is clean: fetch/pull/commit/push quietly. - If changes/conflicts: prompts you, guides you through resolution. Interactive resolution: During merge conflicts: [e] open $EDITOR , [a] abort merge, [s] skip commit. During stash conflicts: [r] use remote, [l] keep local, [m] manual edit. [!TIP] Robustness: Script mostly assumes origin/main structure. It could break for more complex remote configs or bare repos. Hardcoded flows: It assumes command-line tools like awk / sed in your shell, and some git commands are not cross-repo/branch robust. Environment reliance: Relies on $EDITOR , $USER , $HOSTNAME being set. Potential improvements: Add thorough exception handling for subprocesses. Make prompts/commands more configurable (select both branch and remote explicitly). Use proper git plumbing over shell-grade command parsing for increased reliability. Support dry-run mode or add logging. Allow non-interactive operation for automation (e.g., pass options via args for CI). Despite being highly functional for daily CLI-driven syncing and conflict handling, be mindful of repo-specific edge cases and multi-remote/branch workflows!","title":"Python Git Repository Synchronizer"},{"location":"scripts/sync-repo.py/#python-git-repository-synchronizer","text":"sync-repo.py : Python utility for automating git repository synchronization with rich terminal UI, local/remote conflict handling, and progress feedback.","title":"Python Git Repository Synchronizer"},{"location":"scripts/sync-repo.py/#dependencies","text":"python (>=3.7): Required for script execution. rich : For terminal UI components (progress bars, tables, syntax highlighting, etc.). Install via: pip install rich git : Used for command-line git operations. User Environment: Editor: Uses $EDITOR (defaults to vim / nvim in some flows). Runs best in an interactive terminal. Other tools: (used via subprocess in subshells, typically already installed) awk , grep , sed (for repo name extraction)","title":"Dependencies"},{"location":"scripts/sync-repo.py/#description","text":"This script provides a streamlined workflow for synchronizing a git repository with its remote, automating fetch, pull, stash, add, commit, push, and handling both merge and stash conflicts interactively with concise feedback in a colorful Rich-style interface.","title":"Description"},{"location":"scripts/sync-repo.py/#core-features","text":"Automatic Syncing: Runs git fetch , handles fast-forwards, and rebases automatically. Attempts to keep the workflow non-blocking unless manual intervention is strictly required. Stash/Conflict Handling: If you have uncommitted local changes, they're stashed and later re-applied. Any conflicts are detected, and the script offers clear options for manual resolution, keeping local/remote, or opening your $EDITOR for both merge or stash conflict resolution. Status and Summaries: Summarizes repository state before and after sync, includes commit, time, and diff statistics in a tabular view. Commit Automation: Automatically creates messages indicating the number of changes and basic user/host info.","title":"Core features:"},{"location":"scripts/sync-repo.py/#functions-breakdown","text":"run_command : Prints, runs, and syntax-highlights git commands. handle_merge_pull_conflicts & handle_stash_conflict : User-friendly handling for git conflicts (merge or stash). display_summary : Shows key commit/diff info in a table. The script expects a git repo path, checks its validity, and runs in the selected folder.","title":"Functions breakdown:"},{"location":"scripts/sync-repo.py/#usage","text":"Simple usage example (Arch, qtile, terminal): python /home/matias/.scripts/bin/sync-repo.py ~/dev/my_project Or for use as a keybinding (with qtile or similar WM): Assign the script to a key shortcut, optionally with a dmenu prompt to select the repo path. Behavior summary: - If everything is clean: fetch/pull/commit/push quietly. - If changes/conflicts: prompts you, guides you through resolution. Interactive resolution: During merge conflicts: [e] open $EDITOR , [a] abort merge, [s] skip commit. During stash conflicts: [r] use remote, [l] keep local, [m] manual edit. [!TIP] Robustness: Script mostly assumes origin/main structure. It could break for more complex remote configs or bare repos. Hardcoded flows: It assumes command-line tools like awk / sed in your shell, and some git commands are not cross-repo/branch robust. Environment reliance: Relies on $EDITOR , $USER , $HOSTNAME being set. Potential improvements: Add thorough exception handling for subprocesses. Make prompts/commands more configurable (select both branch and remote explicitly). Use proper git plumbing over shell-grade command parsing for increased reliability. Support dry-run mode or add logging. Allow non-interactive operation for automation (e.g., pass options via args for CI). Despite being highly functional for daily CLI-driven syncing and conflict handling, be mindful of repo-specific edge cases and multi-remote/branch workflows!","title":"Usage"},{"location":"scripts/sync-repo.sh/","text":"Sync Git Repository Utility sync-repo.sh : Synchronize a local git repository with its remote, handling stashes, conflicts, and pretty output Dependencies git : Essential version control tool. bat : Optional, for syntax-highlighted command and output display. glow : Optional, for rich markdown rendering in the terminal. External editor: Uses ${EDITOR} variable or defaults to vim / nvim for conflict resolutions. Description This script automates the process of syncing a local git repository with its upstream remote. It enhances standard git operations with user-friendly output, colorized messages, conflict resolution prompts, and a dry-run feature. Key features include: Pretty Output: If bat or glow are installed, the script visually enhances command output for easier comprehension. Error Handling: Functions for clear error reporting and early exit. Conflict Management: If merge or rebase conflicts occur, or if stashed changes cannot be applied cleanly, you are prompted with interactive options to resolve them: Open $EDITOR for manual resolution, Abort, or Accept either the local or remote version for stash conflicts. Automation Steps: Fetch remote updates. Stash local (uncommitted) changes if required. Try fast-forward merge, fall back to rebase. Re-apply stashed changes and resolve conflicts if needed. Add, commit with autogenerated message, and push changes. Run git maintenance run . Display a concise post-sync summary, leveraging glow if available. Main Functions print_command , run_command : Display and execute commands, optionally piping through bat . handle_merge_pull_conflicts , handle_stash_conflict : Interactive, user-driven resolution for common git problems. display_summary : Summarizes changes after sync. Usage/help output via print_usage . Usage In terminal: ./sync-repo.sh <repository_path> [--dry-run] [--help] Examples: ./sync-repo.sh ~/.scripts sync-repo.sh $SCRIPTS --dry-run git_sync $SCRIPTS You can assign this script to a qtile keybinding or run manually for interactive sync sessions. The --dry-run flag will show the intended actions without making changes. Use --help to display usage information. [!TIP] The script is robust and interactive, but depends on external editors and assumes user comfort with manual merge resolution in editors like vim or nvim . There is some redundancy in color definitions ( MAGENTA is set to the code for cyan); you may want to assign colors more carefully for clarity. Conflict handling is manual; could be enhanced by suggesting commands or providing more context on file differences before editing. Autogenerated commit messages are basic; you might want to integrate a smarter commit message generator or LLM hook if consistent, high-quality messages are important. Consider adding more checks: whether the remote branch exists, or prompting to set upstream if @{u} is undefined. The repo name deduction using sed might fail on remotes with unconventional URLs; a more robust parse could help.","title":"Sync Git Repository Utility"},{"location":"scripts/sync-repo.sh/#sync-git-repository-utility","text":"sync-repo.sh : Synchronize a local git repository with its remote, handling stashes, conflicts, and pretty output","title":"Sync Git Repository Utility"},{"location":"scripts/sync-repo.sh/#dependencies","text":"git : Essential version control tool. bat : Optional, for syntax-highlighted command and output display. glow : Optional, for rich markdown rendering in the terminal. External editor: Uses ${EDITOR} variable or defaults to vim / nvim for conflict resolutions.","title":"Dependencies"},{"location":"scripts/sync-repo.sh/#description","text":"This script automates the process of syncing a local git repository with its upstream remote. It enhances standard git operations with user-friendly output, colorized messages, conflict resolution prompts, and a dry-run feature. Key features include: Pretty Output: If bat or glow are installed, the script visually enhances command output for easier comprehension. Error Handling: Functions for clear error reporting and early exit. Conflict Management: If merge or rebase conflicts occur, or if stashed changes cannot be applied cleanly, you are prompted with interactive options to resolve them: Open $EDITOR for manual resolution, Abort, or Accept either the local or remote version for stash conflicts. Automation Steps: Fetch remote updates. Stash local (uncommitted) changes if required. Try fast-forward merge, fall back to rebase. Re-apply stashed changes and resolve conflicts if needed. Add, commit with autogenerated message, and push changes. Run git maintenance run . Display a concise post-sync summary, leveraging glow if available.","title":"Description"},{"location":"scripts/sync-repo.sh/#main-functions","text":"print_command , run_command : Display and execute commands, optionally piping through bat . handle_merge_pull_conflicts , handle_stash_conflict : Interactive, user-driven resolution for common git problems. display_summary : Summarizes changes after sync. Usage/help output via print_usage .","title":"Main Functions"},{"location":"scripts/sync-repo.sh/#usage","text":"In terminal: ./sync-repo.sh <repository_path> [--dry-run] [--help] Examples: ./sync-repo.sh ~/.scripts sync-repo.sh $SCRIPTS --dry-run git_sync $SCRIPTS You can assign this script to a qtile keybinding or run manually for interactive sync sessions. The --dry-run flag will show the intended actions without making changes. Use --help to display usage information. [!TIP] The script is robust and interactive, but depends on external editors and assumes user comfort with manual merge resolution in editors like vim or nvim . There is some redundancy in color definitions ( MAGENTA is set to the code for cyan); you may want to assign colors more carefully for clarity. Conflict handling is manual; could be enhanced by suggesting commands or providing more context on file differences before editing. Autogenerated commit messages are basic; you might want to integrate a smarter commit message generator or LLM hook if consistent, high-quality messages are important. Consider adding more checks: whether the remote branch exists, or prompting to set upstream if @{u} is undefined. The repo name deduction using sed might fail on remotes with unconventional URLs; a more robust parse could help.","title":"Usage"},{"location":"scripts/terminal_with_command.sh/","text":"terminal_with_command.sh terminal_with_command.sh : Opens a floating Alacritty terminal to execute a given command, showing output and staying open. Dependencies alacritty \u2014 GPU-accelerated terminal emulator (required for window class and title support). bash \u2014 The default shell for command execution. qtile (environment context) \u2014 Floating window support configured within your qtile setup. (Optional) Any command you wish to run in the floating terminal. Description This script is designed to launch a floating terminal window under the qtile window manager on Arch Linux, immediately executing the command(s) you pass as arguments. It utilizes alacritty , setting the window title to term_w_cmd and the window class to floating , making it easy to manage its floating behavior via qtile rules. After executing the provided command, the script keeps the shell open ( exec \"$SHELL\" ), allowing you to inspect output or run further commands interactively. By leveraging -e bash -i -c , the script ensures commands run in an interactive session, so aliases and functions are available and the environment is set up as in a normal shell. Passing \"$@\" ensures all arguments are interpreted as a single command with arguments, preserving quoting. Usage You can invoke the script from anywhere, e.g. within keybindings, scripts, or directly from a terminal. Basic usage: terminal_with_command.sh <command> [arguments] Examples: terminal_with_command.sh htop terminal_with_command.sh nvim ~/notes/todo.md terminal_with_command.sh bash -c \"echo Hello && sleep 5\" Note: You can assign this script to a keybinding in your qtile config to rapidly run diagnostics, editors, or monitoring tools in a floating terminal. [!NOTE] - The script does not validate command existence, so typos or missing commands will simply result in an error message inside the terminal window. - The script assumes alacritty is installed and in the PATH; this won\u2019t work with other terminal emulators unless modified. - If you want more flexibility (e.g. alternate terminal emulators or improved error handling), you could parameterize the terminal command and include checks for the command\u2019s existence. - Using \"$@\" with a leading _ as $1 inside the script ( \"$@\" after _ ) is a bash pattern to preserve all original arguments exactly, but if no command is given, the terminal will open to a shell prompt. If you would prefer to display a usage message or error, add a command presence check at the beginning.","title":"terminal_with_command.sh"},{"location":"scripts/terminal_with_command.sh/#terminal_with_commandsh","text":"terminal_with_command.sh : Opens a floating Alacritty terminal to execute a given command, showing output and staying open.","title":"terminal_with_command.sh"},{"location":"scripts/terminal_with_command.sh/#dependencies","text":"alacritty \u2014 GPU-accelerated terminal emulator (required for window class and title support). bash \u2014 The default shell for command execution. qtile (environment context) \u2014 Floating window support configured within your qtile setup. (Optional) Any command you wish to run in the floating terminal.","title":"Dependencies"},{"location":"scripts/terminal_with_command.sh/#description","text":"This script is designed to launch a floating terminal window under the qtile window manager on Arch Linux, immediately executing the command(s) you pass as arguments. It utilizes alacritty , setting the window title to term_w_cmd and the window class to floating , making it easy to manage its floating behavior via qtile rules. After executing the provided command, the script keeps the shell open ( exec \"$SHELL\" ), allowing you to inspect output or run further commands interactively. By leveraging -e bash -i -c , the script ensures commands run in an interactive session, so aliases and functions are available and the environment is set up as in a normal shell. Passing \"$@\" ensures all arguments are interpreted as a single command with arguments, preserving quoting.","title":"Description"},{"location":"scripts/terminal_with_command.sh/#usage","text":"You can invoke the script from anywhere, e.g. within keybindings, scripts, or directly from a terminal. Basic usage: terminal_with_command.sh <command> [arguments] Examples: terminal_with_command.sh htop terminal_with_command.sh nvim ~/notes/todo.md terminal_with_command.sh bash -c \"echo Hello && sleep 5\" Note: You can assign this script to a keybinding in your qtile config to rapidly run diagnostics, editors, or monitoring tools in a floating terminal. [!NOTE] - The script does not validate command existence, so typos or missing commands will simply result in an error message inside the terminal window. - The script assumes alacritty is installed and in the PATH; this won\u2019t work with other terminal emulators unless modified. - If you want more flexibility (e.g. alternate terminal emulators or improved error handling), you could parameterize the terminal command and include checks for the command\u2019s existence. - Using \"$@\" with a leading _ as $1 inside the script ( \"$@\" after _ ) is a bash pattern to preserve all original arguments exactly, but if no command is given, the terminal will open to a shell prompt. If you would prefer to display a usage message or error, add a command presence check at the beginning.","title":"Usage"},{"location":"scripts/text_spectrogram.py/","text":"Text-Mode Spectrogram (Live Microphone Viewer) text_spectrogram.py : Live real-time text-based spectrogram using microphone input and ANSI colors. Dependencies numpy : Fast numeric array and FFT operations. sounddevice : Real-time microphone data acquisition. shutil : Terminal size detection. Standard Python modules: math , argparse . ALSA or PulseAudio (system dependency) support for audio input on Linux. Terminal with ANSI color support (most modern terminals, including those in Arch Linux environments). (Optional) qtile: Can be bound to a keybinding for quick access. Description This script visualizes real-time audio frequencies from the default (or user-specified) microphone device as a colorful spectrogram directly in your terminal. How it works: - Uses sounddevice to capture live audio data. - Applies FFT (Fast Fourier Transform, via numpy ) to obtain frequency/amplitude information. - Draws the amplitude spectrum per block as a colored horizontal line using gradients of ANSI terminal color escapes (\u201cheatmap\u201d style). - Configurable parameters let you: - Change frequency range ( --range ) - Adjust gain interactively ( + to increase, - to decrease) - Set spectrogram width - Choose block duration (responsiveness vs. latency) - Select microphone device - List available input devices The UI is minimalist, relying on \u201cpress to quit,\u201d and responds to + and - for scaling. Usage General usage in terminal: python3 ~/.scripts/dev/text_spectrogram.py [options] List audio devices first if needed: python3 ~/.scripts/dev/text_spectrogram.py --list-devices Set device by index or substring, and adjust frequency range: python3 ~/.scripts/dev/text_spectrogram.py --device 2 --range 300 3500 Start with custom gain, width, or block duration: python3 ~/.scripts/dev/text_spectrogram.py --gain 20 --columns 100 --block-duration 40 During Execution: - + (then ): Double gain/contrast. - - (then ): Halve gain/contrast. - <Enter> or q/Q : Quit. Example (good for qtile keybinding): alacritty --class=\"SpectroTerm\" -e python3 ~/.scripts/dev/text_spectrogram.py --range 200 4000 [!TIP] - User Experience: Requires frequent keypresses for UI interaction, and printing to input blocks ongoing visualization (single-threaded: input() pauses spectrogram updates). - Improvements: - Replace input() with non-blocking key listening (e.g., curses or readchar ) for smooth, uninterrupted display. - Optionally support stereo or more channels. - Consider dynamic resizing based on terminal dimension changes (SIGWINCH). - Add a persistent info/header/status bar. - Performance: Might experience lag on slow terminals or with large FFT sizes. - Portability: Hard requirement for color and Unicode support; basic shell or tmux sessions may render colors poorly. - Exception Handling: Good coverage, but consider graceful restart of the stream if device disconnects.","title":"Text-Mode Spectrogram (Live Microphone Viewer)"},{"location":"scripts/text_spectrogram.py/#text-mode-spectrogram-live-microphone-viewer","text":"text_spectrogram.py : Live real-time text-based spectrogram using microphone input and ANSI colors.","title":"Text-Mode Spectrogram (Live Microphone Viewer)"},{"location":"scripts/text_spectrogram.py/#dependencies","text":"numpy : Fast numeric array and FFT operations. sounddevice : Real-time microphone data acquisition. shutil : Terminal size detection. Standard Python modules: math , argparse . ALSA or PulseAudio (system dependency) support for audio input on Linux. Terminal with ANSI color support (most modern terminals, including those in Arch Linux environments). (Optional) qtile: Can be bound to a keybinding for quick access.","title":"Dependencies"},{"location":"scripts/text_spectrogram.py/#description","text":"This script visualizes real-time audio frequencies from the default (or user-specified) microphone device as a colorful spectrogram directly in your terminal. How it works: - Uses sounddevice to capture live audio data. - Applies FFT (Fast Fourier Transform, via numpy ) to obtain frequency/amplitude information. - Draws the amplitude spectrum per block as a colored horizontal line using gradients of ANSI terminal color escapes (\u201cheatmap\u201d style). - Configurable parameters let you: - Change frequency range ( --range ) - Adjust gain interactively ( + to increase, - to decrease) - Set spectrogram width - Choose block duration (responsiveness vs. latency) - Select microphone device - List available input devices The UI is minimalist, relying on \u201cpress to quit,\u201d and responds to + and - for scaling.","title":"Description"},{"location":"scripts/text_spectrogram.py/#usage","text":"General usage in terminal: python3 ~/.scripts/dev/text_spectrogram.py [options] List audio devices first if needed: python3 ~/.scripts/dev/text_spectrogram.py --list-devices Set device by index or substring, and adjust frequency range: python3 ~/.scripts/dev/text_spectrogram.py --device 2 --range 300 3500 Start with custom gain, width, or block duration: python3 ~/.scripts/dev/text_spectrogram.py --gain 20 --columns 100 --block-duration 40 During Execution: - + (then ): Double gain/contrast. - - (then ): Halve gain/contrast. - <Enter> or q/Q : Quit. Example (good for qtile keybinding): alacritty --class=\"SpectroTerm\" -e python3 ~/.scripts/dev/text_spectrogram.py --range 200 4000 [!TIP] - User Experience: Requires frequent keypresses for UI interaction, and printing to input blocks ongoing visualization (single-threaded: input() pauses spectrogram updates). - Improvements: - Replace input() with non-blocking key listening (e.g., curses or readchar ) for smooth, uninterrupted display. - Optionally support stereo or more channels. - Consider dynamic resizing based on terminal dimension changes (SIGWINCH). - Add a persistent info/header/status bar. - Performance: Might experience lag on slow terminals or with large FFT sizes. - Portability: Hard requirement for color and Unicode support; basic shell or tmux sessions may render colors poorly. - Exception Handling: Good coverage, but consider graceful restart of the stream if device disconnects.","title":"Usage"},{"location":"scripts/tmux-help.py/","text":"Tmux Help Assistant Script tmux-help.py : A script to provide useful assistance and search functionalities for tmux commands and sections. Dependencies fuzzywuzzy : Python library for fuzzy string matching. argparse : To handle command-line arguments. configparser : To manage configuration file parsing. Basic utilities like os , sys , re , and subprocess . Description This script assists Arch Linux users utilizing qtile WM in navigating the tmux manual, searching for commands, and managing keybindings efficiently. It provides functionalities to list tmux commands either in their original sequence or categorized into themes like navigation, editing, etc. It supports fuzzy and exact search modes for tmux commands using the term entered by the user. It can also fetch and organize manpage sections for easy browsing. Crucially, the script checks and updates the tmux manpage and section data weekly (or manually upon request) from your system using man commands, storing these in a user-defined data directory. Usage The script can be run directly from a terminal with various options: python tmux-help.py [-h] [-L] [-f ARG] [-F ARG] [-s KEY] [-u] [-S [SECTION]] -L, --list-tmux : Lists tmux commands in the original order. -f, --find ARG : Performs a fuzzy search for keyword descriptions. -F, --find-exact ARG : Searches for an exact match (case insensitive). -s, --search KEY : Searches for a specific key and returns the associated commands. -u, --update : Updates the tmux manpage and sections files. -S, --section [SECTION] : Lists or displays a specific manpage section by number or name. Example : To perform a fuzzy search for \"split\" in tmux commands, run: python tmux-help.py --find \"split\" [!IMPORTANT] The script assumes the full_manpage_path and sections_path are pre-populated with the tmux manual content. The extract_keybindings function is yet to be implemented, which means keybinding extraction from manpages is incomplete. Consider integrating this part for full functionality. Additionally, ensure that the fuzzywuzzy library is installed; on Arch Linux, you can install it using pip .","title":"Tmux Help Assistant Script"},{"location":"scripts/tmux-help.py/#tmux-help-assistant-script","text":"tmux-help.py : A script to provide useful assistance and search functionalities for tmux commands and sections.","title":"Tmux Help Assistant Script"},{"location":"scripts/tmux-help.py/#dependencies","text":"fuzzywuzzy : Python library for fuzzy string matching. argparse : To handle command-line arguments. configparser : To manage configuration file parsing. Basic utilities like os , sys , re , and subprocess .","title":"Dependencies"},{"location":"scripts/tmux-help.py/#description","text":"This script assists Arch Linux users utilizing qtile WM in navigating the tmux manual, searching for commands, and managing keybindings efficiently. It provides functionalities to list tmux commands either in their original sequence or categorized into themes like navigation, editing, etc. It supports fuzzy and exact search modes for tmux commands using the term entered by the user. It can also fetch and organize manpage sections for easy browsing. Crucially, the script checks and updates the tmux manpage and section data weekly (or manually upon request) from your system using man commands, storing these in a user-defined data directory.","title":"Description"},{"location":"scripts/tmux-help.py/#usage","text":"The script can be run directly from a terminal with various options: python tmux-help.py [-h] [-L] [-f ARG] [-F ARG] [-s KEY] [-u] [-S [SECTION]] -L, --list-tmux : Lists tmux commands in the original order. -f, --find ARG : Performs a fuzzy search for keyword descriptions. -F, --find-exact ARG : Searches for an exact match (case insensitive). -s, --search KEY : Searches for a specific key and returns the associated commands. -u, --update : Updates the tmux manpage and sections files. -S, --section [SECTION] : Lists or displays a specific manpage section by number or name. Example : To perform a fuzzy search for \"split\" in tmux commands, run: python tmux-help.py --find \"split\" [!IMPORTANT] The script assumes the full_manpage_path and sections_path are pre-populated with the tmux manual content. The extract_keybindings function is yet to be implemented, which means keybinding extraction from manpages is incomplete. Consider integrating this part for full functionality. Additionally, ensure that the fuzzywuzzy library is installed; on Arch Linux, you can install it using pip .","title":"Usage"},{"location":"scripts/tmux_manager.py/","text":"Tmux Session Manager tmux_manager.py : Python utility to manage named tmux sessions using a YAML configuration file Dependencies tmux (Terminal multiplexer; must be installed and in your PATH ) python >=3.13 colorama : For colored terminal output pyyaml : For loading and saving YAML configs uv (optional, but script shebang expects uv run --script ; see uv ) Standard Python libraries: argparse , os , signal , subprocess , sys , pathlib Description This script manages your tmux sessions based on a central YAML config ( $SCRIPTS/config/tmux_sessions.yaml ). Sessions are defined in this file along with their windows and startup commands. The script supports: Listing all configured sessions and their statuses Launching specific or all sessions, optionally force-restarting them Autostarting only those flagged as autostart: true in config Interactive prompt to add new sessions via the CLI Output uses color coding for better readability (requires a truecolor terminal) Session definitions are like: sessions: - name: MUSIC autostart: true windows: - name: player command: cmus - name: edit command: nvim ~/Music/playlist.m3u Features: - Automatically initializes config if missing, including a sensible default - Handles proper process detachment and session killing/relaunching - Safety prompts for overwriting existing session configs - Graceful exit on Ctrl+C, with visually distinct warnings/errors Usage You may run tmux_manager.py in a terminal, or bind it to a key in your qtile setup (recommended for quick autostart, etc). Common invocations: ./tmux_manager.py --list # or (if using uv as in the shebang) uv run -- tmux_manager.py --list ./tmux_manager.py --session MUSIC # Launch \"MUSIC\" ./tmux_manager.py --session music --relaunch # Relaunch (kill & restart) \"MUSIC\" ./tmux_manager.py --all # Launch all configured sessions ./tmux_manager.py --auto # Launch only autostart sessions ./tmux_manager.py --add # Add a new session interactively For integrating autostart on login: Add to your qtile or user startup scripts: tmux_manager.py --auto Interactive Session Creation: $ ./tmux_manager.py --add === Adding New Tmux Session Configuration === Enter session name: dev Enable autostart? (y/N): y Enter window name (or empty to finish): python Enter command for this window: nvim main.py Enter window name (or empty to finish): Session 'DEV' added successfully! [!TIP] The script will always create $SCRIPTS/config/tmux_sessions.yaml if not present, but $SCRIPTS must be set (or it'll default to ~/scripts ). Make sure you have consistent environment handling. The script relies on tmux CLI; any custom tmux configuration might affect behavior. No built-in \"delete session from config\" option. Removing sessions must be done by editing the YAML directly, or implement an extra flag. Consider validating window commands before execution to surface errors proactively. Windows and commands are not deeply validated; misconfigured YAML (wrong keys, etc.) is only warned, not fatal. If run from within tmux, window management may behave unexpectedly (detached sessions).","title":"Tmux Session Manager"},{"location":"scripts/tmux_manager.py/#tmux-session-manager","text":"tmux_manager.py : Python utility to manage named tmux sessions using a YAML configuration file","title":"Tmux Session Manager"},{"location":"scripts/tmux_manager.py/#dependencies","text":"tmux (Terminal multiplexer; must be installed and in your PATH ) python >=3.13 colorama : For colored terminal output pyyaml : For loading and saving YAML configs uv (optional, but script shebang expects uv run --script ; see uv ) Standard Python libraries: argparse , os , signal , subprocess , sys , pathlib","title":"Dependencies"},{"location":"scripts/tmux_manager.py/#description","text":"This script manages your tmux sessions based on a central YAML config ( $SCRIPTS/config/tmux_sessions.yaml ). Sessions are defined in this file along with their windows and startup commands. The script supports: Listing all configured sessions and their statuses Launching specific or all sessions, optionally force-restarting them Autostarting only those flagged as autostart: true in config Interactive prompt to add new sessions via the CLI Output uses color coding for better readability (requires a truecolor terminal) Session definitions are like: sessions: - name: MUSIC autostart: true windows: - name: player command: cmus - name: edit command: nvim ~/Music/playlist.m3u Features: - Automatically initializes config if missing, including a sensible default - Handles proper process detachment and session killing/relaunching - Safety prompts for overwriting existing session configs - Graceful exit on Ctrl+C, with visually distinct warnings/errors","title":"Description"},{"location":"scripts/tmux_manager.py/#usage","text":"You may run tmux_manager.py in a terminal, or bind it to a key in your qtile setup (recommended for quick autostart, etc). Common invocations: ./tmux_manager.py --list # or (if using uv as in the shebang) uv run -- tmux_manager.py --list ./tmux_manager.py --session MUSIC # Launch \"MUSIC\" ./tmux_manager.py --session music --relaunch # Relaunch (kill & restart) \"MUSIC\" ./tmux_manager.py --all # Launch all configured sessions ./tmux_manager.py --auto # Launch only autostart sessions ./tmux_manager.py --add # Add a new session interactively For integrating autostart on login: Add to your qtile or user startup scripts: tmux_manager.py --auto Interactive Session Creation: $ ./tmux_manager.py --add === Adding New Tmux Session Configuration === Enter session name: dev Enable autostart? (y/N): y Enter window name (or empty to finish): python Enter command for this window: nvim main.py Enter window name (or empty to finish): Session 'DEV' added successfully! [!TIP] The script will always create $SCRIPTS/config/tmux_sessions.yaml if not present, but $SCRIPTS must be set (or it'll default to ~/scripts ). Make sure you have consistent environment handling. The script relies on tmux CLI; any custom tmux configuration might affect behavior. No built-in \"delete session from config\" option. Removing sessions must be done by editing the YAML directly, or implement an extra flag. Consider validating window commands before execution to surface errors proactively. Windows and commands are not deeply validated; misconfigured YAML (wrong keys, etc.) is only warned, not fatal. If run from within tmux, window management may behave unexpectedly (detached sessions).","title":"Usage"},{"location":"scripts/tmux_session.sh/","text":"tmux Session Launcher tmux_session.sh : Minimal script to launch a detached tmux session with a specified window and command Dependencies tmux : Terminal multiplexer. Required to create, attach, and manage terminal sessions. /usr/bin/bash : The script is written for bash and uses basic shell features. getopts : Shell builtin used for parsing options. Description This script provides a simplified interface for launching new tmux sessions on your Arch Linux environment, especially useful if you often automate terminal multiplexer setups (e.g., for development or testing environments from qtile keybindings). It ensures you specify: a tmux session name ( -s ), a window name within that session ( -w ), and a command to run inside the new window ( -c ). Key features: - Enforces all options as mandatory, avoiding ambiguous or partial session creation. - Useful as both an interactive tool or within scripts and window manager hooks. - Output echoes all parameters for quick verification. How it works: Parses options with getopts . Exits with usage info if any required option is missing. Launches a new detached ( -d ) tmux session with the assigned session/window name and command. Prints the resulting configuration for transparency. Usage To run the script directly from a terminal: ~/.scripts/bin/tmux_session.sh -s dev_session -w editor -c \"nvim\" Example use cases: - Starting a new Python REPL in a tmux session called py : ~/.scripts/bin/tmux_session.sh -s py -w repl -c \"python\" - Running a long process in its own session: ~/.scripts/bin/tmux_session.sh -s downloads -w aria -c \"aria2c http://example.com/file\" Integration with qtile: You can bind this script to a key or group launch: # Example (add to qtile config): Key([mod], \"F10\", lazy.spawn(\"~/.scripts/bin/tmux_session.sh -s scratchpad -w sysmon -c 'htop'\")) [!TIP] - This script doesn't check for existing sessions/windows with the same names, which may result in errors or duplicate sessions if you run the script with the same parameters multiple times. It would be beneficial to add a check to prevent accidental overwrite or to attach to existing sessions. - The command runs only in the first window; additional window management must be done manually. - Optionally, support for attaching to the session after creation, or making options optional (with sensible defaults), could improve usability. - Lastly, a -h|--help option for cleaner CLI usage would be handy.","title":"tmux Session Launcher"},{"location":"scripts/tmux_session.sh/#tmux-session-launcher","text":"tmux_session.sh : Minimal script to launch a detached tmux session with a specified window and command","title":"tmux Session Launcher"},{"location":"scripts/tmux_session.sh/#dependencies","text":"tmux : Terminal multiplexer. Required to create, attach, and manage terminal sessions. /usr/bin/bash : The script is written for bash and uses basic shell features. getopts : Shell builtin used for parsing options.","title":"Dependencies"},{"location":"scripts/tmux_session.sh/#description","text":"This script provides a simplified interface for launching new tmux sessions on your Arch Linux environment, especially useful if you often automate terminal multiplexer setups (e.g., for development or testing environments from qtile keybindings). It ensures you specify: a tmux session name ( -s ), a window name within that session ( -w ), and a command to run inside the new window ( -c ). Key features: - Enforces all options as mandatory, avoiding ambiguous or partial session creation. - Useful as both an interactive tool or within scripts and window manager hooks. - Output echoes all parameters for quick verification.","title":"Description"},{"location":"scripts/tmux_session.sh/#how-it-works","text":"Parses options with getopts . Exits with usage info if any required option is missing. Launches a new detached ( -d ) tmux session with the assigned session/window name and command. Prints the resulting configuration for transparency.","title":"How it works:"},{"location":"scripts/tmux_session.sh/#usage","text":"To run the script directly from a terminal: ~/.scripts/bin/tmux_session.sh -s dev_session -w editor -c \"nvim\" Example use cases: - Starting a new Python REPL in a tmux session called py : ~/.scripts/bin/tmux_session.sh -s py -w repl -c \"python\" - Running a long process in its own session: ~/.scripts/bin/tmux_session.sh -s downloads -w aria -c \"aria2c http://example.com/file\" Integration with qtile: You can bind this script to a key or group launch: # Example (add to qtile config): Key([mod], \"F10\", lazy.spawn(\"~/.scripts/bin/tmux_session.sh -s scratchpad -w sysmon -c 'htop'\")) [!TIP] - This script doesn't check for existing sessions/windows with the same names, which may result in errors or duplicate sessions if you run the script with the same parameters multiple times. It would be beneficial to add a check to prevent accidental overwrite or to attach to existing sessions. - The command runs only in the first window; additional window management must be done manually. - Optionally, support for attaching to the session after creation, or making options optional (with sensible defaults), could improve usability. - Lastly, a -h|--help option for cleaner CLI usage would be handy.","title":"Usage"},{"location":"scripts/toggle_picom.sh/","text":"Toggle Picom Compositor toggle_picom.sh : Simple script to toggle the Picom compositor on and off with notifications. Dependencies picom - Lightweight compositor for X11 pkill / pgrep - Process management commands (provided by procps-ng ) notify-send - Desktop notification tool (commonly provided by libnotify ) bash - The script interpreter Description This script checks if the picom compositor is currently running and toggles its state accordingly, providing a desktop notification on both actions: If picom is running, it sends a notification and terminates the process. If picom is not running, it notifies the user and starts picom in the background with the -b option. The script is especially useful in tiling window manager setups (such as qtile on Arch Linux), where you may want to quickly enable or disable window transparency and other compositor effects. Breakdown pgrep -x \"picom\" : Checks for running picom processes. notify-send : Sends a desktop notification for user feedback. pkill picom : Stops any running picom . picom -b : Starts picom in daemon/background mode. Usage This script can be executed directly, or bound to a keybinding in qtile for fast toggling. Direct terminal usage: /home/matias/.scripts/bin/toggle_picom.sh Example qtile keybinding (Python, in your config.py): Key([mod], \"F12\", lazy.spawn(\"/home/matias/.scripts/bin/toggle_picom.sh\")) tldr Just run the script; it will start or stop picom, with a notification. Useful to quickly disable compositing for screen sharing/gaming, or re-enable it for eye candy. [!TIP] The script is effective and minimal! Some potential improvements: - There's no error handling for cases where picom fails to start (e.g., config issues). - It assumes only one picom instance ever runs (multiple displays/setups might want more). - If you want custom configurations or logging, you could add arguments to pass extra options to picom . - On Wayland, picom is not relevant; script only applies for X11 sessions. - You could add audible feedback (e.g., with aplay or similar) for extra accessibility.","title":"Toggle Picom Compositor"},{"location":"scripts/toggle_picom.sh/#toggle-picom-compositor","text":"toggle_picom.sh : Simple script to toggle the Picom compositor on and off with notifications.","title":"Toggle Picom Compositor"},{"location":"scripts/toggle_picom.sh/#dependencies","text":"picom - Lightweight compositor for X11 pkill / pgrep - Process management commands (provided by procps-ng ) notify-send - Desktop notification tool (commonly provided by libnotify ) bash - The script interpreter","title":"Dependencies"},{"location":"scripts/toggle_picom.sh/#description","text":"This script checks if the picom compositor is currently running and toggles its state accordingly, providing a desktop notification on both actions: If picom is running, it sends a notification and terminates the process. If picom is not running, it notifies the user and starts picom in the background with the -b option. The script is especially useful in tiling window manager setups (such as qtile on Arch Linux), where you may want to quickly enable or disable window transparency and other compositor effects.","title":"Description"},{"location":"scripts/toggle_picom.sh/#breakdown","text":"pgrep -x \"picom\" : Checks for running picom processes. notify-send : Sends a desktop notification for user feedback. pkill picom : Stops any running picom . picom -b : Starts picom in daemon/background mode.","title":"Breakdown"},{"location":"scripts/toggle_picom.sh/#usage","text":"This script can be executed directly, or bound to a keybinding in qtile for fast toggling. Direct terminal usage: /home/matias/.scripts/bin/toggle_picom.sh Example qtile keybinding (Python, in your config.py): Key([mod], \"F12\", lazy.spawn(\"/home/matias/.scripts/bin/toggle_picom.sh\")) tldr Just run the script; it will start or stop picom, with a notification. Useful to quickly disable compositing for screen sharing/gaming, or re-enable it for eye candy. [!TIP] The script is effective and minimal! Some potential improvements: - There's no error handling for cases where picom fails to start (e.g., config issues). - It assumes only one picom instance ever runs (multiple displays/setups might want more). - If you want custom configurations or logging, you could add arguments to pass extra options to picom . - On Wayland, picom is not relevant; script only applies for X11 sessions. - You could add audible feedback (e.g., with aplay or similar) for extra accessibility.","title":"Usage"},{"location":"scripts/transform_symlink.sh/","text":"transform_symlink.sh transform_symlink.sh : Convert symlinks into copies of their targets (both files and directories). Dependencies fd : A fast, user-friendly alternative to find . Used here to discover symlinks recursively. fzf : Command-line fuzzy finder. Provides an interactive menu to select symlinks for transformation. bat : (Optional but used in the preview) For pretty-print file previews within fzf . Standard GNU utils: readlink , cp , rm . Description This script's core purpose is to \"unsymlink\" : it takes symlinks (files or directories that point elsewhere) and replaces each with a copy of the data they point to, deleting the link in the process. Key logic/features: If run without arguments , it uses fd to list all symlinks (depth 5 by default) below $PWD , filters the selection via fzf , and transforms the selected symlink. If run with one or more arguments , each argument is handled as a symlink path and processed in turn. Helpful usage function with colored terminal output details available options, synopsis, and examples. Handles basic error situations: not a symlink, or target does not exist. Symlink transformation is performed by: Validating the symlink and its target. Removing the symlink. Copying the target (using cp -r ) into the original symlink's path. Usage Run without arguments for interactive selection (uses fzf ): transform_symlink.sh Run with explicit paths to transform: transform_symlink.sh /path/to/link1 /path/to/link2 Print help: transform_symlink.sh --help In your Qtile config: You can bind a key to run this script (e.g., in a terminal): Key([mod], \"F7\", lazy.spawn(\"alacritty -e ~/.scripts/bin/transform_symlink.sh\")) [!TIP] The script is very useful for \u201cmaterializing\u201d data that might otherwise be lost if a symlink\u2019s target is deleted. Here are some potential enhancements: Relative Symlink Targets: The script assumes readlink outputs an absolute path. If the symlink uses a relative target, cp could fail or act unpredictably. Consider resolving to an absolute path first. Overwrite Warnings: The script always replaces the symlink, destroying any data present at that path if a copy fails midway. Adding a backup or prompt would be safer. Multiple Selection: In interactive mode, only one symlink can be selected. Consider allowing multi-select via fzf \u2019s --multi . Robustness: Better handling of symlink edge cases (e.g., broken symlinks, links with spaces/newlines). Preview Dependency: If bat is missing, the preview in fzf fails silently; consider fallback to cat . Otherwise, the script achieves its purpose efficiently and fits well into your Arch + Qtile workflow!","title":"transform_symlink.sh"},{"location":"scripts/transform_symlink.sh/#transform_symlinksh","text":"transform_symlink.sh : Convert symlinks into copies of their targets (both files and directories).","title":"transform_symlink.sh"},{"location":"scripts/transform_symlink.sh/#dependencies","text":"fd : A fast, user-friendly alternative to find . Used here to discover symlinks recursively. fzf : Command-line fuzzy finder. Provides an interactive menu to select symlinks for transformation. bat : (Optional but used in the preview) For pretty-print file previews within fzf . Standard GNU utils: readlink , cp , rm .","title":"Dependencies"},{"location":"scripts/transform_symlink.sh/#description","text":"This script's core purpose is to \"unsymlink\" : it takes symlinks (files or directories that point elsewhere) and replaces each with a copy of the data they point to, deleting the link in the process. Key logic/features: If run without arguments , it uses fd to list all symlinks (depth 5 by default) below $PWD , filters the selection via fzf , and transforms the selected symlink. If run with one or more arguments , each argument is handled as a symlink path and processed in turn. Helpful usage function with colored terminal output details available options, synopsis, and examples. Handles basic error situations: not a symlink, or target does not exist. Symlink transformation is performed by: Validating the symlink and its target. Removing the symlink. Copying the target (using cp -r ) into the original symlink's path.","title":"Description"},{"location":"scripts/transform_symlink.sh/#usage","text":"Run without arguments for interactive selection (uses fzf ): transform_symlink.sh Run with explicit paths to transform: transform_symlink.sh /path/to/link1 /path/to/link2 Print help: transform_symlink.sh --help In your Qtile config: You can bind a key to run this script (e.g., in a terminal): Key([mod], \"F7\", lazy.spawn(\"alacritty -e ~/.scripts/bin/transform_symlink.sh\")) [!TIP] The script is very useful for \u201cmaterializing\u201d data that might otherwise be lost if a symlink\u2019s target is deleted. Here are some potential enhancements: Relative Symlink Targets: The script assumes readlink outputs an absolute path. If the symlink uses a relative target, cp could fail or act unpredictably. Consider resolving to an absolute path first. Overwrite Warnings: The script always replaces the symlink, destroying any data present at that path if a copy fails midway. Adding a backup or prompt would be safer. Multiple Selection: In interactive mode, only one symlink can be selected. Consider allowing multi-select via fzf \u2019s --multi . Robustness: Better handling of symlink edge cases (e.g., broken symlinks, links with spaces/newlines). Preview Dependency: If bat is missing, the preview in fzf fails silently; consider fallback to cat . Otherwise, the script achieves its purpose efficiently and fits well into your Arch + Qtile workflow!","title":"Usage"},{"location":"scripts/try_the_bat_suit.sh/","text":"Try the Bat Suit try_the_bat_suit.sh : Fuzzy-finds and previews files with syntax highlighting in terminal using bat and fzf . Dependencies bat : A cat clone with syntax highlighting and Git integration. fzf : A general-purpose command-line fuzzy finder. fd : Simple, fast and user-friendly alternative to find . ripgrep ( rg ): Line-oriented search tool that recursively searches your directory. sed , cut : Standard Unix text processing tools (part of coreutils). Optional : Must be run under Bash; exported preview functions may require Bash-specific features. Description This script provides an enhanced and interactive command-line tool for browsing and syntax-highlighting files, especially useful within the terminal workflow on Arch Linux and the Qtile window manager. File Selection : If a file is provided as the first argument, it\u2019s used directly. Otherwise, it invokes fd to produce a list of files in the current directory tree and passes this list into fzf for fuzzy searching. Files are displayed in color. Language Highlighting : Uses bat --list-languages to obtain all available syntax highlighting options. Allows selection of a language in fzf (with blue highlighting). Preview : For each available language, it previews the chosen file with bat using plain output ( -pp ), applying the selected language for syntax highlighting. The preview is dynamically updated in the fzf pane via the Bash-exported function preview_cmd . Usage Run from any terminal window. If you want to select a file using fuzzy search: try_the_bat_suit.sh Or specify a file directly as a parameter: try_the_bat_suit.sh ~/projects/notes.md Navigating the UI: - When prompted, search for or select a syntax highlighting language. - See the live syntax-highlighted preview of your file as you navigate. - Can be assigned to a keybinding in Qtile for fast access. TL;DR # Fuzzy-pick and preview any file: try_the_bat_suit.sh # Preview a specific file: try_the_bat_suit.sh myfile.py [!TIP] If you cancel out of one of the two fzf prompts, the script exits without action\u2014there\u2019s no error handling for null selections. The fd file search is rooted in the current directory; if called from home, it might produce a very long list. Consider limiting it with arguments or cd\u2019ing to an appropriate folder before running. The preview function relies on Bash and exported shell functions, which won't work in shells like Zsh unless adapted. Error handling for missing dependencies (notably bat , fzf , fd , rg ) could be enhanced to provide user-friendly messages. The preview logic for language parsing is somewhat brittle ( lang=\"-l$(...)\" ); if the output format of bat --list-languages changes, this may break. Parsing could be made more robust.","title":"Try the Bat Suit"},{"location":"scripts/try_the_bat_suit.sh/#try-the-bat-suit","text":"try_the_bat_suit.sh : Fuzzy-finds and previews files with syntax highlighting in terminal using bat and fzf .","title":"Try the Bat Suit"},{"location":"scripts/try_the_bat_suit.sh/#dependencies","text":"bat : A cat clone with syntax highlighting and Git integration. fzf : A general-purpose command-line fuzzy finder. fd : Simple, fast and user-friendly alternative to find . ripgrep ( rg ): Line-oriented search tool that recursively searches your directory. sed , cut : Standard Unix text processing tools (part of coreutils). Optional : Must be run under Bash; exported preview functions may require Bash-specific features.","title":"Dependencies"},{"location":"scripts/try_the_bat_suit.sh/#description","text":"This script provides an enhanced and interactive command-line tool for browsing and syntax-highlighting files, especially useful within the terminal workflow on Arch Linux and the Qtile window manager. File Selection : If a file is provided as the first argument, it\u2019s used directly. Otherwise, it invokes fd to produce a list of files in the current directory tree and passes this list into fzf for fuzzy searching. Files are displayed in color. Language Highlighting : Uses bat --list-languages to obtain all available syntax highlighting options. Allows selection of a language in fzf (with blue highlighting). Preview : For each available language, it previews the chosen file with bat using plain output ( -pp ), applying the selected language for syntax highlighting. The preview is dynamically updated in the fzf pane via the Bash-exported function preview_cmd .","title":"Description"},{"location":"scripts/try_the_bat_suit.sh/#usage","text":"Run from any terminal window. If you want to select a file using fuzzy search: try_the_bat_suit.sh Or specify a file directly as a parameter: try_the_bat_suit.sh ~/projects/notes.md Navigating the UI: - When prompted, search for or select a syntax highlighting language. - See the live syntax-highlighted preview of your file as you navigate. - Can be assigned to a keybinding in Qtile for fast access.","title":"Usage"},{"location":"scripts/try_the_bat_suit.sh/#tldr","text":"# Fuzzy-pick and preview any file: try_the_bat_suit.sh # Preview a specific file: try_the_bat_suit.sh myfile.py [!TIP] If you cancel out of one of the two fzf prompts, the script exits without action\u2014there\u2019s no error handling for null selections. The fd file search is rooted in the current directory; if called from home, it might produce a very long list. Consider limiting it with arguments or cd\u2019ing to an appropriate folder before running. The preview function relies on Bash and exported shell functions, which won't work in shells like Zsh unless adapted. Error handling for missing dependencies (notably bat , fzf , fd , rg ) could be enhanced to provide user-friendly messages. The preview logic for language parsing is somewhat brittle ( lang=\"-l$(...)\" ); if the output format of bat --list-languages changes, this may break. Parsing could be made more robust.","title":"TL;DR"},{"location":"scripts/tui-gpt.py/","text":"Mother: Terminal TUI Chat with GPT tui-gpt.py : Interactive TUI chat application for GPT models themed as \"Mother\" from Aliens. Dependencies python >=3.12 \u2013 Minimum Python version required. openai \u2013 Official OpenAI Python client for API queries. textual \u2013 For building terminal GUI apps. rich \u2013 Used by textual for colors and themes. (Optional, commented out but referenced) llm \u2013 Alternative model interface (not actively used in this script). Environment variable: OPENAI_API_KEY must be set for authentication. Description This script launches a terminal-based chat interface styled after \"Mother\", the AI from the Alien movies. It uses the Textual library for a modern terminal UI, showing chat prompts and model responses with custom colors and borders for clarity. Key features: Prompt/Response distinction : Your input is styled differently from AI replies. Continuous streaming : AI responses appear in real time as they are received from OpenAI's GPT API ( gpt-4o-2024-08-06 ). Alien lore flavor : All model output is instructively themed as if spoken by \"Mother\" from Alien. Persistent vertical scroll : See previous chat history, auto-scroll enabled. Key components: MotherApp class: Main Textual app, handles UI layout and interactions. Prompt and Response : Widgets for displaying user questions and AI answers. Upon each input, the script creates a new API chat session and renders the stream live, suitable for direct interactive use in a terminal. Usage Set up your API key (one-time, or in your shell config): export OPENAI_API_KEY=\"sk-...\" Run the script directly from your terminal: python /home/matias/.scripts/bin/tui-gpt.py TL;DR Start chat: bash python tui-gpt.py Type your query, press Enter . Responses stream in real time. Exit with Ctrl+C or standard Textual quit sequences. Tip: Assign this script to a qtile keybinding for instant access from your Arch setup! [!NOTE] - No error handling for missing or invalid OPENAI_API_KEY \u2014fails with an exception if not set. - Script depends on a recent version of Textual; older Python packages might not render the interface as intended. - Code for the optional llm backend is present but commented, which could be cleaned up or made configurable. - API key is read directly from the environment; consider adding better secrets management. - Consider adding input history navigation and multi-turn chat context for a richer experience. - Currently, the system prompt is hardcoded; making it configurable at runtime could improve utility.","title":"Mother: Terminal TUI Chat with GPT"},{"location":"scripts/tui-gpt.py/#mother-terminal-tui-chat-with-gpt","text":"tui-gpt.py : Interactive TUI chat application for GPT models themed as \"Mother\" from Aliens.","title":"Mother: Terminal TUI Chat with GPT"},{"location":"scripts/tui-gpt.py/#dependencies","text":"python >=3.12 \u2013 Minimum Python version required. openai \u2013 Official OpenAI Python client for API queries. textual \u2013 For building terminal GUI apps. rich \u2013 Used by textual for colors and themes. (Optional, commented out but referenced) llm \u2013 Alternative model interface (not actively used in this script). Environment variable: OPENAI_API_KEY must be set for authentication.","title":"Dependencies"},{"location":"scripts/tui-gpt.py/#description","text":"This script launches a terminal-based chat interface styled after \"Mother\", the AI from the Alien movies. It uses the Textual library for a modern terminal UI, showing chat prompts and model responses with custom colors and borders for clarity. Key features: Prompt/Response distinction : Your input is styled differently from AI replies. Continuous streaming : AI responses appear in real time as they are received from OpenAI's GPT API ( gpt-4o-2024-08-06 ). Alien lore flavor : All model output is instructively themed as if spoken by \"Mother\" from Alien. Persistent vertical scroll : See previous chat history, auto-scroll enabled. Key components: MotherApp class: Main Textual app, handles UI layout and interactions. Prompt and Response : Widgets for displaying user questions and AI answers. Upon each input, the script creates a new API chat session and renders the stream live, suitable for direct interactive use in a terminal.","title":"Description"},{"location":"scripts/tui-gpt.py/#usage","text":"Set up your API key (one-time, or in your shell config): export OPENAI_API_KEY=\"sk-...\" Run the script directly from your terminal: python /home/matias/.scripts/bin/tui-gpt.py","title":"Usage"},{"location":"scripts/tui-gpt.py/#tldr","text":"Start chat: bash python tui-gpt.py Type your query, press Enter . Responses stream in real time. Exit with Ctrl+C or standard Textual quit sequences. Tip: Assign this script to a qtile keybinding for instant access from your Arch setup! [!NOTE] - No error handling for missing or invalid OPENAI_API_KEY \u2014fails with an exception if not set. - Script depends on a recent version of Textual; older Python packages might not render the interface as intended. - Code for the optional llm backend is present but commented, which could be cleaned up or made configurable. - API key is read directly from the environment; consider adding better secrets management. - Consider adding input history navigation and multi-turn chat context for a richer experience. - Currently, the system prompt is hardcoded; making it configurable at runtime could improve utility.","title":"TL;DR"},{"location":"scripts/ugc-python.py/","text":"UGC HTML Movie Titles Extractor ugc-python.py : Extracts and lists movie titles from HTML input piped via stdin. Dependencies uv Alternative Python runner/virtual env manager, used to execute the script with dependencies resolved. beautifulsoup4 HTML/XML parser; required for extracting movie titles from given HTML. python >= 3.13 Script is intended for newer Python (adjust if using an older version). Description This script reads HTML from standard input, parses it, and extracts a clean list of movie titles from the first <div class=\"info-wrapper\"> . It trims lines and filters out non-movie text blocks (like those starting with \"Films avec de l'audio description\" or \"Rappel\"), then prints each movie on a new line with a numeric index. Main steps: - Read the HTML content from stdin. - Parse with BeautifulSoup ( html.parser ). - Find the <div> with class info-wrapper . - Split and clean lines from the div's text. - Ignore irrelevant header/notification lines. - Output a numbered list to stdout. Usage Pipe HTML to the script: cat page.html | uv run --script --quiet /home/matias/.scripts/dev/ugc-python.py or (if executable): chmod +x /home/matias/.scripts/dev/ugc-python.py cat page.html | /home/matias/.scripts/dev/ugc-python.py Within Qtile: - You can bind this script to a keybinding or use it in combination with a web scraping or clipboard utility. Typical output: 1. The Godfather 2. Pulp Fiction 3. Interstellar ... [!CAUTION] The script assumes only a single relevant <div class=\"info-wrapper\"> . If the HTML structure changes or multiple such divs are present, some movies could be missed or repeated. No error is raised for missing dependencies; script will simply fail. Consider adding dependency checks. The shebang redundantly appears twice in the script. The second one ( #!/usr/bin/env python ) is ignored due to placement. Filtering logic is hardcoded for specific phrases (in French). If site notification text changes, false positives may appear. Would benefit from command-line options (for input file path or custom selectors). Adding optional output formats (CSV, JSON) could be useful for scripting.","title":"UGC HTML Movie Titles Extractor"},{"location":"scripts/ugc-python.py/#ugc-html-movie-titles-extractor","text":"ugc-python.py : Extracts and lists movie titles from HTML input piped via stdin.","title":"UGC HTML Movie Titles Extractor"},{"location":"scripts/ugc-python.py/#dependencies","text":"uv Alternative Python runner/virtual env manager, used to execute the script with dependencies resolved. beautifulsoup4 HTML/XML parser; required for extracting movie titles from given HTML. python >= 3.13 Script is intended for newer Python (adjust if using an older version).","title":"Dependencies"},{"location":"scripts/ugc-python.py/#description","text":"This script reads HTML from standard input, parses it, and extracts a clean list of movie titles from the first <div class=\"info-wrapper\"> . It trims lines and filters out non-movie text blocks (like those starting with \"Films avec de l'audio description\" or \"Rappel\"), then prints each movie on a new line with a numeric index. Main steps: - Read the HTML content from stdin. - Parse with BeautifulSoup ( html.parser ). - Find the <div> with class info-wrapper . - Split and clean lines from the div's text. - Ignore irrelevant header/notification lines. - Output a numbered list to stdout.","title":"Description"},{"location":"scripts/ugc-python.py/#usage","text":"Pipe HTML to the script: cat page.html | uv run --script --quiet /home/matias/.scripts/dev/ugc-python.py or (if executable): chmod +x /home/matias/.scripts/dev/ugc-python.py cat page.html | /home/matias/.scripts/dev/ugc-python.py Within Qtile: - You can bind this script to a keybinding or use it in combination with a web scraping or clipboard utility. Typical output: 1. The Godfather 2. Pulp Fiction 3. Interstellar ... [!CAUTION] The script assumes only a single relevant <div class=\"info-wrapper\"> . If the HTML structure changes or multiple such divs are present, some movies could be missed or repeated. No error is raised for missing dependencies; script will simply fail. Consider adding dependency checks. The shebang redundantly appears twice in the script. The second one ( #!/usr/bin/env python ) is ignored due to placement. Filtering logic is hardcoded for specific phrases (in French). If site notification text changes, false positives may appear. Would benefit from command-line options (for input file path or custom selectors). Adding optional output formats (CSV, JSON) could be useful for scripting.","title":"Usage"},{"location":"scripts/update_birthdays.sh/","text":"Update File Birthdays Utility update_birthdays.sh : Extracts and records the creation date (\"birthday\") of all files in your scripts directory using git history. Dependencies fd : A simple, fast and user-friendly alternative to find . Required for efficient file discovery. git : Used to determine the historical creation date of files. sed : For line manipulation and text substitution. basename : Extracts the filename from a path. sort , cut , tail , cat , rm : Standard UNIX utilities. Assumes $SCRIPTS environment variable is set, pointing to your scripts directory. Files must be tracked by git for the birthdays to be accurate. Description This script populates a CSV file ( bdays.csv in your $SCRIPTS directory) with the creation (\"birthday\") dates for every tracked file under $SCRIPTS . For each file found, it analyzes its git log using: git log --follow --format=%ai <file> | tail -n 1 This pipeline ensures the script finds the earliest commit date associated with each file (including across renames). The output lines contain YYYY-MM-DD, filename . After constructing an intermediate .temp file, the script substitutes any empty date fields (which could occur if a file is untracked by git) with today's date. It then sorts the CSV for better readability and reference. This is especially useful for tracking when scripts were first committed in a long-running dotfiles or scripts repository. Usage You can run this script at any time to update your birthday records: bash ~/.scripts/meta/update_birthdays.sh If you often edit or add new scripts, consider binding this script to a key sequence in your qtile config or having a cron or systemd timer trigger it periodically. Sample $bdays.csv output: 2022-03-01, launch_steam.sh 2023-02-16, get_wifi_info.sh 2024-05-02, update_birthdays.sh Just ensure that $SCRIPTS is set in your environment (e.g., in your .bashrc ): export SCRIPTS=\"$HOME/.scripts\" [!TIP] - Files not tracked by git will have today's date as their \"birthday\", which may not reflect their true age. - All basename calls strip directory paths; if multiple files have identical names in different directories, you'll lose location context. - Using echo > \"$BDAYS.temp\" truncates the file but leaves an empty line at the top of the CSV. Consider using : > \"$BDAYS.temp\" and filtering out empty lines. - To improve efficiency, process substitution or parallelization might help with large numbers of files. - Consider adding error handling (e.g., if $SCRIPTS isn't set, or if fd / git aren't available).","title":"Update File Birthdays Utility"},{"location":"scripts/update_birthdays.sh/#update-file-birthdays-utility","text":"update_birthdays.sh : Extracts and records the creation date (\"birthday\") of all files in your scripts directory using git history.","title":"Update File Birthdays Utility"},{"location":"scripts/update_birthdays.sh/#dependencies","text":"fd : A simple, fast and user-friendly alternative to find . Required for efficient file discovery. git : Used to determine the historical creation date of files. sed : For line manipulation and text substitution. basename : Extracts the filename from a path. sort , cut , tail , cat , rm : Standard UNIX utilities. Assumes $SCRIPTS environment variable is set, pointing to your scripts directory. Files must be tracked by git for the birthdays to be accurate.","title":"Dependencies"},{"location":"scripts/update_birthdays.sh/#description","text":"This script populates a CSV file ( bdays.csv in your $SCRIPTS directory) with the creation (\"birthday\") dates for every tracked file under $SCRIPTS . For each file found, it analyzes its git log using: git log --follow --format=%ai <file> | tail -n 1 This pipeline ensures the script finds the earliest commit date associated with each file (including across renames). The output lines contain YYYY-MM-DD, filename . After constructing an intermediate .temp file, the script substitutes any empty date fields (which could occur if a file is untracked by git) with today's date. It then sorts the CSV for better readability and reference. This is especially useful for tracking when scripts were first committed in a long-running dotfiles or scripts repository.","title":"Description"},{"location":"scripts/update_birthdays.sh/#usage","text":"You can run this script at any time to update your birthday records: bash ~/.scripts/meta/update_birthdays.sh If you often edit or add new scripts, consider binding this script to a key sequence in your qtile config or having a cron or systemd timer trigger it periodically. Sample $bdays.csv output: 2022-03-01, launch_steam.sh 2023-02-16, get_wifi_info.sh 2024-05-02, update_birthdays.sh Just ensure that $SCRIPTS is set in your environment (e.g., in your .bashrc ): export SCRIPTS=\"$HOME/.scripts\" [!TIP] - Files not tracked by git will have today's date as their \"birthday\", which may not reflect their true age. - All basename calls strip directory paths; if multiple files have identical names in different directories, you'll lose location context. - Using echo > \"$BDAYS.temp\" truncates the file but leaves an empty line at the top of the CSV. Consider using : > \"$BDAYS.temp\" and filtering out empty lines. - To improve efficiency, process substitution or parallelization might help with large numbers of files. - Consider adding error handling (e.g., if $SCRIPTS isn't set, or if fd / git aren't available).","title":"Usage"},{"location":"scripts/update_env.xsh/","text":"Update Environment File with API Keys update_env.xsh : Extracts current environment API keys and writes them to a .env file. Dependencies xonsh : Python-powered shell; needed to run .xsh scripts. Environment variables: The script expects all API keys to be present as environment variables ending with API_KEY . Description This script is designed to help you manage your API keys on your Arch Linux system (WM: qtile). It scans all your environment variables for keys whose names end with API_KEY , then creates (or overwrites) the file $HOME/.env containing these key-value pairs in standard dotenv format. Main Steps: Collect all environment variables ending with API_KEY using a dictionary comprehension. Format each KEY=VALUE pair, joined by newlines. Write this content to $HOME/.env . Example entry in .env after running: OPENAI_API_KEY=sk-XXXXX GITHUB_API_KEY=ghp-YYYYY Usage You can run this script directly in any terminal where xonsh is available: xonsh /home/matias/.scripts/bin/update_env.xsh Or, if it's executable: ~/.scripts/bin/update_env.xsh If you want to automate or bind it to a key (for example in qtile or sxhkd), simply add the above command. Typical workflow: 1. Export your API keys in your shell session: export OPENAI_API_KEY=sk-XXXXX export GITHUB_API_KEY=ghp-YYYYY 2. Run the script to update .env : update_env.xsh [!TIP] Security note: The script will overwrite your .env every time; make sure this is intended, especially if you store additional values in .env manually. Improvements: Consider adding: A warning or backup of previous .env before overwriting. Filtering or support for other secrets (not just API_KEY suffixes). Option to append instead of overwrite. Logging/echo output for feedback. Also, note that this script pulls variables from the current environment\u2014not from files or shells other than the one running the script. If running from a graphical launcher that doesn't inherit your terminal env, you might not get all keys.","title":"Update Environment File with API Keys"},{"location":"scripts/update_env.xsh/#update-environment-file-with-api-keys","text":"update_env.xsh : Extracts current environment API keys and writes them to a .env file.","title":"Update Environment File with API Keys"},{"location":"scripts/update_env.xsh/#dependencies","text":"xonsh : Python-powered shell; needed to run .xsh scripts. Environment variables: The script expects all API keys to be present as environment variables ending with API_KEY .","title":"Dependencies"},{"location":"scripts/update_env.xsh/#description","text":"This script is designed to help you manage your API keys on your Arch Linux system (WM: qtile). It scans all your environment variables for keys whose names end with API_KEY , then creates (or overwrites) the file $HOME/.env containing these key-value pairs in standard dotenv format.","title":"Description"},{"location":"scripts/update_env.xsh/#main-steps","text":"Collect all environment variables ending with API_KEY using a dictionary comprehension. Format each KEY=VALUE pair, joined by newlines. Write this content to $HOME/.env . Example entry in .env after running: OPENAI_API_KEY=sk-XXXXX GITHUB_API_KEY=ghp-YYYYY","title":"Main Steps:"},{"location":"scripts/update_env.xsh/#usage","text":"You can run this script directly in any terminal where xonsh is available: xonsh /home/matias/.scripts/bin/update_env.xsh Or, if it's executable: ~/.scripts/bin/update_env.xsh If you want to automate or bind it to a key (for example in qtile or sxhkd), simply add the above command. Typical workflow: 1. Export your API keys in your shell session: export OPENAI_API_KEY=sk-XXXXX export GITHUB_API_KEY=ghp-YYYYY 2. Run the script to update .env : update_env.xsh [!TIP] Security note: The script will overwrite your .env every time; make sure this is intended, especially if you store additional values in .env manually. Improvements: Consider adding: A warning or backup of previous .env before overwriting. Filtering or support for other secrets (not just API_KEY suffixes). Option to append instead of overwrite. Logging/echo output for feedback. Also, note that this script pulls variables from the current environment\u2014not from files or shells other than the one running the script. If running from a graphical launcher that doesn't inherit your terminal env, you might not get all keys.","title":"Usage"},{"location":"scripts/utils_update_symlinks.sh/","text":"Symlink Management Utility utils_update_symlinks.sh : maintain and update symlinks for $SCRIPTS into ~/.local/bin , logging actions and cleaning obsolete links Dependencies fd : Fast alternative to find used for searching executables in the $SCRIPTS directory glow : Render markdown output (for status output, e.g., \"# Cleaning...\") bat : Syntax-highlighted file viewer, used here for pretty-printing CSV files bash : Uses basic Bash functionality for file operations and control flow Description This script automates the management of symbolic links for all executables in your custom $SCRIPTS directory, ensuring your ~/.local/bin always contains up-to-date links for your scripts. It provides the following functionality: Removes stale symlinks from ~/.local/bin that no longer point to valid files (often due to deleted or moved scripts). Creates new symlinks for any scripts in $SCRIPTS missing from ~/.local/bin . Logs successes and errors in a detailed log file ( $SCRIPTS/meta/log/symlinking.log ). Maintains a CSV record of original script paths and their symlinks for tracking and troubleshooting. Utilizes clean and colorized output for clear feedback during operations. The script defines several functions: - log_info and log_error for colorized and timestamped logging, - remove_broken_symlinks to detect and remove invalid symlinks, - create_symlinks to safely generate new links, logging conflicts, - add_symlinks_to_csv which updates the main CSV file and displays it neatly with bat . CSV operations ensure you can always check which symlinks currently target scripts in your $SCRIPTS directory and facilitate quick auditing or rollback if needed. Usage TLDR: Run this script directly in your terminal; it doesn't accept arguments. ~/.scripts/meta/utils_update_symlinks.sh Typical flow: Cleans up and removes broken links in ~/.local/bin Creates symlinks from executables in $SCRIPTS to ~/.local/bin Updates a CSV log of all managed symlinks (shown with bat ) Automating / Scheduling: Assign to a keybinding in Qtile, or call from another script or periodic cron/systemd job for regular maintenance. [!TIP] Potential improvements and caveats: - The script expects environment variables ( $SCRIPTS , $HOME ) to be set\u2014ensure they're always defined, especially if run from cron or WM keybindings where the environment may be minimal. - Missing dependencies ( bat , fd , glow ) will cause failures; add checks at the top for more robust operation. - Consider handling spaces in file/dir names more robustly (e.g., using find -print0 and xargs -0 , or while IFS= read -r ). - You may want to improve conflict handling: presently, if a symlink exists and is incorrect, only a log message is printed\u2014optionally, offer to overwrite automatically. - For very large script directories, using bat every time may be slow; consider optional previewing or limiting. - Logging CSV appends to history but never trims\u2014periodically archive/rotate if the number of scripts grows substantially.","title":"Symlink Management Utility"},{"location":"scripts/utils_update_symlinks.sh/#symlink-management-utility","text":"utils_update_symlinks.sh : maintain and update symlinks for $SCRIPTS into ~/.local/bin , logging actions and cleaning obsolete links","title":"Symlink Management Utility"},{"location":"scripts/utils_update_symlinks.sh/#dependencies","text":"fd : Fast alternative to find used for searching executables in the $SCRIPTS directory glow : Render markdown output (for status output, e.g., \"# Cleaning...\") bat : Syntax-highlighted file viewer, used here for pretty-printing CSV files bash : Uses basic Bash functionality for file operations and control flow","title":"Dependencies"},{"location":"scripts/utils_update_symlinks.sh/#description","text":"This script automates the management of symbolic links for all executables in your custom $SCRIPTS directory, ensuring your ~/.local/bin always contains up-to-date links for your scripts. It provides the following functionality: Removes stale symlinks from ~/.local/bin that no longer point to valid files (often due to deleted or moved scripts). Creates new symlinks for any scripts in $SCRIPTS missing from ~/.local/bin . Logs successes and errors in a detailed log file ( $SCRIPTS/meta/log/symlinking.log ). Maintains a CSV record of original script paths and their symlinks for tracking and troubleshooting. Utilizes clean and colorized output for clear feedback during operations. The script defines several functions: - log_info and log_error for colorized and timestamped logging, - remove_broken_symlinks to detect and remove invalid symlinks, - create_symlinks to safely generate new links, logging conflicts, - add_symlinks_to_csv which updates the main CSV file and displays it neatly with bat . CSV operations ensure you can always check which symlinks currently target scripts in your $SCRIPTS directory and facilitate quick auditing or rollback if needed.","title":"Description"},{"location":"scripts/utils_update_symlinks.sh/#usage","text":"TLDR: Run this script directly in your terminal; it doesn't accept arguments. ~/.scripts/meta/utils_update_symlinks.sh Typical flow: Cleans up and removes broken links in ~/.local/bin Creates symlinks from executables in $SCRIPTS to ~/.local/bin Updates a CSV log of all managed symlinks (shown with bat ) Automating / Scheduling: Assign to a keybinding in Qtile, or call from another script or periodic cron/systemd job for regular maintenance. [!TIP] Potential improvements and caveats: - The script expects environment variables ( $SCRIPTS , $HOME ) to be set\u2014ensure they're always defined, especially if run from cron or WM keybindings where the environment may be minimal. - Missing dependencies ( bat , fd , glow ) will cause failures; add checks at the top for more robust operation. - Consider handling spaces in file/dir names more robustly (e.g., using find -print0 and xargs -0 , or while IFS= read -r ). - You may want to improve conflict handling: presently, if a symlink exists and is incorrect, only a log message is printed\u2014optionally, offer to overwrite automatically. - For very large script directories, using bat every time may be slow; consider optional previewing or limiting. - Logging CSV appends to history but never trims\u2014periodically archive/rotate if the number of scripts grows substantially.","title":"Usage"},{"location":"scripts/utopia.sh/","text":"Utopia Film Pages Downloader utopia.sh : Download selected Utopia Bordeaux film pages to HTML files Dependencies bash : Required as the script interpreter. curl : Used to fetch web content via HTTP. Description This script automates the process of fetching and saving several film information pages from the Utopia Bordeaux cinema website. The script defines a set of film IDs and downloads each corresponding web page, saving each as a separate HTML file ( film_<ID>.html ). Each download is announced in the terminal for progress tracking. Key Details: Base URL : The script targets pages under https://www.cinemas-utopia.org/bordeaux/index.php . ID Array : Edit the ids array to fetch different films without modifying core logic. Each HTML page is saved using its film ID for easy reference. Status messages provide feedback on progress. Usage You can execute this script from a terminal window or map it to a qtile keybinding if you routinely fetch such pages. bash /home/matias/.scripts/dev/utopia.sh Output will look like: Fetched content for film ID: 7767 Fetched content for film ID: 7860 ... All content fetched. To customize which films are fetched, simply edit the ids array: ids=(\"1234\" \"5678\") # Replace with your desired film IDs [!TIP] - Improvements : The script does not handle errors from curl (e.g., network issues, missing pages), meaning if a fetch fails, you'll end up with an empty or invalid HTML file but still get a \u201cFetched...\u201d message. Add || echo \"Failed to fetch...\" after the curl command or use set -e at the top with error checks for greater robustness. Enhancement : Consider creating an output directory for fetched files (e.g., ./utopia-films/film_$id.html ) to prevent cluttering your working directory. Support for command-line parameters to override IDs or the base URL would also add flexibility. Arch-specific advice : Ensure curl is installed ( sudo pacman -S curl ). No Arch-specific changes required otherwise. Qtile integration : The script is suitable for a keybinding in qtile; however, since it produces multiple files, you may want notifications or a summary at the end if run from a GUI context.","title":"Utopia Film Pages Downloader"},{"location":"scripts/utopia.sh/#utopia-film-pages-downloader","text":"utopia.sh : Download selected Utopia Bordeaux film pages to HTML files","title":"Utopia Film Pages Downloader"},{"location":"scripts/utopia.sh/#dependencies","text":"bash : Required as the script interpreter. curl : Used to fetch web content via HTTP.","title":"Dependencies"},{"location":"scripts/utopia.sh/#description","text":"This script automates the process of fetching and saving several film information pages from the Utopia Bordeaux cinema website. The script defines a set of film IDs and downloads each corresponding web page, saving each as a separate HTML file ( film_<ID>.html ). Each download is announced in the terminal for progress tracking. Key Details: Base URL : The script targets pages under https://www.cinemas-utopia.org/bordeaux/index.php . ID Array : Edit the ids array to fetch different films without modifying core logic. Each HTML page is saved using its film ID for easy reference. Status messages provide feedback on progress.","title":"Description"},{"location":"scripts/utopia.sh/#usage","text":"You can execute this script from a terminal window or map it to a qtile keybinding if you routinely fetch such pages. bash /home/matias/.scripts/dev/utopia.sh Output will look like: Fetched content for film ID: 7767 Fetched content for film ID: 7860 ... All content fetched. To customize which films are fetched, simply edit the ids array: ids=(\"1234\" \"5678\") # Replace with your desired film IDs [!TIP] - Improvements : The script does not handle errors from curl (e.g., network issues, missing pages), meaning if a fetch fails, you'll end up with an empty or invalid HTML file but still get a \u201cFetched...\u201d message. Add || echo \"Failed to fetch...\" after the curl command or use set -e at the top with error checks for greater robustness. Enhancement : Consider creating an output directory for fetched files (e.g., ./utopia-films/film_$id.html ) to prevent cluttering your working directory. Support for command-line parameters to override IDs or the base URL would also add flexibility. Arch-specific advice : Ensure curl is installed ( sudo pacman -S curl ). No Arch-specific changes required otherwise. Qtile integration : The script is suitable for a keybinding in qtile; however, since it produces multiple files, you may want notifications or a summary at the end if run from a GUI context.","title":"Usage"},{"location":"scripts/vimwiki.sh/","text":"Vimwiki FZF Launcher vimwiki.sh : Fuzzy search and open Markdown notes in Vim from your notes directory. Dependencies fd \u2013 fast/friendly alternative to find , used for finding Markdown files fzf \u2013 command-line interactive fuzzy finder bat \u2013 cat clone with syntax highlighting, used for file preview nvim \u2013 Neovim text editor (can be replaced with vim if neovim isn't preferred) Markdown notes stored in $HOME/notes (directory must exist) Description This script streamlines the process of opening Markdown notes with nvim , acting as a minimal yet powerful \"vimwiki\" dedicated to your $HOME/notes directory. Here's a breakdown of its workflow: fd lists all .md files directly under ~/notes (no recursion by default), outputting colored names. Output is piped to fzf for fuzzy selection. --ansi allows colored output. The preview pane uses bat to display the currently selected Markdown file with syntax highlighting. Pressing <Enter> opens the selected note in nvim . The process is interactive and efficient, making navigating and editing your Markdown personal wiki blazingly fast within a terminal session. Usage Just run the script from anywhere: ~/.scripts/bin/vimwiki.sh A fuzzy picker window will appear showcasing the files in ~/notes . Use type-to-filter to find your note. Up/Down, Type \u2013 Navigate/filter notes Preview Pane \u2013 See content instantly highlighted \u2013 Open the note in nvim Example tldr $ ~/.scripts/bin/vimwiki.sh # Fuzzy-search your notes; Enter opens in Neovim. Pro-Tip: Assign a keybinding in qtile to run this script for one-keypress access to your notes. [!TIP] - If you want recursive search inside subdirectories, add the -a flag to fd . - The script currently hardcodes $HOME/notes and .md files only; making these configurable (via env vars or args) would improve flexibility. - The obsolete commented-out line at the end ( vim ~/notes/\"$( ls ~/notes | fzf )\" ) can be removed for clarity. - Consider handling the case where fd , fzf , or bat aren't installed; a check could inform the user gracefully instead of failing silently. - Using nvim instead of vim may not match all setups\u2014let the user choose via a variable or fallback mechanism.","title":"Vimwiki FZF Launcher"},{"location":"scripts/vimwiki.sh/#vimwiki-fzf-launcher","text":"vimwiki.sh : Fuzzy search and open Markdown notes in Vim from your notes directory.","title":"Vimwiki FZF Launcher"},{"location":"scripts/vimwiki.sh/#dependencies","text":"fd \u2013 fast/friendly alternative to find , used for finding Markdown files fzf \u2013 command-line interactive fuzzy finder bat \u2013 cat clone with syntax highlighting, used for file preview nvim \u2013 Neovim text editor (can be replaced with vim if neovim isn't preferred) Markdown notes stored in $HOME/notes (directory must exist)","title":"Dependencies"},{"location":"scripts/vimwiki.sh/#description","text":"This script streamlines the process of opening Markdown notes with nvim , acting as a minimal yet powerful \"vimwiki\" dedicated to your $HOME/notes directory. Here's a breakdown of its workflow: fd lists all .md files directly under ~/notes (no recursion by default), outputting colored names. Output is piped to fzf for fuzzy selection. --ansi allows colored output. The preview pane uses bat to display the currently selected Markdown file with syntax highlighting. Pressing <Enter> opens the selected note in nvim . The process is interactive and efficient, making navigating and editing your Markdown personal wiki blazingly fast within a terminal session.","title":"Description"},{"location":"scripts/vimwiki.sh/#usage","text":"Just run the script from anywhere: ~/.scripts/bin/vimwiki.sh A fuzzy picker window will appear showcasing the files in ~/notes . Use type-to-filter to find your note. Up/Down, Type \u2013 Navigate/filter notes Preview Pane \u2013 See content instantly highlighted \u2013 Open the note in nvim","title":"Usage"},{"location":"scripts/vimwiki.sh/#example-tldr","text":"$ ~/.scripts/bin/vimwiki.sh # Fuzzy-search your notes; Enter opens in Neovim. Pro-Tip: Assign a keybinding in qtile to run this script for one-keypress access to your notes. [!TIP] - If you want recursive search inside subdirectories, add the -a flag to fd . - The script currently hardcodes $HOME/notes and .md files only; making these configurable (via env vars or args) would improve flexibility. - The obsolete commented-out line at the end ( vim ~/notes/\"$( ls ~/notes | fzf )\" ) can be removed for clarity. - Consider handling the case where fd , fzf , or bat aren't installed; a check could inform the user gracefully instead of failing silently. - Using nvim instead of vim may not match all setups\u2014let the user choose via a variable or fallback mechanism.","title":"Example tldr"},{"location":"scripts/vox.py/","text":"Vox Amp Models Lookup CLI vox.py : Command-line utility to list and describe Vox amp modeling options Dependencies python (3.x): Script interpreter pandas : Data manipulation and filtering tabulate : Pretty-printing tables in the terminal You can install python dependencies with: pip install pandas tabulate Description This Python script provides a command-line interface (CLI) for browsing, searching, and retrieving descriptions of various Vox amp models and modes, including clean, crunch, and metal options, with handy technical commentary for each. The data is organized in a pandas DataFrame and includes fields like name , mode , color , amp_name , and a descriptive text for each item. Key features: Tabular overview : With no argument, a truncated table (40 chars of description) is shown for all amp models\u2014quick for browsing. Detail lookup : Pass a row number, and you\u2019ll get the detailed model/mode header, full name, and the complete amp description. Filter by color : Use g , o , or r as argument to filter the table by model \"color\" type. Fuzzy text search : Enter a substring (case-insensitive) to see matching model names. Terminal output : All results are formatted as easy-to-read tables via tabulate . The script is great for quick information lookup from the terminal, especially useful for musicians or tinkerers who want to recall the sound profile or special features of a given amp model. Usage Display all Vox amp models (in brief): python /home/matias/.scripts/bin/vox.py Show full details for a specific model by index: python /home/matias/.scripts/bin/vox.py 17 Filter models by \"color\" category: python /home/matias/.scripts/bin/vox.py g # Green python /home/matias/.scripts/bin/vox.py o # Orange python /home/matias/.scripts/bin/vox.py r # Red Fuzzy search by part of amp name: python /home/matias/.scripts/bin/vox.py VOX python /home/matias/.scripts/bin/vox.py CLEAN You can bind this script to a keybinding in Qtile for fast pop-up queries, or run it from dmenu/rofi. [!TIP] Suggestions: - The script is very data-driven and easy to maintain, but: - The colors g/o/r could be explained (e.g., as amp classes or sound types) in the output or docstring. - There\u2019s no usage/help output ( -h or --help ). Consider adding an argument to print instructions. - Filtering by amp name is uses a basic substring search; regex or more fuzzy searching (or tab-completion) could help. - Some columns like amp_name are often empty\u2014maybe hide if empty? Or list those with named references separately. - Truncating description by default is good for performance, but a flag for \"full description\" in table would help. Overall, works well for bespoke terminal workflows or as a pop-up lookup window.","title":"Vox Amp Models Lookup CLI"},{"location":"scripts/vox.py/#vox-amp-models-lookup-cli","text":"vox.py : Command-line utility to list and describe Vox amp modeling options","title":"Vox Amp Models Lookup CLI"},{"location":"scripts/vox.py/#dependencies","text":"python (3.x): Script interpreter pandas : Data manipulation and filtering tabulate : Pretty-printing tables in the terminal You can install python dependencies with: pip install pandas tabulate","title":"Dependencies"},{"location":"scripts/vox.py/#description","text":"This Python script provides a command-line interface (CLI) for browsing, searching, and retrieving descriptions of various Vox amp models and modes, including clean, crunch, and metal options, with handy technical commentary for each. The data is organized in a pandas DataFrame and includes fields like name , mode , color , amp_name , and a descriptive text for each item.","title":"Description"},{"location":"scripts/vox.py/#key-features","text":"Tabular overview : With no argument, a truncated table (40 chars of description) is shown for all amp models\u2014quick for browsing. Detail lookup : Pass a row number, and you\u2019ll get the detailed model/mode header, full name, and the complete amp description. Filter by color : Use g , o , or r as argument to filter the table by model \"color\" type. Fuzzy text search : Enter a substring (case-insensitive) to see matching model names. Terminal output : All results are formatted as easy-to-read tables via tabulate . The script is great for quick information lookup from the terminal, especially useful for musicians or tinkerers who want to recall the sound profile or special features of a given amp model.","title":"Key features:"},{"location":"scripts/vox.py/#usage","text":"Display all Vox amp models (in brief): python /home/matias/.scripts/bin/vox.py Show full details for a specific model by index: python /home/matias/.scripts/bin/vox.py 17 Filter models by \"color\" category: python /home/matias/.scripts/bin/vox.py g # Green python /home/matias/.scripts/bin/vox.py o # Orange python /home/matias/.scripts/bin/vox.py r # Red Fuzzy search by part of amp name: python /home/matias/.scripts/bin/vox.py VOX python /home/matias/.scripts/bin/vox.py CLEAN You can bind this script to a keybinding in Qtile for fast pop-up queries, or run it from dmenu/rofi. [!TIP] Suggestions: - The script is very data-driven and easy to maintain, but: - The colors g/o/r could be explained (e.g., as amp classes or sound types) in the output or docstring. - There\u2019s no usage/help output ( -h or --help ). Consider adding an argument to print instructions. - Filtering by amp name is uses a basic substring search; regex or more fuzzy searching (or tab-completion) could help. - Some columns like amp_name are often empty\u2014maybe hide if empty? Or list those with named references separately. - Truncating description by default is good for performance, but a flag for \"full description\" in table would help. Overall, works well for bespoke terminal workflows or as a pop-up lookup window.","title":"Usage"},{"location":"scripts/wallpaper.sh/","text":"Wallpaper Rotator Script wallpaper.sh : Randomly select, set, or browse wallpapers using feh and optional GUIs. Dependencies feh : Image viewer, used here to set wallpapers. notify-send : Displays desktop notifications about wallpaper changes. fzfmenu.sh : Script-based fuzzy file selector (required for --select mode). yad : Simple GUI dialog tool (required for --gui mode). awk , find , shuf , sed , tail , head , basename : Standard UNIX utilities. The environment variable LOCALDATA must point to your data directory. Description This script allows you to manage wallpapers on your Arch Linux/qtile desktop environment in several flexible ways: Set a random wallpaper: It will choose a random file from ~/.wallpapers/ . Interactively select a wallpaper: Uses fzfmenu.sh for terminal fuzzy search, or a GUI dialog ( yad ). Go back to a previous wallpaper: Maintains a history in ~/.cache/wallpapers.log , lets you revert. Default fallback: If no argument is provided, a default preset wallpaper is applied. GUI selection & preview: Option to select and preview wallpapers with yad . Wherever a wallpaper is set, a notification pops up showing the file name. Logging/Caching: Each applied wallpaper is logged in a cache file. The log is auto-cleaned to remove successive duplicates for accurate history traversal. Usage # Set a random wallpaper wallpaper.sh --random # Fuzzy-select a wallpaper in terminal (needs fzfmenu.sh) wallpaper.sh --select # Use GUI to select & preview wallpaper (needs yad) wallpaper.sh --gui # Revert to previous wallpaper(s), default is the last one wallpaper.sh --previous # previous wallpaper wallpaper.sh --previous 2 # go back 2 wallpapers # Set wallpaper to the default wallpaper.sh Pro-tip: You can map any of these calls to keybindings within your qtile config for fast access. [!TIP] - Some improvements are possible: - The script assumes $LOCALDATA is set, but doesn't check for it or fallback when missing; add a check at the start. - The fzfmenu.sh dependency isn't standard and could cause confusion if not present. Consider a fallback or a check. - The cache grows indefinitely except for duplicate removal; consider limiting its total length. - The --gui mode relies on yad ; a test for its presence (and more robust error handling) would help reliability. - You may want to add file type filtering for --random and --select as is done in --gui . - There\u2019s potential for a race if two script invocations run at the same time and manipulate the cache. - Some find calls might be slow on huge directories; consider parallel alternatives for large collections.","title":"Wallpaper Rotator Script"},{"location":"scripts/wallpaper.sh/#wallpaper-rotator-script","text":"wallpaper.sh : Randomly select, set, or browse wallpapers using feh and optional GUIs.","title":"Wallpaper Rotator Script"},{"location":"scripts/wallpaper.sh/#dependencies","text":"feh : Image viewer, used here to set wallpapers. notify-send : Displays desktop notifications about wallpaper changes. fzfmenu.sh : Script-based fuzzy file selector (required for --select mode). yad : Simple GUI dialog tool (required for --gui mode). awk , find , shuf , sed , tail , head , basename : Standard UNIX utilities. The environment variable LOCALDATA must point to your data directory.","title":"Dependencies"},{"location":"scripts/wallpaper.sh/#description","text":"This script allows you to manage wallpapers on your Arch Linux/qtile desktop environment in several flexible ways: Set a random wallpaper: It will choose a random file from ~/.wallpapers/ . Interactively select a wallpaper: Uses fzfmenu.sh for terminal fuzzy search, or a GUI dialog ( yad ). Go back to a previous wallpaper: Maintains a history in ~/.cache/wallpapers.log , lets you revert. Default fallback: If no argument is provided, a default preset wallpaper is applied. GUI selection & preview: Option to select and preview wallpapers with yad . Wherever a wallpaper is set, a notification pops up showing the file name. Logging/Caching: Each applied wallpaper is logged in a cache file. The log is auto-cleaned to remove successive duplicates for accurate history traversal.","title":"Description"},{"location":"scripts/wallpaper.sh/#usage","text":"# Set a random wallpaper wallpaper.sh --random # Fuzzy-select a wallpaper in terminal (needs fzfmenu.sh) wallpaper.sh --select # Use GUI to select & preview wallpaper (needs yad) wallpaper.sh --gui # Revert to previous wallpaper(s), default is the last one wallpaper.sh --previous # previous wallpaper wallpaper.sh --previous 2 # go back 2 wallpapers # Set wallpaper to the default wallpaper.sh Pro-tip: You can map any of these calls to keybindings within your qtile config for fast access. [!TIP] - Some improvements are possible: - The script assumes $LOCALDATA is set, but doesn't check for it or fallback when missing; add a check at the start. - The fzfmenu.sh dependency isn't standard and could cause confusion if not present. Consider a fallback or a check. - The cache grows indefinitely except for duplicate removal; consider limiting its total length. - The --gui mode relies on yad ; a test for its presence (and more robust error handling) would help reliability. - You may want to add file type filtering for --random and --select as is done in --gui . - There\u2019s potential for a race if two script invocations run at the same time and manipulate the cache. - Some find calls might be slow on huge directories; consider parallel alternatives for large collections.","title":"Usage"},{"location":"scripts/wrapper.sh/","text":"Simple Bash Command Wrapper wrapper.sh : Wraps execution of any command, logs invocation with timestamp. Dependencies bash : Required to run the script. Any command you wish to wrap. The path /data/data/com.termux/files/home/log.txt must be writable.[footnote:On typical Arch Linux systems, this path is used by Termux on Android. Make sure it is adjusted for your environment.] date : Used to generate timestamps. sleep : Used for a 1-second delay at the end of the script. Description This script serves as a transparent wrapper around any command you wish to run. It performs the following steps: Executes the provided command line exactly as given. After completion, logs the current UNIX timestamp along with the invoked command to a log file at /data/data/com.termux/files/home/log.txt . Pauses for one second ( sleep 1 ) before exiting. It is particularly useful if you want a simple way to trace or audit temporary command executions (for development, debugging, or learning purposes). Structure $@ : Expands to all arguments given to the script\u2014this means it will directly run whatever full command you provide. echo \"$(date '+%s') - $@\" >> /data/data/com.termux/files/home/log.txt\" : Appends a log entry with the current date (as epoch seconds) and the command. sleep 1 : Waits for one second at the end. This gives you a moment to see command output (helpful if run in a terminal window that closes quickly). Usage The script can be run directly, given executable permissions, or called from other scripts, wrappers, or keybindings. You can use it with any command, passing the wrapped command as arguments. Examples: # Make the script executable (once only) chmod +x /home/matias/.scripts/dev/wrapper.sh # Run 'ls -l' and log the invocation /home/matias/.scripts/dev/wrapper.sh ls -l # Run an editor, e.g., nano on a file /home/matias/.scripts/dev/wrapper.sh nano test.txt Tip: Integrate with Qtile keybindings by calling this script from your configuration \u2014 especially for any command whose calls you want to audit! [!WARNING] The script hardcodes the log file path to a Termux-specific location ( /data/data/com.termux/files/home/log.txt ). On Arch Linux or a desktop environment, this path likely doesn\u2019t exist and may cause errors or fail silently. Consider parameterizing the log file location to make this script portable across devices and environments. Also, this script does not handle any errors from the wrapped commands\u2014it will only execute and log regardless of success or failure; capturing exit status might make logs more informative. Finally, be cautious when running commands with sensitive data, as everything is logged in plain text.","title":"Simple Bash Command Wrapper"},{"location":"scripts/wrapper.sh/#simple-bash-command-wrapper","text":"wrapper.sh : Wraps execution of any command, logs invocation with timestamp.","title":"Simple Bash Command Wrapper"},{"location":"scripts/wrapper.sh/#dependencies","text":"bash : Required to run the script. Any command you wish to wrap. The path /data/data/com.termux/files/home/log.txt must be writable.[footnote:On typical Arch Linux systems, this path is used by Termux on Android. Make sure it is adjusted for your environment.] date : Used to generate timestamps. sleep : Used for a 1-second delay at the end of the script.","title":"Dependencies"},{"location":"scripts/wrapper.sh/#description","text":"This script serves as a transparent wrapper around any command you wish to run. It performs the following steps: Executes the provided command line exactly as given. After completion, logs the current UNIX timestamp along with the invoked command to a log file at /data/data/com.termux/files/home/log.txt . Pauses for one second ( sleep 1 ) before exiting. It is particularly useful if you want a simple way to trace or audit temporary command executions (for development, debugging, or learning purposes).","title":"Description"},{"location":"scripts/wrapper.sh/#structure","text":"$@ : Expands to all arguments given to the script\u2014this means it will directly run whatever full command you provide. echo \"$(date '+%s') - $@\" >> /data/data/com.termux/files/home/log.txt\" : Appends a log entry with the current date (as epoch seconds) and the command. sleep 1 : Waits for one second at the end. This gives you a moment to see command output (helpful if run in a terminal window that closes quickly).","title":"Structure"},{"location":"scripts/wrapper.sh/#usage","text":"The script can be run directly, given executable permissions, or called from other scripts, wrappers, or keybindings. You can use it with any command, passing the wrapped command as arguments. Examples: # Make the script executable (once only) chmod +x /home/matias/.scripts/dev/wrapper.sh # Run 'ls -l' and log the invocation /home/matias/.scripts/dev/wrapper.sh ls -l # Run an editor, e.g., nano on a file /home/matias/.scripts/dev/wrapper.sh nano test.txt Tip: Integrate with Qtile keybindings by calling this script from your configuration \u2014 especially for any command whose calls you want to audit! [!WARNING] The script hardcodes the log file path to a Termux-specific location ( /data/data/com.termux/files/home/log.txt ). On Arch Linux or a desktop environment, this path likely doesn\u2019t exist and may cause errors or fail silently. Consider parameterizing the log file location to make this script portable across devices and environments. Also, this script does not handle any errors from the wrapped commands\u2014it will only execute and log regardless of success or failure; capturing exit status might make logs more informative. Finally, be cautious when running commands with sensitive data, as everything is logged in plain text.","title":"Usage"},{"location":"scripts/xephyr.sh/","text":"Xephyr + Qtile Testing Harness xephyr.sh : Launches a nested X session with Xephyr, running a development Qtile instance. Dependencies Xephyr : Lightweight nested X server, part of the xorg-server-xephyr package. python3 : Required for launching Qtile and (optionally) for guessing the terminal emulator. qtile : Should be installed; script assumes development inside or near the qtile source tree. libqtile.utils : Used by the helper line for terminal guessing. $APP (your terminal, like alacritty , urxvt , etc.): Automatically detected but can be overridden. readlink , dirname , sleep , env , wait , kill : Standard UNIX utilities. Description This script is a developer utility for quickly spawning a testing instance of your (possibly modified) Qtile window manager within a Xephyr nested X server. This workflow is very handy for Arch Linux users who want to test configuration changes, experiment with Qtile development, or debug their Qtile setup\u2014without interfering with their primary running X session. Key points: Screen and Display : Customizable with SCREEN_SIZE (default: 800x600) and XDISPLAY (default: :1). Terminal Launch : Attempts to detect your preferred terminal, or will use one you specify with $APP . Qtile Logging : Set LOG_LEVEL environment variable to control verbosity (default: INFO ). Isolation : The script launches Qtile under the nested server and starts your terminal. When the Qtile session ends, Xephyr is killed\u2014cleaning up automatically. Flow: Launches Xephyr. Starts a Qtile test instance with the same configuration as your real session. Spawns a terminal inside the nested X session. Tears down everything when done. Usage You will usually run this from a terminal; it's interactive and best not bound to a keyboard shortcut (due to cleanup requirements). Basic usage: $ ~/.scripts/dev/xephyr.sh To specify a screen size or display number: $ SCREEN_SIZE=1280x720 XDISPLAY=:2 ~/.scripts/dev/xephyr.sh To run Qtile with debug logging: $ LOG_LEVEL=DEBUG ~/.scripts/dev/xephyr.sh To override the terminal used inside the session: $ APP=alacritty ~/.scripts/dev/xephyr.sh To pass extra arguments to qtile start : $ ~/.scripts/dev/xephyr.sh --some-qtile-option [!TIP] Possible Improvements: - The script assumes Qtile's start binary is available at ../bin/qtile relative to the script, which is brittle; consider a more flexible lookup. - No check if required programs ( Xephyr , Qtile, terminal) are installed\u2014adding basic dependency checks could make the tool friendlier. - sleep 1 may be insufficient on some systems for Xephyr to initialize; consider a more robust \"wait for display ready\" mechanism. - Arguments after the script are passed only to qtile start , not Xephyr or the terminal. Make this explicit in documentation, or add more flexible argument parsing. - No error handling for background process termination; if Qtile or the terminal crashes, Xephyr may remain orphaned. - On modern Arch instals, you may want to explicitly use python or python3 . The PYTHON variable can be set to suit, but clarify its need and defaults and possibly fallback better if neither are available.","title":"Xephyr + Qtile Testing Harness"},{"location":"scripts/xephyr.sh/#xephyr-qtile-testing-harness","text":"xephyr.sh : Launches a nested X session with Xephyr, running a development Qtile instance.","title":"Xephyr + Qtile Testing Harness"},{"location":"scripts/xephyr.sh/#dependencies","text":"Xephyr : Lightweight nested X server, part of the xorg-server-xephyr package. python3 : Required for launching Qtile and (optionally) for guessing the terminal emulator. qtile : Should be installed; script assumes development inside or near the qtile source tree. libqtile.utils : Used by the helper line for terminal guessing. $APP (your terminal, like alacritty , urxvt , etc.): Automatically detected but can be overridden. readlink , dirname , sleep , env , wait , kill : Standard UNIX utilities.","title":"Dependencies"},{"location":"scripts/xephyr.sh/#description","text":"This script is a developer utility for quickly spawning a testing instance of your (possibly modified) Qtile window manager within a Xephyr nested X server. This workflow is very handy for Arch Linux users who want to test configuration changes, experiment with Qtile development, or debug their Qtile setup\u2014without interfering with their primary running X session.","title":"Description"},{"location":"scripts/xephyr.sh/#key-points","text":"Screen and Display : Customizable with SCREEN_SIZE (default: 800x600) and XDISPLAY (default: :1). Terminal Launch : Attempts to detect your preferred terminal, or will use one you specify with $APP . Qtile Logging : Set LOG_LEVEL environment variable to control verbosity (default: INFO ). Isolation : The script launches Qtile under the nested server and starts your terminal. When the Qtile session ends, Xephyr is killed\u2014cleaning up automatically.","title":"Key points:"},{"location":"scripts/xephyr.sh/#flow","text":"Launches Xephyr. Starts a Qtile test instance with the same configuration as your real session. Spawns a terminal inside the nested X session. Tears down everything when done.","title":"Flow:"},{"location":"scripts/xephyr.sh/#usage","text":"You will usually run this from a terminal; it's interactive and best not bound to a keyboard shortcut (due to cleanup requirements). Basic usage: $ ~/.scripts/dev/xephyr.sh To specify a screen size or display number: $ SCREEN_SIZE=1280x720 XDISPLAY=:2 ~/.scripts/dev/xephyr.sh To run Qtile with debug logging: $ LOG_LEVEL=DEBUG ~/.scripts/dev/xephyr.sh To override the terminal used inside the session: $ APP=alacritty ~/.scripts/dev/xephyr.sh To pass extra arguments to qtile start : $ ~/.scripts/dev/xephyr.sh --some-qtile-option [!TIP] Possible Improvements: - The script assumes Qtile's start binary is available at ../bin/qtile relative to the script, which is brittle; consider a more flexible lookup. - No check if required programs ( Xephyr , Qtile, terminal) are installed\u2014adding basic dependency checks could make the tool friendlier. - sleep 1 may be insufficient on some systems for Xephyr to initialize; consider a more robust \"wait for display ready\" mechanism. - Arguments after the script are passed only to qtile start , not Xephyr or the terminal. Make this explicit in documentation, or add more flexible argument parsing. - No error handling for background process termination; if Qtile or the terminal crashes, Xephyr may remain orphaned. - On modern Arch instals, you may want to explicitly use python or python3 . The PYTHON variable can be set to suit, but clarify its need and defaults and possibly fallback better if neither are available.","title":"Usage"},{"location":"scripts/you_are_not_documented.sh/","text":"you_are_not_documented.sh you_are_not_documented.sh : Finds scripts lacking specific inline documentation tags Dependencies rg : ripgrep, required for fast file searching and text matching. Environment variable: $SCRIPTS , should point to the directory containing your scripts. Description This script helps you manage inline documentation in your script repository by finding Bash (or other) scripts that do not contain a documentation marker of the form #INFO:# . It uses ripgrep ( rg ) for efficient text searching. The steps are: 1. rg '#INFO:#' --files-without-match \"$SCRIPTS\" Searches the $SCRIPTS directory for all files without the #INFO:# tag. 2. The results are piped through rg -v '/docs/|/config/|\\.csv|\\.md' This excludes any matches that are: - In /docs/ or /config/ subdirectories - Files ending with .csv or .md This is particularly useful for enforcing documentation standards in a self-maintained script library (like your dotfiles or personal utilities), especially when evolving a large or shared codebase under qtile on Arch Linux. Usage Make sure: - ripgrep is installed ( pacman -S ripgrep ). - The environment variable $SCRIPTS is set correctly (i.e., points to the directory containing your scripts). Example Usage: export SCRIPTS=\"$HOME/.scripts/bin\" ~/.scripts/bin/you_are_not_documented.sh You can bind this command to a key in your qtile config or run it manually in the terminal to audit script documentation. [!TIP] The script depends on the $SCRIPTS environment variable, but doesn't check if it's set or valid; adding a check with a friendly error could be helpful. Currently, it only looks for the single tag #INFO:# . If your documentation scheme changes or adds extra markers, you'll need to update the script. Excludes are hardcoded; you might want to make those configurable. Only works for single-level excludes and extensions; if your structure grows more complex, consider allowing .gitignore-style rules. No shebang checks: the script will match all files, not just scripts. Filtering by file extension or executable bit could improve accuracy.","title":"you_are_not_documented.sh"},{"location":"scripts/you_are_not_documented.sh/#you_are_not_documentedsh","text":"you_are_not_documented.sh : Finds scripts lacking specific inline documentation tags","title":"you_are_not_documented.sh"},{"location":"scripts/you_are_not_documented.sh/#dependencies","text":"rg : ripgrep, required for fast file searching and text matching. Environment variable: $SCRIPTS , should point to the directory containing your scripts.","title":"Dependencies"},{"location":"scripts/you_are_not_documented.sh/#description","text":"This script helps you manage inline documentation in your script repository by finding Bash (or other) scripts that do not contain a documentation marker of the form #INFO:# . It uses ripgrep ( rg ) for efficient text searching. The steps are: 1. rg '#INFO:#' --files-without-match \"$SCRIPTS\" Searches the $SCRIPTS directory for all files without the #INFO:# tag. 2. The results are piped through rg -v '/docs/|/config/|\\.csv|\\.md' This excludes any matches that are: - In /docs/ or /config/ subdirectories - Files ending with .csv or .md This is particularly useful for enforcing documentation standards in a self-maintained script library (like your dotfiles or personal utilities), especially when evolving a large or shared codebase under qtile on Arch Linux.","title":"Description"},{"location":"scripts/you_are_not_documented.sh/#usage","text":"Make sure: - ripgrep is installed ( pacman -S ripgrep ). - The environment variable $SCRIPTS is set correctly (i.e., points to the directory containing your scripts). Example Usage: export SCRIPTS=\"$HOME/.scripts/bin\" ~/.scripts/bin/you_are_not_documented.sh You can bind this command to a key in your qtile config or run it manually in the terminal to audit script documentation. [!TIP] The script depends on the $SCRIPTS environment variable, but doesn't check if it's set or valid; adding a check with a friendly error could be helpful. Currently, it only looks for the single tag #INFO:# . If your documentation scheme changes or adds extra markers, you'll need to update the script. Excludes are hardcoded; you might want to make those configurable. Only works for single-level excludes and extensions; if your structure grows more complex, consider allowing .gitignore-style rules. No shebang checks: the script will match all files, not just scripts. Filtering by file extension or executable bit could improve accuracy.","title":"Usage"}]}